# Introducción a C
C es un lenguaje de programación desarrollado en el año 1972 por Dennis Ritchie. El lenguaje C es un lenguaje estructuro el cual a pesar de ser un lenguaje de alto nivel da acceso a hacer uso de la memoria, registros, etc.

C es un lenguaje compilado, para poder compilar y ejecutar un archivo llamado HelloWorld.c, se realiza de la siguiente manera:

~~~C
$ gcc HelloWorld.c		// se compila el archivo
$ ./a.out				// se ejecuta el programa
$ Hello World 			//output del programa, en este caso
~~~

## Comentarios en c
~~~C
// para realizar comentarios de una línea
/* TODO LO QUE ESTE DENTRO 
	DE ESTA PARTE ES UN COMENTARIO */ 
~~~~
## Tipos de declaración

Las variables deben ser declaradas antes de usarse y el tipo de la variable no puede ser cambiado. En C, el tamaño de la variable depende de la arquitectura en la cual se este trabajando.

Si no se inicializa el valor de la variable, al imprimirla imprimirá la "basura", es decir, los datos que estaban ubicados  en la dirección de memoria en donde la variable fue guardada.

## Declaración de constantes
~~~C
#define CONSTANTE_DEFINE 25
enum T_ENUM { CONSTANTE_ENUM = 25 };
const int CONSTANTE_VARIABLE = 25;
~~~
## Valores Booleanos en C

Es un importante mencionar que en C todo lo que sea diferente de 0 se considera verdadero, es decir si se desea representar el valor falso se debe utilizar un 0. 

## Funciones en C

- En la declaración de la función debe ir el tipo de dato del valor de retorno y de todos los argumentos.
- void para declarar funciones sin nigun retorno.
- Deben ser declaradas antes de ser usadas.

#### Ejemplo: Función que retorna un valor entero.

~~~C
int funcion1(){
	x = 10;	
	return x;
}
~~~
#### Ejemplo: Función que no tiene un valor de retorno y que recibe un entero como argumento.
~~~C
void function2(int x){
	printf("Hola Mundo %d!", x);
}
~~~

## Estructuras en c

Es un tipo de dato compuesto el cual permite almacenar un conjunto de datos de tipos diferentes. Es muy similar a lo que en java se conoce como clases, pero sin métodos.

#### Ejemplo: 
~~~C
int main(void){
	/*definimos una estructura en C 
	llamada Point que contiene 2 variables de tipo entero.
	*/
	typedef struct { int x, y; } Point; 
		Point p1; //se define una variable de tipo Point llamada p1
		//asignanción de valores a las variables x y y de la variable p1.
		p1.x = 2; 
		p1.y = 4; 
		return 0;
	} 
~~~

## Punteros en c

Un puntero es una variable la cual guarda la dirección de memoria de otra variable o de algún dato. Es necesario al igual que una simple variable asignar el tipo que representa.

#### Ejemplo:
~~~C
int *pi; //declaración de un puntero de datos enteros.
char *pc; //declaración de un puntero dé datos tipo char.
~~~

#### Ejemplo: Puntero de tipo arbitrario.
~~~C
//definición de un puntero el cual puede ser asignado a diferentes tipos.
void *vp;
~~~
#### Ejemplo:
~~~C
int x = 10;
int *pi = &x; //al puntero pi se le asigna la dirección de memoria de la variable x.	
int valorx = *pi; // en la variable valorx se almacena el valor al cual apunta la variable pi, en este ejemplo es 10
~~~
C pasa los argumentos a una función por valor, esto quiere decir que la información de la variable que se recibe en la función es almacenada en una diferente dirección de memoria por lo tanto si la variable se altera dentro de la función, solo será modificada en el contexto de la función.

# C memory managment
- Estructura de memoria cuando se ejecuta un programa
- Hay una parte donde se guarda en código de nuestro programa, las "instrucciones"
- Area de datos estático: comienza un poco "arriba" del codigo (hablando de direcciones de memoria). Cada OS puede ponerle a cada sección un límite distinto. Las variables globales se guardan aqui. En el ejemplo de la diapositiva: static_data se guarda aquí. 
	- No hay variables nuevas durante la ejecución del programa
	- No tiene un puntero como tal (a direfencia del area de codigo que tiene el PC)

- El stack: 
	- 3 operaciones básicas de un stack: push, pop, top ( obervar que hay)
	- CUIDADO: con la ubicacion del stack. es decir el stack baja en direcciones de memoria. "Crece hacia abajo en el diagrama de la diapositiva"
	- A nivel ensamblador: el stack pointer. Probablemente el puntero más usado en assembler
	- Variables locales y parámetros se guardan en el stack
	- Dirección de retorno (en C no necesitamos preocuparnos por eso)
- El heap
	- Es dinamico: listas encadenadas, objestos. Todas aquellas cosas que no tienen un tamaño fijo o determinado al momento de compilar
	- El heap "crece" hacia las direcciones de memoria más altas
	- "Stack Overflow" o "Heap Overflow"

- El compilador es el que se encarga de pedir memoria en cada llamada y devolverla cuando se termina, es decir, el Stack es "transparente" al programador de C.

- Tener cuidado con los punteros a varibles que están en el escope de una llamada a una función.

- No depender de posiciones absolutos de memoria

## Manejo del Heap
- función `malloc()`: los devuelve un bloque de memoria. No los inicializa con ningún valor.
	~~~C
	ptr = (cast-type*) malloc(byte-size) // prt es un puntero
	~~~
	#### Ejemplo
	~~~C
	// ptr es puntero a un "bloque" de 100 enteros.
	ptr = (int*) malloc(100 * sizeof(int));
	~~~
- función `calloc()`: bloque de memoria inicializada con ceros. Es una operación lenta. Evitar usarla en cuanto sea posible.
- función `free()`: libera un bloque de memoria que previamente pedimos.
- cuidado con usar malloc sin el free. "Aquí no hay garbage collector"
- Puede ser lento buscar espacio disponible
- Recordar que manejar el heap es tarea del programador.

