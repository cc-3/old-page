---
layout: post
title:  "Laboratorio 10"
date:   2018-05-08
category: lab
description: >
    El objetivo de este laboratorio es que aprendan a resolver problemas utilizando
    el lenguaje de programación Python y al mismo tiempo entender el paradigma de
    MapReduce.
---

## Introducción

Talvez algunos ya estén familiarizados con **Python** ya que ha ganado popularidad en los últimos años (_es el lenguaje más utilizado en universidades para cursos introductorios de programación_), además siempre está en las primeras posiciones de los lenguajes de programación más usados donde reposan los grandes como **C** y **C++** y no hay que olvidar que es el scripting language por excelencia que utilizan compañias como Google, Facebook, etc. Se preguntarán ¿por qué aprender Python? además de ser una nueva herramienta en su toolbox de conocimientos, es un lenguaje flexible, rápido a pesar de ser interpretado y con dynamic typing (obvio no se compara con uno compilado y con static typing).

Antes de empezar este laboratorio, asumimos que ya leyeron el tutorial de Python que se les proporciona al inicio de la página del curso: [LINK](http://cc-3.github.io/tutorial/tutorial-python.html)

> _**NOTA**: es imperativo que lean el tutorial, en otros años han tratado de saltarse este paso y el resultado es awful, **LEAN EL TUTORIAL**._

## Setup
Para realizar el lab ustedes necesitan ingresar al siguiente [Link de Github Classroom](https://classroom.github.com/a/V9YtixgU) donde se creara su repositorio que contendrá los archivos base necesarios, luego clone este repositorio en donde ustedes quieran trabajar:

```
git clone url_repoositorio
```

donde `url_repositorio` seria algo similar a _https://github.com/cc-3/lab10-2018-suUser_. Cuando ya tengan esto se habrá creado una carpeta `lab03-2018-suUser`.

## Entrega

Cuando completen cada ejercicio deben realizar `commit` y `push` con los cambios que hayan hecho en los archivos correspondientes de éste. Al finalizar el laboratorio deben enviar en el GES el link de su repositorio. **En la asignación del laboratorio se indica la fecha y hora de entrega.**

***

## Ejercicios

### Ejercicio 0: Quicksort

Para este primer ejercicio del laboratorio tienen que implementar el **Quicksort** en python utilizando el conocimiento que adquirieron en el tutorial de python, esta función se encuentra en **ex0.py** y recibe como parámetro una arreglo/lista de números enteros que tiene que ordenar.

```python
def quicksort(arr):
    '''
    TODO: tiene que implementar la funcion de quicksort para ordenar una
    lista no ordenada de python
    '''
    pass
```

pueden probar su implementación con


```shell
python ex0.py
```

lo cual hace 3 tests con listas aleatorias, estos tests imprimen el arreglo que reciben, su output y lo que se esperaba


```shell
Input: [63731, 49830, 4132, 62666, 50149, 56222, 54539, 53928, 50573, 12188, 50974, 29278, 53064, 35586]

Output: [4132, 12188, 29278, 35586, 49830, 50149, 50573, 50974, 53064, 53928, 54539, 56222, 62666, 63731]
Expected: [4132, 12188, 29278, 35586, 49830, 50149, 50573, 50974, 53064, 53928, 54539, 56222, 62666, 63731]
---
...
```

si todo creen que está correcto, hagan commit y push.

### Ejercicio 1: Binary Search

Para este ejercicio del laboratorio tienen que implementar la busqueda
binaria en Python, es decir una función que busca un elemento en una lista
ordenada de elementos. La función que van a implementar tiene que devolver
el índice del elemento que se está buscando en la lista. La función que tienen que implementar se encuentra en el archivo **ex1.py** llamada **binary_search**.


```python
def binary_search(l, element):
    '''
    TODO: implementar esta funcion que busca un elemento dentro de una lista
    ordenada de python utilizando el algoritmo de busqueda binaria (CC2)

    la funcion recibe como parametros una lista (l) y un elemento a buscar

    si el elemento se encuentra en la lista-> devolver posicion
    si el elemento no esta en la lista -> devolver -1

    Hint: Usar if/elif para las condiciones.
    '''
    pass
```

Pueden probar su función con

```shell
python ex1.py
```

Esto realizará 3 pruebas en donde podrán ver si su algoritmo funciona o no e.g:

```shell
Test 1

Input List: [877, 2648, 14033, 18970, 24278, 33478, 45565, 55166, 57605, 59835, 63361]


element: 33478, output: 5, expected: 5



element: 2648, output: 1, expected: 1



element: 57605, output: 8, expected: 8



element: 61681, output: -1, expected: -1

...
```

si todo creen que está correcto, hagan commit y push.

### Ejercicio 2: Word Count

Este es un clásico en MapReduce y seguramente ya lo vieron en clase, tienen que
leer un archivo y tratar de contar las palabras que este contiene utilizando map y reduce de python, para esto nosotros les proporcionamos una funcion que lee un archivo y devuelve un arreglo que tiene las lineas de este archivo. La función que tienen que implementar se llama **word_count** y está dentro del archivo **ex2.py**. Antes de empezar este ejercicio explicaremos cada una de las funciones de Map Reduce:

##### map

Esta función ya viene predefinida en **Python** se utiliza para mapear una secuencia de elementos (lista) hacia otra secuencia de elementos aplicandole a cada elemento una función:

```python
a = [1, 2, 3, 4, 5]
out = map(lambda e: e * e, a)
print(out)

# [1, 4, 9, 16, 25]
```

##### flatMap

esta no viene predefinida en python pero nosotros la implementamos porque les servirá en este ejercicio, lo que hace es mapear una secuencia de elementos hacia otra secuencia de elementos, aplicandole a cada elemento una funcion, la diferencia con map se encuentra en que esta funcion al aplicarla a cada elemento devuelve una secuencia y no solo un elemento, pueden ver como está implementada en **utils.py**.

```python
a = [1, 2, 3]
out = flatMap(lambda e: [e + 1, e + 2, e + 3], a)
print(out)

# [2, 3, 4, 3, 4, 5, 4, 5, 6]
```

##### filter

También viene predefinida en python y como su nombre lo indica filtra elementos de un una secuencia de elementos

```python
a = [1, 2, 3, 4, 5, 6]
out = filter(lambda e: e >= 4, a)
print(out)

# [4, 5, 6]
```

##### reduce
Esta función no está predefinida en python y para poder utilizarla hay que importarla con:

```python
from functools import reduce
```

y lo que hace es reducir una lista de elementos a 1 solo elemento, aplicandole una funcion de agregación que deberia de ser de tipo (V, V) => V.

```python
a = [1, 2, 3]
out = reduce(lambda a, b: a + b, a)
print(out)

# 6
```

##### reduceByKey

Está no está predefinida en python pero nosotros la implementamos para que puedan hacer este ejercicio, lo que hace esta función es: si se manda a llamar con listas de pares (K, V), devuelve una lista de pares (K, V) donde los valores (V) de cada key (K) son agregados dada una funcion de agregación, que deberia de ser de tipo (V, V) => V, pueden ver como está implementada en **utils.py**.

```python
a = [(1, 1), (1, 1), (2, 1), (2, 1)]
out = reduceByKey(lambda a, b: a + b, a)
print(out)

# [(1, 2), (2, 2)]
```

Pueden probar este ejercicio con

```shell
python ex2.py small.txt
```

o

```shell
python ex2.py medium.txt
```

si todo creen que está correcto, hagan commit y push.

### Ejercicio 3: PI Estimation

En este ejercicio ustedes van a utilizar el paradigma de programación MapReduce para poder estimar PI de una forma bastante elegante y simple. Vamos a generar muchos puntos aleatorios (x, y) entre [(0, 0), (1, 1)] y ver cuales de estos puntos caen dentro del círculo unitario i.e, que puntos cumplen con x^2 + y^2 < 1. Si generamos N puntos la fracción de puntos aleatorios que si van a estar dentro del círculo unitario será π / 4 (porcentaje de N que si estará dentro del circulo) claro si N tiende a infinito, así que podemos utilizar esto para estimar PI de la siguiente forma:

```
  4.0 * CANTIDAD_PUNTOS_DENTRO / N
```

ustedes tiene que implementar 3 funciones dentro del archivo **ex3.py**, las cuales son **random_point** que genera un punto random (x, y), **fall_in** que verifa si una tupla (x, y) está dentro del circulo unitario y **estimate_pi** que devuelve la estimación de PI.

Pueden probar su codigo con:

```shell
  python ex3.py
```

esto probara su código en valores de N = 100, 1000, 10000, 100000, 1000000, y se tiene que notar que a N más grande, la estimación es mejor, e.g:


```shell
  N: 100 -> PI ~ 3.240000
  N: 1000 -> PI ~ 3.120000
  N: 10000 -> PI ~ 3.154000
  N: 100000 -> PI ~ 3.134720
  N: 1000000 -> PI ~ 3.142068
```


si todo creen que está correcto, hagan commit y push.
