{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bienvenidos a Estructura de M\u00e1quinas \u00b6","title":"Inicio"},{"location":"#bienvenidos-a-estructura-de-maquinas","text":"","title":"Bienvenidos a Estructura de M\u00e1quinas"},{"location":"labs/lab00/","text":"Lab 0 - Git y Representaci\u00f3n de N\u00fameros \u00b6 Objetivos \u00b6 Aprender git y crear cuenta de GitHub. Ganar m\u00e1s intuici\u00f3n para trabajar con n\u00fameros binarios. Lecturas \u00b6 P&H: 2.4 Ejercicio 1: Cuenta de GitHub \u00b6 Por favor lean las siguientes instrucciones cuidadosamente antes de seguir con el laboratorio. La mayor parte de los problemas que tienen los estudiantes durante este laboratorio se pueden prevenir siguiendo atentamente los pasos que se indican. Para este curso necesitaremos que utilicen git , un sistema de control de versiones distribuido . Los sistemas de control de versiones son las mejores herramientas para compartir y almacenar c\u00f3digo a comparaci\u00f3n de mandar correos con archivos adjuntos, utilizar memorias flash, o incluso compartir documentos mediante DropBox o Google Docs. Vamos a estar usando GitHub para tener repositorios privados en donde van a almacenar su c\u00f3digo remotamente. Si la oraci\u00f3n anterior no les dijo nada, no se preocupen, vamos a guiarlos en el proceso m\u00e1s adelante. Pero primero, necesitan crear una cuenta de GitHub . \u00bfPor qu\u00e9 GitHub? GitHub ahora le permite a todas las cuentas gratuitas tener repositorios privados ilimitados con algunas limitaciones que no van a ser ning\u00fan problema para nosotros. GitHub y Primer Repositorio \u00b6 Naveguen a la siguiente p\u00e1gina: github.com Si no tienen una cuenta de GitHub todav\u00eda, creen una en el siguiente link . Creen un repositorio privado vac\u00edo, llamado lab0_git Primero hagan click en el siguiente link Luego llenen los campos, como se muestra en la siguiente imagen Configurando git \u00b6 Ahora que ya hemos creado nuestro repositorio, vamos a configurar git para que sepa qui\u00e9nes son. Abran una terminal ctrl alt t y ejecuten los siguientes comandos listados abajo, reemplazando NOMBRE con su nombre y apellido (entre comillas) y CORREO con la direcci\u00f3n de correo que utilizar\u00f3n para registrarse en GitHub. git config --global user.name \"NOMBRE\" git config --global user.email \"CORREO\" Ejercicio 2: git y Remotes \u00b6 Primero, algunas definiciones r\u00e1pidas: Un remote es la p\u00e1gina web host o servidor que va a almacenar su c\u00f3digo remotamente en vez de tener \u00fanicamente el c\u00f3digo de forma local en su propia computadora. Pueden pensar en esto de igual manera a como se almacena un archivo en DropBox o Google Drive pero con el poder que nos da git. Un branch es una secuencia (por aparte) de diferentes cambios a su c\u00f3digo. Pueden pensar en los branches como diferentes versiones de su c\u00f3digo, que en alg\u00fan punto fueron lo mismo. La siguiente figura muestra a que nos referimos como branches. (cr\u00e9ditos de imagen: BitBucket) A lo largo de este curso, estar\u00e1n trabajando en dos diferentes \" computadoras \" que generalmente tendran diferentes versiones de su c\u00f3digo en alg\u00fan tiempo. Estas dos son: su computadora personal y su remote de GitHub (sus repositorios privados de GitHub). Es esencial que entiendan la diferencia entre estas dos y como pueden compartir c\u00f3digo entre ellas. Su computadora personal es la que les servir\u00e1 para hacer todo el trabajo (laboratorios y proyectos) que necesiten hacer durante el curso, nada nuevo aqu\u00ed. Su cuenta de GitHub y los remotes les servir\u00e1n para muchos prop\u00f3sitos, pero la principal raz\u00f3n es para tener un backup o copia de respaldo, de tal manera que si algo malo le sucede a sus computadoras (esperamos no ), puedan recuperar su c\u00f3digo en vez de empezar de cero nuevamente. Conceptualmente, pueden pensar en los remotes de GitHub como otra computadora que \u00fanicamente almacena su c\u00f3digo y nada m\u00e1s. Siempre deben subir sus cambios a GitHub haciendo push al remote (es decir actualizando los archivos en GitHub) y tambi\u00e9n pueden descargar los cambios de GitHub haciendo pull (actualizando los archivos en su computadora personal). Obteniendo los Archivos \u00b6 Creen una carpeta llamada lab0_git en alg\u00fan directorio de su preferencia. mkdir lab0_git cd lab0_git Luego descarguen los archivos base de la siguiente manera: git init git remote add lab0-starter https://github.com/cc-3/lab0_git.git git fetch lab0-starter git merge lab0-starter/master -m \"agregando codigo base, lab 0\" Deber\u00edan de ser capaces de ver los archivos del laboratorio si los listan en la terminal: ls Lo cual desplegar\u00e1 lo siguiente: autograder ex3.txt ex4.txt LICENSE submit Haciendo push hacia GitHub \u00b6 Ahora vamos a hacer push del c\u00f3digo hacia el repositorio privado de GitHub que creamos anteriormente, ejecutando los siguientes comandos, para ello deben estar en la carpeta que acabamos de crear lab0_git : NOTA : Tienen que cambiar USUARIO por su usuario de GitHub. git remote add origin https://github.com/USUARIO/lab0_git.git git push -u origin master En caso hayan olvidado cambiar USUARIO por su usuario de GitHub, pueden utilizar el siguiente comando para arreglarlo: git remote set-url origin https://github.com/USUARIO/lab0_git.git ` Ahora que tenemos nuestro laboratorio almacenado en GitHub (pueden verificar esto navegando hacia https://github.com/USUARIO/lab00_git.git), podemos agregar un archivo y hacer algunos commits . Vamos a crear un archivo llamado hello.sh en la carpeta del laboratorio ejecutando el siguiente commando en la terminal: echo 'echo \"Hola Mundo\"' > hello.sh Luego pueden correr el archivo en la terminal con bash hello.sh . En la terminal se imprimir\u00e1 Hola Mundo . Ahora utilicemos git para ver los archivos que todav\u00eda no han sido rastreados utilizando status : git status Lo que producir\u00e1 lo siguiente: On branch master No commits yet Untracked files: ( use \"git add <file>...\" to include in what will be committed ) hello.sh nothing added to commit but untracked files present ( use \"git add\" to track ) Esto es porque hemos creado un archivo nuevo llamado hello.sh y no lo hemos agregado. Podemos agregarlo y hacer commit: git add hello.sh # agrega el archivo hello.sh para hacer commit git commit -m \"Mensaje del Commit\" # ingresa cualquier mensaje que quieras git branch # deberias de ver que solo existe el branch master y que estas en ella (*) git push -u origin master # Esto hace push de tu codigo hacia GitHub (lo puedes ver en GitHub ahora) El control de versiones git esta construido alrededor de commits , o checkpoints en el desarrollo de diferentes versiones/etapas de su c\u00f3digo. Para explicar los pasos de arriba un poco m\u00e1s: git add [archivo] le dir\u00e1 a git que han hecho cambios a ese archivo y que quieren que esos cambios se guarden en el siguiente commit (staging). git commit -m \"mensaje\" oficialmente guarda esos cambios que acaban de agregar, y crea un snapshot del contenido actual de todos los archivos en el repositorio. Ahora siempre van a tener la opci\u00f3n de revertir su c\u00f3digo hacia este commit. git push -u origin master manda todo el contenido del repositorio que est\u00e1 en el branch \"master\" al repositorio remoto \"origin\" (recuerden que agregamos el repositorio de GitHub \"lab0_git\" como remote y lo llamamos \"origin\"). Cuando estamos trabajando con git, si alguna vez no est\u00e1n seguros de algo, pero quieren asegurarse de que tienen una copia guardada del contenido actual de su c\u00f3digo, solo tienen que correr git add . y despu\u00e9s git commit en la terminal. Un \u00faltimo comando de git que pueden encontrar bastante util es git log . Pueden ejectuar este comando en la terminal y van a ver un historial o log de todos los commits que se han hecho (en el branch actual), incluyendo el tiempo y quien hizo el commit. Ejercicio 3: Alfabeto Binario \u00b6 Vamos a utilizar n\u00fameros de 4 bits. Si apilamos cinco n\u00fameros de 4 bits uno encima de otro en binario, podemos crear patrones e im\u00e1genes. Para ayudarlos a visualizar esto, pueden pensar que un bit en cero es blanco y un bit en uno es negro. Por ejemplo miren el siguiente patr\u00f3n de bits. Preguntas \u00b6 \u00bfCu\u00e1les son los cinco n\u00fameros en decimal (separados por una coma) que producen el patr\u00f3n de arriba? \u00bfCu\u00e1les son los cinco digitos en hexadecimal (separados por una coma) que producen el patr\u00f3n de arriba? \u00bfQu\u00e9 letra se dibuja con los siguientes n\u00fameros en decimal: 1,1,9,9,6? \u00bfQu\u00e9 letra se dibuja con el siguiente numero en hexadecimal: 0xF8F88? \u00bfCu\u00e1l es el numero en hexadecimal para dibujar la letra b (min\u00fascula)? \u00bfUtilizar\u00edas cinco d\u00edgitos hexadecimales para dibujar la letra N? Contesten Si o No En los archivos del laboratorio van a encontrar un archivo de texto ex3.txt con lo siguiente: 1: 2: 3: 4: 5: 6: En este archivo tienen que colocar todas sus respuestas de las preguntas de arriba siguiendo ese formato por ejemplo un archivo valido ser\u00eda: 1:1,2,3,4,5 2:0x1,0x2,0x3,0x4,0x5 3:A 4:A 5:0xcafee 6:Si/No Si ya contestaron todo y creen que est\u00e1 correcto pueden agregar los cambios, hacer commit y subirlo al repositorio remoto ejecutando los siguientes comandos en la terminal: git add ex4.txt git commit -m \"ex. 3 complete\" git push -u origin master Ejercicio 4: 1,000 billetes de $1 \u00b6 Imaginen que tienen mil billetes de $1 y 10 sobres. Para este ejercicio tienen que encontrar una manera de poner una cantidad determinada de billetes de $1 en cada uno de los sobres de tal forma que, sin importar la cantidad de dinero que se les pida (entre $1 y $1000), simplemente entreguen una combinaci\u00f3n de los sobres y que siempre est\u00e9n seguros de que est\u00e1n dando la cantidad correcta. En los archivos del laboratorio hay un archivo de texto llamado ex4.txt en donde encontrar\u00e1n lo siguiente: a,b,c,d,e,f,g,h,i,j Cada una de las letras representa un sobre, tienen que reemplazar cada letra por la cantidad de billetes de $1 que crean correcta, esa cantidad tiene que ser >= 0 (en decimal) y recuerda que la suma de la cantidad de cada uno de los sobres tiene que ser igual a 1000 . Si ya contestaron todo y creen que est\u00e1 correcto pueden agregar los cambios, hacer commit y subirlo al repositorio remoto ejecutando los siguientes comandos en la terminal: git add ex4.txt git commit -m \"ex. 4 complete\" git push -u origin master Calificaci\u00f3n \u00b6 Todos los laboratorios y proyectos de este curso tendr\u00e1n autograders y podr\u00e1n saber su nota al terminarlo. Este proceso que van a ver a continuaci\u00f3n lo tienen que seguir siempre para poder obtener su nota. Generando Un Token \u00b6 Para que podamos calificar su laboratorio es necesario que generen un token \u00fanico de identificaci\u00f3n para subir los archivos y que sean calificados, este token es de uso personal no lo compartan. Para generar el token solo tiene que ir al siguiente link . Tienen que hacer click en generate token NOTA : Necesitan usar una cuenta de @galileo.edu para esto Luego copien y peguen el c\u00f3digo generado en alg\u00fan lugar y guardenlo Si por alguna raz\u00f3n pierden el token, pueden volver a generarlo en el mismo link de arriba, pero recuerden que es personal y no lo tienen que compartir con \u00a1\u00a1\u00a1 nadie !!!. Algo muy importante que tienen que tener en cuenta es que en este curso, como en cualquier otro, no se permite el PLAGIO, si utilizan el laboratorio de otro compa\u00f1ero y hacen submit con su token solo para sacar una \"buena nota\" nos daremos cuenta de esto porque tendremos una copia siempre de los archivos que utilizan gracias a GitHub classroom. NOTA : NO SE COPIEN, EN SERIO NO LO HAGAN !!!! Subiendo el laboratorio \u00b6 Ya que tienen el token generado pueden subir su laboratorio para que sea calificado y obtener su nota. Lo \u00fanico que tienen que hacer para esto es ejecutar el siguiente comando en la terminal (siempre estando en la carpeta del laboratorio): ./submit TOKEN NOTA : Tienen que reemplazar TOKEN por el token que generaron. Lo cual, si nada sale mal , les dar\u00e1 la nota que sacaron en el laboratorio y lo guardar\u00e1 en nuestra base de datos. ___ __ __ / _ | __ __/ /____ ___ ________ ____/ /__ ____ / __ / // / __/ _ \\/ _ ` / __/ _ ` / _ / -_ ) __/ /_/ | _ \\_ ,_/ \\_ _/ \\_ __/ \\_ , /_/ \\_ ,_/ \\_ ,_/ \\_ _/_/ /___/ Lab: lab0_git zipping source files... getting server url... waiting for results... Exercise Grade Message ------------------ ------- --------- 2 . git and Remotes 20 passed 3 . Binary Alphabet 40 passed 4 . 1000 $1 Bills 40 passed = > Score 100 .00/100","title":"0: Git"},{"location":"labs/lab00/#lab-0-git-y-representacion-de-numeros","text":"","title":"Lab 0 - Git y Representaci\u00f3n de N\u00fameros"},{"location":"labs/lab00/#objetivos","text":"Aprender git y crear cuenta de GitHub. Ganar m\u00e1s intuici\u00f3n para trabajar con n\u00fameros binarios.","title":"Objetivos"},{"location":"labs/lab00/#lecturas","text":"P&H: 2.4","title":"Lecturas"},{"location":"labs/lab00/#ejercicio-1-cuenta-de-github","text":"Por favor lean las siguientes instrucciones cuidadosamente antes de seguir con el laboratorio. La mayor parte de los problemas que tienen los estudiantes durante este laboratorio se pueden prevenir siguiendo atentamente los pasos que se indican. Para este curso necesitaremos que utilicen git , un sistema de control de versiones distribuido . Los sistemas de control de versiones son las mejores herramientas para compartir y almacenar c\u00f3digo a comparaci\u00f3n de mandar correos con archivos adjuntos, utilizar memorias flash, o incluso compartir documentos mediante DropBox o Google Docs. Vamos a estar usando GitHub para tener repositorios privados en donde van a almacenar su c\u00f3digo remotamente. Si la oraci\u00f3n anterior no les dijo nada, no se preocupen, vamos a guiarlos en el proceso m\u00e1s adelante. Pero primero, necesitan crear una cuenta de GitHub . \u00bfPor qu\u00e9 GitHub? GitHub ahora le permite a todas las cuentas gratuitas tener repositorios privados ilimitados con algunas limitaciones que no van a ser ning\u00fan problema para nosotros.","title":"Ejercicio 1: Cuenta de GitHub"},{"location":"labs/lab00/#github-y-primer-repositorio","text":"Naveguen a la siguiente p\u00e1gina: github.com Si no tienen una cuenta de GitHub todav\u00eda, creen una en el siguiente link . Creen un repositorio privado vac\u00edo, llamado lab0_git Primero hagan click en el siguiente link Luego llenen los campos, como se muestra en la siguiente imagen","title":"GitHub y Primer Repositorio"},{"location":"labs/lab00/#configurando-git","text":"Ahora que ya hemos creado nuestro repositorio, vamos a configurar git para que sepa qui\u00e9nes son. Abran una terminal ctrl alt t y ejecuten los siguientes comandos listados abajo, reemplazando NOMBRE con su nombre y apellido (entre comillas) y CORREO con la direcci\u00f3n de correo que utilizar\u00f3n para registrarse en GitHub. git config --global user.name \"NOMBRE\" git config --global user.email \"CORREO\"","title":"Configurando git"},{"location":"labs/lab00/#ejercicio-2-git-y-remotes","text":"Primero, algunas definiciones r\u00e1pidas: Un remote es la p\u00e1gina web host o servidor que va a almacenar su c\u00f3digo remotamente en vez de tener \u00fanicamente el c\u00f3digo de forma local en su propia computadora. Pueden pensar en esto de igual manera a como se almacena un archivo en DropBox o Google Drive pero con el poder que nos da git. Un branch es una secuencia (por aparte) de diferentes cambios a su c\u00f3digo. Pueden pensar en los branches como diferentes versiones de su c\u00f3digo, que en alg\u00fan punto fueron lo mismo. La siguiente figura muestra a que nos referimos como branches. (cr\u00e9ditos de imagen: BitBucket) A lo largo de este curso, estar\u00e1n trabajando en dos diferentes \" computadoras \" que generalmente tendran diferentes versiones de su c\u00f3digo en alg\u00fan tiempo. Estas dos son: su computadora personal y su remote de GitHub (sus repositorios privados de GitHub). Es esencial que entiendan la diferencia entre estas dos y como pueden compartir c\u00f3digo entre ellas. Su computadora personal es la que les servir\u00e1 para hacer todo el trabajo (laboratorios y proyectos) que necesiten hacer durante el curso, nada nuevo aqu\u00ed. Su cuenta de GitHub y los remotes les servir\u00e1n para muchos prop\u00f3sitos, pero la principal raz\u00f3n es para tener un backup o copia de respaldo, de tal manera que si algo malo le sucede a sus computadoras (esperamos no ), puedan recuperar su c\u00f3digo en vez de empezar de cero nuevamente. Conceptualmente, pueden pensar en los remotes de GitHub como otra computadora que \u00fanicamente almacena su c\u00f3digo y nada m\u00e1s. Siempre deben subir sus cambios a GitHub haciendo push al remote (es decir actualizando los archivos en GitHub) y tambi\u00e9n pueden descargar los cambios de GitHub haciendo pull (actualizando los archivos en su computadora personal).","title":"Ejercicio 2: git y Remotes"},{"location":"labs/lab00/#obteniendo-los-archivos","text":"Creen una carpeta llamada lab0_git en alg\u00fan directorio de su preferencia. mkdir lab0_git cd lab0_git Luego descarguen los archivos base de la siguiente manera: git init git remote add lab0-starter https://github.com/cc-3/lab0_git.git git fetch lab0-starter git merge lab0-starter/master -m \"agregando codigo base, lab 0\" Deber\u00edan de ser capaces de ver los archivos del laboratorio si los listan en la terminal: ls Lo cual desplegar\u00e1 lo siguiente: autograder ex3.txt ex4.txt LICENSE submit","title":"Obteniendo los Archivos"},{"location":"labs/lab00/#haciendo-push-hacia-github","text":"Ahora vamos a hacer push del c\u00f3digo hacia el repositorio privado de GitHub que creamos anteriormente, ejecutando los siguientes comandos, para ello deben estar en la carpeta que acabamos de crear lab0_git : NOTA : Tienen que cambiar USUARIO por su usuario de GitHub. git remote add origin https://github.com/USUARIO/lab0_git.git git push -u origin master En caso hayan olvidado cambiar USUARIO por su usuario de GitHub, pueden utilizar el siguiente comando para arreglarlo: git remote set-url origin https://github.com/USUARIO/lab0_git.git ` Ahora que tenemos nuestro laboratorio almacenado en GitHub (pueden verificar esto navegando hacia https://github.com/USUARIO/lab00_git.git), podemos agregar un archivo y hacer algunos commits . Vamos a crear un archivo llamado hello.sh en la carpeta del laboratorio ejecutando el siguiente commando en la terminal: echo 'echo \"Hola Mundo\"' > hello.sh Luego pueden correr el archivo en la terminal con bash hello.sh . En la terminal se imprimir\u00e1 Hola Mundo . Ahora utilicemos git para ver los archivos que todav\u00eda no han sido rastreados utilizando status : git status Lo que producir\u00e1 lo siguiente: On branch master No commits yet Untracked files: ( use \"git add <file>...\" to include in what will be committed ) hello.sh nothing added to commit but untracked files present ( use \"git add\" to track ) Esto es porque hemos creado un archivo nuevo llamado hello.sh y no lo hemos agregado. Podemos agregarlo y hacer commit: git add hello.sh # agrega el archivo hello.sh para hacer commit git commit -m \"Mensaje del Commit\" # ingresa cualquier mensaje que quieras git branch # deberias de ver que solo existe el branch master y que estas en ella (*) git push -u origin master # Esto hace push de tu codigo hacia GitHub (lo puedes ver en GitHub ahora) El control de versiones git esta construido alrededor de commits , o checkpoints en el desarrollo de diferentes versiones/etapas de su c\u00f3digo. Para explicar los pasos de arriba un poco m\u00e1s: git add [archivo] le dir\u00e1 a git que han hecho cambios a ese archivo y que quieren que esos cambios se guarden en el siguiente commit (staging). git commit -m \"mensaje\" oficialmente guarda esos cambios que acaban de agregar, y crea un snapshot del contenido actual de todos los archivos en el repositorio. Ahora siempre van a tener la opci\u00f3n de revertir su c\u00f3digo hacia este commit. git push -u origin master manda todo el contenido del repositorio que est\u00e1 en el branch \"master\" al repositorio remoto \"origin\" (recuerden que agregamos el repositorio de GitHub \"lab0_git\" como remote y lo llamamos \"origin\"). Cuando estamos trabajando con git, si alguna vez no est\u00e1n seguros de algo, pero quieren asegurarse de que tienen una copia guardada del contenido actual de su c\u00f3digo, solo tienen que correr git add . y despu\u00e9s git commit en la terminal. Un \u00faltimo comando de git que pueden encontrar bastante util es git log . Pueden ejectuar este comando en la terminal y van a ver un historial o log de todos los commits que se han hecho (en el branch actual), incluyendo el tiempo y quien hizo el commit.","title":"Haciendo push hacia GitHub"},{"location":"labs/lab00/#ejercicio-3-alfabeto-binario","text":"Vamos a utilizar n\u00fameros de 4 bits. Si apilamos cinco n\u00fameros de 4 bits uno encima de otro en binario, podemos crear patrones e im\u00e1genes. Para ayudarlos a visualizar esto, pueden pensar que un bit en cero es blanco y un bit en uno es negro. Por ejemplo miren el siguiente patr\u00f3n de bits.","title":"Ejercicio 3: Alfabeto Binario"},{"location":"labs/lab00/#preguntas","text":"\u00bfCu\u00e1les son los cinco n\u00fameros en decimal (separados por una coma) que producen el patr\u00f3n de arriba? \u00bfCu\u00e1les son los cinco digitos en hexadecimal (separados por una coma) que producen el patr\u00f3n de arriba? \u00bfQu\u00e9 letra se dibuja con los siguientes n\u00fameros en decimal: 1,1,9,9,6? \u00bfQu\u00e9 letra se dibuja con el siguiente numero en hexadecimal: 0xF8F88? \u00bfCu\u00e1l es el numero en hexadecimal para dibujar la letra b (min\u00fascula)? \u00bfUtilizar\u00edas cinco d\u00edgitos hexadecimales para dibujar la letra N? Contesten Si o No En los archivos del laboratorio van a encontrar un archivo de texto ex3.txt con lo siguiente: 1: 2: 3: 4: 5: 6: En este archivo tienen que colocar todas sus respuestas de las preguntas de arriba siguiendo ese formato por ejemplo un archivo valido ser\u00eda: 1:1,2,3,4,5 2:0x1,0x2,0x3,0x4,0x5 3:A 4:A 5:0xcafee 6:Si/No Si ya contestaron todo y creen que est\u00e1 correcto pueden agregar los cambios, hacer commit y subirlo al repositorio remoto ejecutando los siguientes comandos en la terminal: git add ex4.txt git commit -m \"ex. 3 complete\" git push -u origin master","title":"Preguntas"},{"location":"labs/lab00/#ejercicio-4-1000-billetes-de-1","text":"Imaginen que tienen mil billetes de $1 y 10 sobres. Para este ejercicio tienen que encontrar una manera de poner una cantidad determinada de billetes de $1 en cada uno de los sobres de tal forma que, sin importar la cantidad de dinero que se les pida (entre $1 y $1000), simplemente entreguen una combinaci\u00f3n de los sobres y que siempre est\u00e9n seguros de que est\u00e1n dando la cantidad correcta. En los archivos del laboratorio hay un archivo de texto llamado ex4.txt en donde encontrar\u00e1n lo siguiente: a,b,c,d,e,f,g,h,i,j Cada una de las letras representa un sobre, tienen que reemplazar cada letra por la cantidad de billetes de $1 que crean correcta, esa cantidad tiene que ser >= 0 (en decimal) y recuerda que la suma de la cantidad de cada uno de los sobres tiene que ser igual a 1000 . Si ya contestaron todo y creen que est\u00e1 correcto pueden agregar los cambios, hacer commit y subirlo al repositorio remoto ejecutando los siguientes comandos en la terminal: git add ex4.txt git commit -m \"ex. 4 complete\" git push -u origin master","title":"Ejercicio 4: 1,000 billetes de $1"},{"location":"labs/lab00/#calificacion","text":"Todos los laboratorios y proyectos de este curso tendr\u00e1n autograders y podr\u00e1n saber su nota al terminarlo. Este proceso que van a ver a continuaci\u00f3n lo tienen que seguir siempre para poder obtener su nota.","title":"Calificaci\u00f3n"},{"location":"labs/lab00/#generando-un-token","text":"Para que podamos calificar su laboratorio es necesario que generen un token \u00fanico de identificaci\u00f3n para subir los archivos y que sean calificados, este token es de uso personal no lo compartan. Para generar el token solo tiene que ir al siguiente link . Tienen que hacer click en generate token NOTA : Necesitan usar una cuenta de @galileo.edu para esto Luego copien y peguen el c\u00f3digo generado en alg\u00fan lugar y guardenlo Si por alguna raz\u00f3n pierden el token, pueden volver a generarlo en el mismo link de arriba, pero recuerden que es personal y no lo tienen que compartir con \u00a1\u00a1\u00a1 nadie !!!. Algo muy importante que tienen que tener en cuenta es que en este curso, como en cualquier otro, no se permite el PLAGIO, si utilizan el laboratorio de otro compa\u00f1ero y hacen submit con su token solo para sacar una \"buena nota\" nos daremos cuenta de esto porque tendremos una copia siempre de los archivos que utilizan gracias a GitHub classroom. NOTA : NO SE COPIEN, EN SERIO NO LO HAGAN !!!!","title":"Generando Un Token"},{"location":"labs/lab00/#subiendo-el-laboratorio","text":"Ya que tienen el token generado pueden subir su laboratorio para que sea calificado y obtener su nota. Lo \u00fanico que tienen que hacer para esto es ejecutar el siguiente comando en la terminal (siempre estando en la carpeta del laboratorio): ./submit TOKEN NOTA : Tienen que reemplazar TOKEN por el token que generaron. Lo cual, si nada sale mal , les dar\u00e1 la nota que sacaron en el laboratorio y lo guardar\u00e1 en nuestra base de datos. ___ __ __ / _ | __ __/ /____ ___ ________ ____/ /__ ____ / __ / // / __/ _ \\/ _ ` / __/ _ ` / _ / -_ ) __/ /_/ | _ \\_ ,_/ \\_ _/ \\_ __/ \\_ , /_/ \\_ ,_/ \\_ ,_/ \\_ _/_/ /___/ Lab: lab0_git zipping source files... getting server url... waiting for results... Exercise Grade Message ------------------ ------- --------- 2 . git and Remotes 20 passed 3 . Binary Alphabet 40 passed 4 . 1000 $1 Bills 40 passed = > Score 100 .00/100","title":"Subiendo el laboratorio"},{"location":"labs/lab01/","text":"Lab 1 - Punteros en C y GDB \u00b6 Objetivos \u00b6 Aprender c\u00f3mo compilar y ejecutar un programa en C. Examinar diferentes tipos de control de flujo en C. Introducirlos al debugger (depurador) de C Conseguir experiencia pr\u00e1ctica utilizando GBD para depurar programas en C. Ganar m\u00e1s confianza al trabajar con punteros. Preparaci\u00f3n \u00b6 Visiten este link . Aqu\u00ed encontrar\u00e1n todos los archivos necesarios para completar este lab. En esta p\u00e1gina, encontrar\u00e1n un bot\u00f3n que dice \"Accept assignment\". Al presionar este bot\u00f3n, se crear\u00e1 autom\u00e1ticamente un repositorio en Github llamado \"www.github.com/cc-3/lab1-c-gdb-USUARIO\". Noten que el \"due\u00f1o\" de este repositorio es un usuario llamado cc-3 , y el usuario de ustedes es \u00fanicamente el sufijo del nombre del repo. De esta forma, nos encargamos de tener acceso siempre a su c\u00f3digo, en caso existan copias o cualquier otro tipo de trampa. Sepan de una vez que, si encontramos plagio o cualquier otro tipo de trampa en sus laboratorios, su nota ser\u00e1 AUTOM\u00c1TICAMENTE 0, sin posibilidad de cambiarla. De repetirse nuevamente este acontecimiento, el staff del curso organizar\u00e1 una reuni\u00f3n con ustedes y sus directores de carrera para contarles lo ocurrido y sancionarlos conforme al reglamento de la universidad. Despu\u00e9s de realizar esto, en la m\u00e1quina virtual (o sus propias computadoras) abran una terminal en el directorio que prefieran, y ejecuten el siguiente comando: git clone https://github.com/cc-3/lab1-c-gdb-<SU USUARIO DE GITHUB> esto descargar\u00e1 en el directorio que escogieron todos los archivos base para este laboratorio. Compilando y ejecutando un programa de C \u00b6 En este laboratorio, estaremos usando el programa gcc para compilar programas en c. La manera m\u00e1s sencilla de ejecutar gcc es la siguiente: gcc program.c Esto compila el archivo program.c y crea un archivo ejecutable llamado a.out . Si tienen experiencia en Java, pueden m\u00e1s o menos considerar a gcc como el equivalente en C de javac . Este archivo se puede ejecutar con el siguiente comando: ./a.out El archivo ejecutable es a.out , as\u00ed que, \u00bfqu\u00e9 rayos es eso de punto y diagonal? La respuesta: cuando quieren ejecutar un ejecutable, es necesario preponer una ruta de archivo para distinguirlo de un comando como python (no se utiliza ./python ). El punto se refiere al \"directorio actual\". De paso, dos puntos (..) se referir\u00edan al directorio que est\u00e1 un nivel arriba. gcc tiene varias opciones (o argumentos) de l\u00ednea de comandos, los cuales les recomendamos explorar. En este laboratorio, vamos a estar usando solamente -o, que se usa para especificar el nombre del ejecutable que gcc genera. Usando -o, se utilizar\u00edan estos comandos para compilar program.c en un archivo llamado program , y ejecutarlo. Eso nos sirve si no queremos que todos nuestros archivos ejecutables se llamen a.out . gcc -o program program.c ./program Ejercicio 1: Programa simple de C \u00b6 En este ejercicio, veremos un ejemplo de definiciones macro de preprocesador. Las macros pueden ser un tema complicado, pero en general, la forma en que funcionan es que, antes de que un archivo en C es compilado, las constantes macro son reemplazadas exactamente por el valor al que se refieren. En este ejercicio, estaremos usando macros exclusivamente como constantes globales. Aqu\u00ed definimos CONSTANT_NAME como un literal_value (una literal entera). Noten que solo hay 1 espacio separando el nombre del valor. #define CONSTANT_NAME LITERAL_VALUE Ahora, vean el c\u00f3digo en eccentric.c (en el repo). Noten los cuatro diferentes ejemplos de control b\u00e1sico de flujo. (\u00bfCu\u00e1les son?) Compilen y ejecuten el programa para ver lo que hace. Jueguen con las constantes de las cuatro macros: v0 a v3 . Vean c\u00f3mo cambiar cada uno de estos cambia el output del programa. Su tarea: Modificando s\u00f3lo estos cuatro valores, hagan que el programa produzca el siguiente mensaje: $ gcc -o eccentric eccentric.c $ ./eccentric Berkeley eccentrics: ==================== Happy Happy Happy Yoshua Go BEARS! Hay m\u00faltiples combinaciones de valores en las macros que consiguen este resultado, El reto para ustedes en este ejercicio es: Consideren el m\u00ednimo n\u00famero de distintos valores que las constantes v0 a v3 puedan tener que a\u00fan den el mismo resultado correcto. Como ejemplo, el m\u00e1ximo te\u00f3rico es cuatro (cuando todos son diferentes uno de otro). Cuando ya hayan logrado esto, pueden actualizar el archivo en su repositorio en github, de esta manera: $ git add eccentric.c $ git commit -m \"Ejercicio 1 terminado\" $ git push -u origin master Ejercicio 2: Debugger (depurador) \u00b6 \u00bfQu\u00e9 es un debugger ? \u00b6 Este p\u00e1rrafo es para los estudiantes que no est\u00e1n familiarizados con los debuggers . Un debugger , como sugiere el nombre, es un programa espec\u00edficamente dise\u00f1ado para ayudarlos a encontrar bugs , o errores l\u00f3gicos, u otros errores en el c\u00f3digo (nota: si quieren saber por qu\u00e9 se les llama bugs a los errores, vean aqu\u00ed ). Distintos debuggers tienen distintas caracter\u00edsticas, pero es normal que todos los debuggers sean capaces de hacer las siguientes cosas: 1. Poner un breakpoint en el programa. Un Breakpoint es una l\u00ednea espec\u00edfica en su c\u00f3digo en donde quisieran que se detenga la ejecuci\u00f3n del programa, para que puedan ver lo que est\u00e1 pasando alrededor. 2. Ejecuci\u00f3n por Steps (l\u00ednea a l\u00ednea) por el programa. El c\u00f3digo siempre se ejecuta l\u00ednea a l\u00ednea, pero pasa muy r\u00e1pido como para que sepamos qu\u00e9 l\u00ednea produce alg\u00fan error. Ser capaces de ejecutar l\u00ednea a l\u00ednea el programa les permite observar exactamente qu\u00e9 esta causando un bug en el programa. Para este ejercicio, necesitar\u00e1n la GDB reference card . GDB quiere decir \"GNU De-Bugger\". Compilen hello.c con la bandera \"-g\": gcc -g -o hello hello.c Esto har\u00e1 que gcc guarde informaci\u00f3n en el archivo ejecutable para que gdb lo interprete. Ahora ejecuten el debugger, (c)gdb: cgdb hello Vean lo que hace este comando. Est\u00e1n ejecutando el programa cgdb en el ejecutable hello generado por gcc . No intenten ejecutar cgdb en el archivo fuente en hello.c ! Eso no va a funcionar. Si cgdb no funciona, gdb se puede usar para completar los ejercicios (utilicen gdb hello ). Su tarea: ejecuten el programa varias veces haciendo esto: 1. Poniendo un breakpoint en el main. 2. Usando el comando run de gdb. 3. Utilizando el comando single-step de gdb. Escriban help adentro de gdb para averiguar c\u00f3mo hacer estas cosas, o usen la reference card. Si encuentran un mensaje de error que dice: printf.c: No such file or directory . Probablemente entraron a una funci\u00f3n printf . Si siguen ejecutando paso a paso, pareciera que nunca avanzaran en el c\u00f3digo. CGDB est\u00e1 dando el error porque no tienen el archivo en el que se define la funci\u00f3n printf . Esto es algo molesto, y para librarse de esto, usen el comando finish para ejecutar el programa hasta que termine la funci\u00f3n printf. Y la pr\u00f3xima vez , utilicen el comando next para saltar sobre la linea que usa printf . Nota: CGDB vs GDB . En este ejercicio, usamos cgdb para depurar nuestros programas. cgdb es id\u00e9ntico a gdb, excepto que tiene unas caracter\u00edsticas extra que hacen m\u00e1s c\u00f3modo el trabajo. Todos los comandos de la hoja de referencia funcionan tambi\u00e9n en gdb. En cgdb, pueden presionar ESC para ir a la ventana del c\u00f3digo (arriba), y usar i para regresar a la ventana de comandos (abajo), similar a vim . La ventana de comandos es donde se introducen los comandos de gdb. Para este ejercicio, encontrar\u00e1n un archivo de texto llamado ex2.txt, con el siguiente formato: 1 : 2 : 3 : 4 : 5 : 6 : 7 : 8 : 9 : Aqu\u00ed tendr\u00e1n que responder las siguientes preguntas de opci\u00f3n m\u00faltiple (no tengan miedo de probar las opciones en CGDB antes de responder, \u00a1lo recomendamos!) con el siguiente formato (tienen que cambiar la letra en el ejemplo por la letra de la respuesta que ustedes consideren correcta): 1 :e 2 :f 3 :g 4 :h 5 :i 6 :j 7 :k 8 :l 9 :m Preguntas 1. \u00bfC\u00f3mo se le dan argumentos desde la l\u00ednea de comandos a un programa al utilizar gdb? a. args arglist b. run arglist c. gdb args d. Ninguna de las anteriores 2. \u00bfC\u00f3mo se a\u00f1ade un breakpoint que s\u00f3lo ocurre cuando se cumplen ciertas condiciones (por ejemplo, ciertas variables alcanzan cierto valor)? a. expr cond b. cond break expr c. break ... if expr d. Ninguna de las anteriores 3. \u00bfCon qu\u00e9 comando se ejecuta la siguiente l\u00ednea del c\u00f3digo en C despu\u00e9s de parar en un breakpoint? a. run b. s c. c d. n 4. Si la siguiente l\u00ednea de c\u00f3digo es una llamada a funci\u00f3n, \u00bfse ejecutar\u00eda toda la funci\u00f3n si se utiliza el comando de la pregunta #3? (si no, es momento de cambiarla!). \u00bfC\u00f3mo se le indica a gdb, que quieren debuggear el c\u00f3digo adentro de la funci\u00f3n ? (Si tuvieron que cambiar la respuesta #3, esa respuesta muy probablemente aplica aqu\u00ed) a. run b. s c. c d. n 5. \u00bfC\u00f3mo se reanuda la ejecuci\u00f3n del programa despu\u00e9s de parar en un breakpoint? a. run b. s c. c d. n 6. \u00bfC\u00f3mo podemos ver el valor de una variable (o expresi\u00f3n) en gdb? a. display expr b. signal expr c. print expr d. next expr 7. \u00bfQu\u00e9 comando de gdb se usa para desplegar el valor de una variable despu\u00e9s de cada paso ? a. display expr b. signal expr c. print expr d. next expr 8. \u00bfC\u00f3mo se imprime una lista de todas las variables y su valor en la funci\u00f3n actual? a. display all b. display c. print all d. print 9. \u00bfC\u00f3mo salimos de gdb? a. end b. quit c. exit d. finish Despu\u00e9s de responder estas preguntas, no olviden hacer el submit y push de este archivo hacia github: $ git add ex2.txt $ git commit -m \"Ejercicio 2 terminado\" $ git push -u origin master Ejercicio 3: Depurando un problema con fallas usando GDB \u00b6 Ahora, usar\u00e1n su nuevo conocimiento para depurar un peque\u00f1o programa. Vean el programa ll_equal.c . Compilen y ejecuten el programa, y analicen un poco lo que hace. As\u00ed como est\u00e1, producir\u00e1 un resultado como el siguiente: $ gcc -g -o ll_equal ll_equal.c $ ./ll_equal equal test 1 result = 1 Segmentation fault Averig\u00fcen qu\u00e9 produce el segmentation fault (falla de segmentaci\u00f3n) . Ejecuten gdb en el programa, siguiendo las instrucciones aprendidas en los ejercicios anteriores. Les recomendamos a\u00f1adir un breakpoint en la funci\u00f3n ll_equal() . Cuando el debugger pare en el breakpoint, ejecuten paso a paso el programa, para que puedan descifrar qu\u00e9 es lo que provoca el error. Pista: Analicen el valor de los punteros a y b en la funci\u00f3n (\u00a1despli\u00e9guenlos!). \u00bfEst\u00e1n siempre apuntando a la direcci\u00f3n correcta? Pista 2: Vean el c\u00f3digo fuente en main para ver la estructura de los nodos y ver exactamente qu\u00e9 est\u00e1 pasando como argumento a ll_equal . Despu\u00e9s de corregir el problema, compilen nuevamente y ejecuten el c\u00f3digo. \u00bfNotan la diferencia? Al finalizar, no olviden subir el archivo modificado a su repositorio remoto: $ git add ll_equal.c $ git commit -m \"Ejercicio 2 terminado\" $ git push -u origin master Ejercicio 4: \"Debuggeando\" un programa en C que requiere interacci\u00f3n del usuario \u00b6 Veamos qu\u00e9 pasa cuando, a un programa que requiere interacci\u00f3n del usuario, lo ejecutamos con gdb. Primero, ejecuten el programa en interactive_hello.c para hablar con un programa muy amigable :). $ gcc -g -o int_hello interactive_hello.c $ ./int_hello Ahora, traten de depurarlo (aunque no haya ning\u00fan problema realmente): $ cgdb int_hello \u00bfQu\u00e9 pasa cuando intentar ejecutar el programa hasta el final? Vamos a aprender acerca de una herramienta que nos ayudar\u00e1 a evitar este problema. El prop\u00f3sito de este ejercicio es que no tengan miedo de usar un debugger incluso cuando el programa requiera de interacci\u00f3n con el usuario. Resulta que es posible enviar texto a stdin , el flujo de datos que es le\u00eddo por la funci\u00f3n fgets en este programa, con unos caracteres especiales desde la l\u00ednea de comandos. Echen un vistazo a la \"redirecci\u00f3n\" en esta p\u00e1gina , y vean si pueden descifrar c\u00f3mo enviar texto al programa sin escribirlo textualmente mientras el programa est\u00e1 en ejecuci\u00f3n (lo cual, como ya saben, no funciona bien en CGDB). Pueden ver esta discusi\u00f3n de stackoverflow para m\u00e1s inspiraci\u00f3n. (Pista 1: \u00a1Si est\u00e1n creando un archivo de texto que contiene su input, van bien!) (pista 2: Recuerden que es posible ejecutar programas con argumentos (incluyendo s\u00edmbolos de redirecci\u00f3n) desde CGDB! Esperamos que hayan comprendido c\u00f3mo utilizar redirecci\u00f3n y c\u00f3mo es que esto les ayuda a evitar varios problemas al usar CGDB. \u00a1Nunca tengan miedo de usar un debugger ! Tal vez no es muy agradable visualmente, pero siempre estar\u00e1 para ayudarlos. Este ejercicio no vale puntos :-) pero es importante conocer sobre estas cosas para que puedan utilizarlo en el futuro (los siguientes laboratorios y proyectos podr\u00edan necesitar de este conocimiento) Ejercicio 5: Punteros y estructuras en C \u00b6 En ll_cycle.c, completen la funci\u00f3n ll_has_cycle(), de modo que implemente el siguiente algoritmo para comprobar si una linked list simple tiene un ciclo: 1. Comiencen con dos punteros apuntando al principio de la lista. Llamaremos al primero tortoise (tortuga) y al segundo hare (liebre). 2. Avancen el puntero hare dos nodos hacia adelante. Si no se puede debido a punteros null , hemos llegado al final de la lista. Por lo tanto, la lista no tiene un ciclo. 3. Ahora, avancen tortoise un nodo. (Revisar si llega a ser un puntero nulo es innecesario. \u00bfPor qu\u00e9?) 4. Si la tortuga y la liebre apuntan al mismo nodo, la lista es c\u00edclica. Si no, regresen al paso 2. Despu\u00e9s de implementar correctamente la funci\u00f3n ll_has_cycle() , el programa que se obtiene despu\u00e9s de compilar ll_cycle.c mostrar\u00e1 si el resultado de su funci\u00f3n est\u00e1 correcto, conforme a lo que esperaba como salida. Pista: Hay dos formas comunes en que los estudiantes resuelven esta funci\u00f3n, y la diferencia principal est\u00e1 en la forma en que deciden codificar el criterio de c\u00f3mo finalizar. Si lo hacen de una forma, tendr\u00edan que tomar en cuenta un caso especial en el principio. Si lo hacen de otra forma, tendr\u00edan que tener unas pruebas extra de NULL, lo cual esta bien tambi\u00e9n. Les decimos esto para que no se preocupen de la \"limpieza\" de su c\u00f3digo, si no les ayuda, simplemente ignoren esta pista. El punto de este ejercicio es asegurarse de que entiendan como usar punteros. Aqu\u00ed hay un Art\u00edculo del algoritmo y por qu\u00e9 funciona. No se preocupen de entender completamente todo (no hay examen de esto). A prop\u00f3sito, los punteros se llaman tortoise y hare porque el puntero \"tortoise (tortuga)\" se incrementa lentamente (como una tortuga, que se mueve muy lento) y el puntero \"hare (liebre)\" se incrementa r\u00e1pidamente (m\u00e1s r\u00e1pido que una tortuga, como una liebre, o conejo, que se mueve muy r\u00e1pido). Al finalizar, compilen y ejecuten el archivo, y verifiquen que el resultado de su c\u00f3digo, el cual deber\u00eda ser m\u00e1s o menos igual a este: $ gcc -g -o ll_cycle ll_cycle.c $ ./ll_cycle Checking first list for cycles. There should be none, ll_has_cycle says it has no cycle Checking second list for cycles. There should be a cycle, ll_has_cycle says it has a cycle Checking third list for cycles. There should be a cycle, ll_has_cycle says it has a cycle Checking fourth list for cycles. There should be a cycle, ll_has_cycle says it has a cycle Checking fifth list for cycles. There should be none, ll_has_cycle says it has no cycle Checking length-zero list for cycles. There should be none, ll_has_cycle says it has no cycle Si su c\u00f3digo presenta errores, entonces ya son capaces de utilizar CGDB para poder encontrarlos y corregirlos. Finalmente, pueden subir el archivo a github: $ git add ll_cycle.c $ git commit -m \"LAB01 terminado\" $ git push -u origin master Ya con todos los ejercicios completados, no olviden ejecutar ./submit TOKEN Para poder ver su nota. Para finalizar, la par\u00e1bola de la tortuga y la liebre es relevante siempre, especialmente en este curso. Escribir sus programas en C a paso lento pero seguro (ayud\u00e1ndose de programas como CGDB) es lo que les har\u00e1 ganar la carrera.","title":"1: C y GDB"},{"location":"labs/lab01/#lab-1-punteros-en-c-y-gdb","text":"","title":"Lab 1 - Punteros en C y GDB"},{"location":"labs/lab01/#objetivos","text":"Aprender c\u00f3mo compilar y ejecutar un programa en C. Examinar diferentes tipos de control de flujo en C. Introducirlos al debugger (depurador) de C Conseguir experiencia pr\u00e1ctica utilizando GBD para depurar programas en C. Ganar m\u00e1s confianza al trabajar con punteros.","title":"Objetivos"},{"location":"labs/lab01/#preparacion","text":"Visiten este link . Aqu\u00ed encontrar\u00e1n todos los archivos necesarios para completar este lab. En esta p\u00e1gina, encontrar\u00e1n un bot\u00f3n que dice \"Accept assignment\". Al presionar este bot\u00f3n, se crear\u00e1 autom\u00e1ticamente un repositorio en Github llamado \"www.github.com/cc-3/lab1-c-gdb-USUARIO\". Noten que el \"due\u00f1o\" de este repositorio es un usuario llamado cc-3 , y el usuario de ustedes es \u00fanicamente el sufijo del nombre del repo. De esta forma, nos encargamos de tener acceso siempre a su c\u00f3digo, en caso existan copias o cualquier otro tipo de trampa. Sepan de una vez que, si encontramos plagio o cualquier otro tipo de trampa en sus laboratorios, su nota ser\u00e1 AUTOM\u00c1TICAMENTE 0, sin posibilidad de cambiarla. De repetirse nuevamente este acontecimiento, el staff del curso organizar\u00e1 una reuni\u00f3n con ustedes y sus directores de carrera para contarles lo ocurrido y sancionarlos conforme al reglamento de la universidad. Despu\u00e9s de realizar esto, en la m\u00e1quina virtual (o sus propias computadoras) abran una terminal en el directorio que prefieran, y ejecuten el siguiente comando: git clone https://github.com/cc-3/lab1-c-gdb-<SU USUARIO DE GITHUB> esto descargar\u00e1 en el directorio que escogieron todos los archivos base para este laboratorio.","title":"Preparaci\u00f3n"},{"location":"labs/lab01/#compilando-y-ejecutando-un-programa-de-c","text":"En este laboratorio, estaremos usando el programa gcc para compilar programas en c. La manera m\u00e1s sencilla de ejecutar gcc es la siguiente: gcc program.c Esto compila el archivo program.c y crea un archivo ejecutable llamado a.out . Si tienen experiencia en Java, pueden m\u00e1s o menos considerar a gcc como el equivalente en C de javac . Este archivo se puede ejecutar con el siguiente comando: ./a.out El archivo ejecutable es a.out , as\u00ed que, \u00bfqu\u00e9 rayos es eso de punto y diagonal? La respuesta: cuando quieren ejecutar un ejecutable, es necesario preponer una ruta de archivo para distinguirlo de un comando como python (no se utiliza ./python ). El punto se refiere al \"directorio actual\". De paso, dos puntos (..) se referir\u00edan al directorio que est\u00e1 un nivel arriba. gcc tiene varias opciones (o argumentos) de l\u00ednea de comandos, los cuales les recomendamos explorar. En este laboratorio, vamos a estar usando solamente -o, que se usa para especificar el nombre del ejecutable que gcc genera. Usando -o, se utilizar\u00edan estos comandos para compilar program.c en un archivo llamado program , y ejecutarlo. Eso nos sirve si no queremos que todos nuestros archivos ejecutables se llamen a.out . gcc -o program program.c ./program","title":"Compilando y ejecutando un programa de C"},{"location":"labs/lab01/#ejercicio-1-programa-simple-de-c","text":"En este ejercicio, veremos un ejemplo de definiciones macro de preprocesador. Las macros pueden ser un tema complicado, pero en general, la forma en que funcionan es que, antes de que un archivo en C es compilado, las constantes macro son reemplazadas exactamente por el valor al que se refieren. En este ejercicio, estaremos usando macros exclusivamente como constantes globales. Aqu\u00ed definimos CONSTANT_NAME como un literal_value (una literal entera). Noten que solo hay 1 espacio separando el nombre del valor. #define CONSTANT_NAME LITERAL_VALUE Ahora, vean el c\u00f3digo en eccentric.c (en el repo). Noten los cuatro diferentes ejemplos de control b\u00e1sico de flujo. (\u00bfCu\u00e1les son?) Compilen y ejecuten el programa para ver lo que hace. Jueguen con las constantes de las cuatro macros: v0 a v3 . Vean c\u00f3mo cambiar cada uno de estos cambia el output del programa. Su tarea: Modificando s\u00f3lo estos cuatro valores, hagan que el programa produzca el siguiente mensaje: $ gcc -o eccentric eccentric.c $ ./eccentric Berkeley eccentrics: ==================== Happy Happy Happy Yoshua Go BEARS! Hay m\u00faltiples combinaciones de valores en las macros que consiguen este resultado, El reto para ustedes en este ejercicio es: Consideren el m\u00ednimo n\u00famero de distintos valores que las constantes v0 a v3 puedan tener que a\u00fan den el mismo resultado correcto. Como ejemplo, el m\u00e1ximo te\u00f3rico es cuatro (cuando todos son diferentes uno de otro). Cuando ya hayan logrado esto, pueden actualizar el archivo en su repositorio en github, de esta manera: $ git add eccentric.c $ git commit -m \"Ejercicio 1 terminado\" $ git push -u origin master","title":"Ejercicio 1: Programa simple de C"},{"location":"labs/lab01/#ejercicio-2-debugger-depurador","text":"","title":"Ejercicio 2: Debugger (depurador)"},{"location":"labs/lab01/#que-es-un-debugger","text":"Este p\u00e1rrafo es para los estudiantes que no est\u00e1n familiarizados con los debuggers . Un debugger , como sugiere el nombre, es un programa espec\u00edficamente dise\u00f1ado para ayudarlos a encontrar bugs , o errores l\u00f3gicos, u otros errores en el c\u00f3digo (nota: si quieren saber por qu\u00e9 se les llama bugs a los errores, vean aqu\u00ed ). Distintos debuggers tienen distintas caracter\u00edsticas, pero es normal que todos los debuggers sean capaces de hacer las siguientes cosas: 1. Poner un breakpoint en el programa. Un Breakpoint es una l\u00ednea espec\u00edfica en su c\u00f3digo en donde quisieran que se detenga la ejecuci\u00f3n del programa, para que puedan ver lo que est\u00e1 pasando alrededor. 2. Ejecuci\u00f3n por Steps (l\u00ednea a l\u00ednea) por el programa. El c\u00f3digo siempre se ejecuta l\u00ednea a l\u00ednea, pero pasa muy r\u00e1pido como para que sepamos qu\u00e9 l\u00ednea produce alg\u00fan error. Ser capaces de ejecutar l\u00ednea a l\u00ednea el programa les permite observar exactamente qu\u00e9 esta causando un bug en el programa. Para este ejercicio, necesitar\u00e1n la GDB reference card . GDB quiere decir \"GNU De-Bugger\". Compilen hello.c con la bandera \"-g\": gcc -g -o hello hello.c Esto har\u00e1 que gcc guarde informaci\u00f3n en el archivo ejecutable para que gdb lo interprete. Ahora ejecuten el debugger, (c)gdb: cgdb hello Vean lo que hace este comando. Est\u00e1n ejecutando el programa cgdb en el ejecutable hello generado por gcc . No intenten ejecutar cgdb en el archivo fuente en hello.c ! Eso no va a funcionar. Si cgdb no funciona, gdb se puede usar para completar los ejercicios (utilicen gdb hello ). Su tarea: ejecuten el programa varias veces haciendo esto: 1. Poniendo un breakpoint en el main. 2. Usando el comando run de gdb. 3. Utilizando el comando single-step de gdb. Escriban help adentro de gdb para averiguar c\u00f3mo hacer estas cosas, o usen la reference card. Si encuentran un mensaje de error que dice: printf.c: No such file or directory . Probablemente entraron a una funci\u00f3n printf . Si siguen ejecutando paso a paso, pareciera que nunca avanzaran en el c\u00f3digo. CGDB est\u00e1 dando el error porque no tienen el archivo en el que se define la funci\u00f3n printf . Esto es algo molesto, y para librarse de esto, usen el comando finish para ejecutar el programa hasta que termine la funci\u00f3n printf. Y la pr\u00f3xima vez , utilicen el comando next para saltar sobre la linea que usa printf . Nota: CGDB vs GDB . En este ejercicio, usamos cgdb para depurar nuestros programas. cgdb es id\u00e9ntico a gdb, excepto que tiene unas caracter\u00edsticas extra que hacen m\u00e1s c\u00f3modo el trabajo. Todos los comandos de la hoja de referencia funcionan tambi\u00e9n en gdb. En cgdb, pueden presionar ESC para ir a la ventana del c\u00f3digo (arriba), y usar i para regresar a la ventana de comandos (abajo), similar a vim . La ventana de comandos es donde se introducen los comandos de gdb. Para este ejercicio, encontrar\u00e1n un archivo de texto llamado ex2.txt, con el siguiente formato: 1 : 2 : 3 : 4 : 5 : 6 : 7 : 8 : 9 : Aqu\u00ed tendr\u00e1n que responder las siguientes preguntas de opci\u00f3n m\u00faltiple (no tengan miedo de probar las opciones en CGDB antes de responder, \u00a1lo recomendamos!) con el siguiente formato (tienen que cambiar la letra en el ejemplo por la letra de la respuesta que ustedes consideren correcta): 1 :e 2 :f 3 :g 4 :h 5 :i 6 :j 7 :k 8 :l 9 :m Preguntas 1. \u00bfC\u00f3mo se le dan argumentos desde la l\u00ednea de comandos a un programa al utilizar gdb? a. args arglist b. run arglist c. gdb args d. Ninguna de las anteriores 2. \u00bfC\u00f3mo se a\u00f1ade un breakpoint que s\u00f3lo ocurre cuando se cumplen ciertas condiciones (por ejemplo, ciertas variables alcanzan cierto valor)? a. expr cond b. cond break expr c. break ... if expr d. Ninguna de las anteriores 3. \u00bfCon qu\u00e9 comando se ejecuta la siguiente l\u00ednea del c\u00f3digo en C despu\u00e9s de parar en un breakpoint? a. run b. s c. c d. n 4. Si la siguiente l\u00ednea de c\u00f3digo es una llamada a funci\u00f3n, \u00bfse ejecutar\u00eda toda la funci\u00f3n si se utiliza el comando de la pregunta #3? (si no, es momento de cambiarla!). \u00bfC\u00f3mo se le indica a gdb, que quieren debuggear el c\u00f3digo adentro de la funci\u00f3n ? (Si tuvieron que cambiar la respuesta #3, esa respuesta muy probablemente aplica aqu\u00ed) a. run b. s c. c d. n 5. \u00bfC\u00f3mo se reanuda la ejecuci\u00f3n del programa despu\u00e9s de parar en un breakpoint? a. run b. s c. c d. n 6. \u00bfC\u00f3mo podemos ver el valor de una variable (o expresi\u00f3n) en gdb? a. display expr b. signal expr c. print expr d. next expr 7. \u00bfQu\u00e9 comando de gdb se usa para desplegar el valor de una variable despu\u00e9s de cada paso ? a. display expr b. signal expr c. print expr d. next expr 8. \u00bfC\u00f3mo se imprime una lista de todas las variables y su valor en la funci\u00f3n actual? a. display all b. display c. print all d. print 9. \u00bfC\u00f3mo salimos de gdb? a. end b. quit c. exit d. finish Despu\u00e9s de responder estas preguntas, no olviden hacer el submit y push de este archivo hacia github: $ git add ex2.txt $ git commit -m \"Ejercicio 2 terminado\" $ git push -u origin master","title":"\u00bfQu\u00e9 es un debugger?"},{"location":"labs/lab01/#ejercicio-3-depurando-un-problema-con-fallas-usando-gdb","text":"Ahora, usar\u00e1n su nuevo conocimiento para depurar un peque\u00f1o programa. Vean el programa ll_equal.c . Compilen y ejecuten el programa, y analicen un poco lo que hace. As\u00ed como est\u00e1, producir\u00e1 un resultado como el siguiente: $ gcc -g -o ll_equal ll_equal.c $ ./ll_equal equal test 1 result = 1 Segmentation fault Averig\u00fcen qu\u00e9 produce el segmentation fault (falla de segmentaci\u00f3n) . Ejecuten gdb en el programa, siguiendo las instrucciones aprendidas en los ejercicios anteriores. Les recomendamos a\u00f1adir un breakpoint en la funci\u00f3n ll_equal() . Cuando el debugger pare en el breakpoint, ejecuten paso a paso el programa, para que puedan descifrar qu\u00e9 es lo que provoca el error. Pista: Analicen el valor de los punteros a y b en la funci\u00f3n (\u00a1despli\u00e9guenlos!). \u00bfEst\u00e1n siempre apuntando a la direcci\u00f3n correcta? Pista 2: Vean el c\u00f3digo fuente en main para ver la estructura de los nodos y ver exactamente qu\u00e9 est\u00e1 pasando como argumento a ll_equal . Despu\u00e9s de corregir el problema, compilen nuevamente y ejecuten el c\u00f3digo. \u00bfNotan la diferencia? Al finalizar, no olviden subir el archivo modificado a su repositorio remoto: $ git add ll_equal.c $ git commit -m \"Ejercicio 2 terminado\" $ git push -u origin master","title":"Ejercicio 3: Depurando un problema con fallas usando GDB"},{"location":"labs/lab01/#ejercicio-4-debuggeando-un-programa-en-c-que-requiere-interaccion-del-usuario","text":"Veamos qu\u00e9 pasa cuando, a un programa que requiere interacci\u00f3n del usuario, lo ejecutamos con gdb. Primero, ejecuten el programa en interactive_hello.c para hablar con un programa muy amigable :). $ gcc -g -o int_hello interactive_hello.c $ ./int_hello Ahora, traten de depurarlo (aunque no haya ning\u00fan problema realmente): $ cgdb int_hello \u00bfQu\u00e9 pasa cuando intentar ejecutar el programa hasta el final? Vamos a aprender acerca de una herramienta que nos ayudar\u00e1 a evitar este problema. El prop\u00f3sito de este ejercicio es que no tengan miedo de usar un debugger incluso cuando el programa requiera de interacci\u00f3n con el usuario. Resulta que es posible enviar texto a stdin , el flujo de datos que es le\u00eddo por la funci\u00f3n fgets en este programa, con unos caracteres especiales desde la l\u00ednea de comandos. Echen un vistazo a la \"redirecci\u00f3n\" en esta p\u00e1gina , y vean si pueden descifrar c\u00f3mo enviar texto al programa sin escribirlo textualmente mientras el programa est\u00e1 en ejecuci\u00f3n (lo cual, como ya saben, no funciona bien en CGDB). Pueden ver esta discusi\u00f3n de stackoverflow para m\u00e1s inspiraci\u00f3n. (Pista 1: \u00a1Si est\u00e1n creando un archivo de texto que contiene su input, van bien!) (pista 2: Recuerden que es posible ejecutar programas con argumentos (incluyendo s\u00edmbolos de redirecci\u00f3n) desde CGDB! Esperamos que hayan comprendido c\u00f3mo utilizar redirecci\u00f3n y c\u00f3mo es que esto les ayuda a evitar varios problemas al usar CGDB. \u00a1Nunca tengan miedo de usar un debugger ! Tal vez no es muy agradable visualmente, pero siempre estar\u00e1 para ayudarlos. Este ejercicio no vale puntos :-) pero es importante conocer sobre estas cosas para que puedan utilizarlo en el futuro (los siguientes laboratorios y proyectos podr\u00edan necesitar de este conocimiento)","title":"Ejercicio 4: \"Debuggeando\" un programa en C que requiere interacci\u00f3n del usuario"},{"location":"labs/lab01/#ejercicio-5-punteros-y-estructuras-en-c","text":"En ll_cycle.c, completen la funci\u00f3n ll_has_cycle(), de modo que implemente el siguiente algoritmo para comprobar si una linked list simple tiene un ciclo: 1. Comiencen con dos punteros apuntando al principio de la lista. Llamaremos al primero tortoise (tortuga) y al segundo hare (liebre). 2. Avancen el puntero hare dos nodos hacia adelante. Si no se puede debido a punteros null , hemos llegado al final de la lista. Por lo tanto, la lista no tiene un ciclo. 3. Ahora, avancen tortoise un nodo. (Revisar si llega a ser un puntero nulo es innecesario. \u00bfPor qu\u00e9?) 4. Si la tortuga y la liebre apuntan al mismo nodo, la lista es c\u00edclica. Si no, regresen al paso 2. Despu\u00e9s de implementar correctamente la funci\u00f3n ll_has_cycle() , el programa que se obtiene despu\u00e9s de compilar ll_cycle.c mostrar\u00e1 si el resultado de su funci\u00f3n est\u00e1 correcto, conforme a lo que esperaba como salida. Pista: Hay dos formas comunes en que los estudiantes resuelven esta funci\u00f3n, y la diferencia principal est\u00e1 en la forma en que deciden codificar el criterio de c\u00f3mo finalizar. Si lo hacen de una forma, tendr\u00edan que tomar en cuenta un caso especial en el principio. Si lo hacen de otra forma, tendr\u00edan que tener unas pruebas extra de NULL, lo cual esta bien tambi\u00e9n. Les decimos esto para que no se preocupen de la \"limpieza\" de su c\u00f3digo, si no les ayuda, simplemente ignoren esta pista. El punto de este ejercicio es asegurarse de que entiendan como usar punteros. Aqu\u00ed hay un Art\u00edculo del algoritmo y por qu\u00e9 funciona. No se preocupen de entender completamente todo (no hay examen de esto). A prop\u00f3sito, los punteros se llaman tortoise y hare porque el puntero \"tortoise (tortuga)\" se incrementa lentamente (como una tortuga, que se mueve muy lento) y el puntero \"hare (liebre)\" se incrementa r\u00e1pidamente (m\u00e1s r\u00e1pido que una tortuga, como una liebre, o conejo, que se mueve muy r\u00e1pido). Al finalizar, compilen y ejecuten el archivo, y verifiquen que el resultado de su c\u00f3digo, el cual deber\u00eda ser m\u00e1s o menos igual a este: $ gcc -g -o ll_cycle ll_cycle.c $ ./ll_cycle Checking first list for cycles. There should be none, ll_has_cycle says it has no cycle Checking second list for cycles. There should be a cycle, ll_has_cycle says it has a cycle Checking third list for cycles. There should be a cycle, ll_has_cycle says it has a cycle Checking fourth list for cycles. There should be a cycle, ll_has_cycle says it has a cycle Checking fifth list for cycles. There should be none, ll_has_cycle says it has no cycle Checking length-zero list for cycles. There should be none, ll_has_cycle says it has no cycle Si su c\u00f3digo presenta errores, entonces ya son capaces de utilizar CGDB para poder encontrarlos y corregirlos. Finalmente, pueden subir el archivo a github: $ git add ll_cycle.c $ git commit -m \"LAB01 terminado\" $ git push -u origin master Ya con todos los ejercicios completados, no olviden ejecutar ./submit TOKEN Para poder ver su nota. Para finalizar, la par\u00e1bola de la tortuga y la liebre es relevante siempre, especialmente en este curso. Escribir sus programas en C a paso lento pero seguro (ayud\u00e1ndose de programas como CGDB) es lo que les har\u00e1 ganar la carrera.","title":"Ejercicio 5: Punteros y estructuras en C"},{"location":"labs/lab02/","text":"Lab 2 - C Avanzado y Manejo de Memoria \u00b6 Objetivos \u00b6 Manipular los bits de n\u00fameros binarios. Aprendan a utilizar sus nuevos poderes. Practicar trabajar con la asignaci\u00f3n de memoria de manera din\u00e1mica (esa cosa de malloc ). Aprovechar toda la memoria no utilizada. Pensar c\u00f3mo el manejo de memoria din\u00e1mica los puede hacer mejores personas. Son bromas, pero s\u00f3lo los puede volver mejores programadores. Preparaci\u00f3n \u00b6 De primero, deben de descargar todos los archivos que necesitar\u00e1n para completar este laboratorio, estos se encuentran aqu\u00ed . Recuerden que deben aceptar la asignaci\u00f3n y se les crear\u00e1 autom\u00e1ticamente un repositorio con una extensi\u00f3n que termina con su usuario. Recuerden que este ser\u00e1 revisado en b\u00fasqueda de copia o plagio, as\u00ed que no lo hagan. De lo contrario, ser\u00e1 sancionado acorde al reglamento de la universidad. Ahora, ya pueden ejecutar en la terminal el comando que les descargar\u00e1 los archivos base en el directorio a su elecci\u00f3n: git clone link_al_lab Ejercicio 1: Operando Bits \u00b6 Para este inciso, su trabajo es completar los archivos ex1/get_bit.c , ex1/set_bit.c y ex1/flip_bit.c de manera que las funciones cumplan con su tarea (as\u00ed como el nombre de las funciones sugiere). Para ello deber\u00e1n utilizar las operaciones de bits b\u00e1sicas: and (&), or (|), xor (^), not (~) y los corrimientos a la derecha (>>) y a la izquierda (<<). Deben evitar el uso de ciclos o condicionales. \u00a1\u00a1\u00a1\u00a1No usen ciclos ni condicionales!!!! Eso significa que mientras realicen el ejercicio no pueden y no deben de escribir las palabras: if, else, do, while, for, switch o algo de \u00edndole similar. Por favor no traten de enga\u00f1arnos, todo el personal involucrado (esperamos) sabe c\u00f3mo se miran todas estas palabras, entonces si encontramos una de ellas... El autograder analiza su c\u00f3digo de todas formas... \u00af\\_(\u30c4)_/\u00af sorry not sorry NOTA IMPORTANTE: Considerar que n es un valor que inicia en la posici\u00f3n cero, contando desde la derecha, por lo que el bit que se encuentra hasta la derecha es el bit cero. // Return the nth bit of x. // Assume 0 <= n <= 31 unsigned get_bit ( unsigned x , unsigned n ); // Set the nth bit of the value of x to v. // Assume 0 <= n <= 31, and v is 0 or 1 void set_bit ( unsigned * x , unsigned n , unsigned v ); // Flip the nth bit of the value of x. // Assume 0 <= n <= 31 void flip_bit ( unsigned * x , unsigned n ); Ayuda para set_bit : La parte complicada es no saber el valor del bit antes de cambiarlo. Pero, sabemos que 0 | x = x , pero \u00bfpodemos aprovecharnos de esto? \u00bfEs posible volverlo cero? Una vez terminen de editar las funciones, pueden compilar y correr el c\u00f3digo con: make bit_ops ./bit_ops Lo cual imprimir\u00e1 el resultado de algunas pruebas. Si tienen curiosidad pueden revisar con libertad la carpeta tests/ que contiene las pruebas que se van a realizar en cada ejercicio de este laboratorio y que reflejan bastante lo que evaluar\u00e1 el autograder, por ejemplo el archivo que se utiliza para este ejercicio es tests/bit_ops_test.c . De ahora en adelante hasta que esten 100% seguros de que tienen completo el laboratorio o ya est\u00e9 cerca la hora de entregar su laboratorio, pueden mandar sus archivos como en los laboratorios pasados utilizando ./submit <TOKEN> . Acu\u00e9rdense de realizar el proceso de \"hacerle push\" al archivo para subirlo al repositorio de GitHub. Ejercicio 2: Registro de Corrimiento con Retroalimentaci\u00f3n Lineal \u00b6 En este ejercicio deben de implementar una funci\u00f3n que compute la siguiente iteraci\u00f3n de un registro de corrimiento de retroalimentaci\u00f3n lineal (LFSR por sus siglas en ingl\u00e9s). \u00a1Algunas aplicaciones que utilizan LFSRs son: televisi\u00f3n digital, tel\u00e9fonos con acceso m\u00faltiple por divisi\u00f3n de c\u00f3digo, Ethernet, USB 3.0 y mucho m\u00e1s! Esta funci\u00f3n deber\u00e1 generar n\u00fameros pseudo-aleatorios utilizando operadores binarios. Para un poco de informaci\u00f3n adicional, pueden visitar el siguiente link de Wikipedia . En el archivo ex2/lfsr_calculate.c deben de completar la funci\u00f3n lfsr_calculate() de manera que realice lo siguiente: Diagrama del Hardware (Explicaci\u00f3n M\u00e1s Abajo) \u00b6 Explicaci\u00f3n del Diagrama de Arriba \u00b6 En cada llamada de lfsr_calculate() , deben de correr el contenido del registro un bit hacia la derecha. Este corrimiento no es ni l\u00f3gico, ni aritm\u00e9tico. En el lado izquierdo deben de colocar un bit equivalente a un XOR de los bits que estaban, originalmente, en las posiciones 1, 3, 4 y 6. El objeto que parece un faro de autom\u00f3vil curvado es un XOR, el cual recibe dos entradas (a, b) y devuelve en su salida a^b. A diferencia del ejercicio 1, las posiciones de los bits inician con 1 . Despu\u00e9s que hayan implementado de manera correcta lfsr_calculate() , compilen y c\u00f3rranlo. Su respuesta debe ser similar a lo siguiente: make lfsr ./lfsr My number is: 1 My number is: 5185 My number is: 38801 My number is: 52819 My number is: 21116 My number is: 54726 My number is: 26552 My number is: 46916 My number is: 41728 My number is: 26004 My number is: 62850 My number is: 40625 My number is: 647 My number is: 12837 My number is: 7043 My number is: 26003 My number is: 35845 My number is: 61398 My number is: 42863 My number is: 57133 My number is: 59156 My number is: 13312 My number is: 16285 ... etc etc ... Got 65535 numbers before cycling! Congratulations! It works! De nuevo, recu\u00e9rdense de hacer el push. Ejercicio 3: Manejo de Memoria \u00b6 Este ejercicio requiere de los archivos: tests/include/vector.h , tests/vector_test.c y ex3/vector.c , en donde les proveemos con la base para la implementaci\u00f3n de un arreglo de longitud variable. Este inciso busca que se familiaricen con el uso de los \"structs\" de C, as\u00ed como el manejo de memoria en este lenguaje. En otras palabras, no se preocupen por los detalles pr\u00e1cticos de esta estructura de datos un tanto extra\u00f1a. S\u00f3lo no lo hagan. Su trabajo es completar las funciones vector_new() , vector_get() , vector_delete() y vector_set() en ex3/vector.c de manera que tests/vector-test.c corra sin errores de manejo de memoria. \u00bfC\u00f3mo funciona un vector_t ? \u00b6 Posee un int size que indica cu\u00e1ntos elementos posee actualmente. En otras palabras, el size es igual al \u00edndice de la \u00faltima posici\u00f3n que ha sido alterada del vector. Por ejemplo, si se tiene un vector con un size de 5 y se altera su ducent\u00e9cimo bit (\u00edndice iniciando en cero), su tama\u00f1o se ver\u00e1 actualizado a 201. La longitud por defecto del vector vector_new es de 1. Tiene un int *data , un arreglo din\u00e1mico de enteros que contiene los valores de los componentes del vector. Si se altera el ducent\u00e9cimo elemento de un vector v a 8 entonces el elemento modificado (de nuevo, iniciando en cero) de v->data deber\u00eda evaluar a 8. El valor de un vector vector_new es 0 por defecto. El valor de cualquier componente de alg\u00fan vector que no ha sido expl\u00edcitamente editado es 0. Si se deseara conocer el valor en la quinta posici\u00f3n de un vector, pero s\u00f3lo se ha alterado el valor de los primeras dos, la interrogante tendr\u00eda como respuesta 0. Adem\u00e1s, si se quisiera el contenido en la s\u00e9ptima posici\u00f3n de un vector de longitud igual a 5, tambi\u00e9n ser\u00eda 0. NO devolver\u00eda un error. Es momento de revisar el c\u00f3digo de ex3/vector.c si no lo han hecho. Aqu\u00ed hay comentarios complementarios que describen c\u00f3mo deber\u00edan de correr las funciones. Recuerden que los usuarios de su estructura de datos vector_t deben asumir que todas las entradas al vector son 0, a menos que hayan sido definidas de otra manera por ellos. Tengan esto en mente, porque malloc no hace esto por ustedes. \u00bfQu\u00e9 deben hacer? \u00b6 Completen vector_new , la versi\u00f3n correcta. Hay exactamente seis (6) espacios para que escriban una expresi\u00f3n en C, indicados con el comentario que dice /* YOUR CODE HERE */ . Escriban una expresi\u00f3n en estos sitios. Esto significa no m\u00e1s de una l\u00ednea de c\u00f3digo. Existen comentarios adicionales que describen qu\u00e9 deber\u00eda de suceder en la l\u00ednea de c\u00f3digo inferior a cada divisi\u00f3n. Terminen vector_get() de la misma manera en que lo hicieron para la funci\u00f3n anterior: de manera respetuosa, dispuesto a aprender, con mente abierta y conscientes de qu\u00e9 es lo que est\u00e1n escribiendo, ya que esta es la mejor forma de programar. Complementen vector_delete() . Una soluci\u00f3n satisfactoria no deber\u00eda de llevar m\u00e1s de dos l\u00edneas de c\u00f3digo. Corrijan a vector_set() . Esta es la m\u00e1s complicada. Bienvenidos a las ligas mayores. El problema de manipular una posici\u00f3n/\u00edndice arbitrario en un vector v es que es posible que no se haya reservado suficiente espacio con malloc en vector->data (s\u00ed, eso significa que tuvieron que haber guardado memoria con malloc ). Piensen c\u00f3mo administrar la memoria para lograr esto, para ver qu\u00e9 hacer con la data que estaba ah\u00ed antes y de qu\u00e9 otras cosas deben de hacer en su nuevo bloque de datos. Ayuda: Recuerden que los \u00edndices que no hayan sido alterados deben de ser cero. Hay distintas formas de acabar resolviendo esta funci\u00f3n. Consideren el uso de las 3 funciones __alloc , porque pueden resultar \u00fatiles... Saber c\u00f3mo reorganizar y liberar memoria es importante para la programaci\u00f3n en C. Piensen que el manejo de memoria es como un parqueo, si hay carros parqueados y los due\u00f1os nunca se van, entonces no tienen espacio para nuevos carros. Y recuerden que deber\u00edan tener un 'heap' vac\u00edo al terminar su programa. Utilicen free y todo estar\u00e1 bien. Calificaci\u00f3n \u00b6 Como en todos los dem\u00e1s laboratorios, hay un autograder y este no es la excepci\u00f3n. El staff trabajo bastante para que su experiencia en este curso sea de las mejores, por eso ahora pueden visitar la siguiente p\u00e1gina https://dashboard.cc-3.site/ en donde al iniciar sesi\u00f3n, con su cuenta de galileo , puedan ver el reporte de notas de los laboratorios y proyectos. Submit \u00b6 Si ustedes navegan hacia la p\u00e1gina de laboratorios , all\u00ed van a aparecer el estado de sus laboratorios, si ya est\u00e1n calificados o est\u00e1n pendientes de calificar por el autograder, la fecha y hora en que lo subieron al hacer ./submit y el output de la consola y esto en tiempo real. De esta manera pueden obtener el feedback m\u00e1s rapidamente en caso en el GES todav\u00eda no est\u00e9n subidas las notas. Como notar\u00e1n en este laboratorio y en adelante ahora cuando hagan submit, el resultado no les aparecer\u00e1 inmediatamente en la consola, sino que se subir\u00e1 a nuestros servidores, entrar\u00e1 a una cola de espera y eventualmente ser\u00e1 calificado. Si el autograder todav\u00eda no ha terminado de calificarles sus archivos no les dejar\u00e1 volver hacer submit, esto es para animarlos a que hagan primero sus pruebas locales con los tests que les damos antes de subir los archivos al autograder. Recuerden para hacer submit al autograder siempre es: ./submit TOKEN NOTA : Tienen que crear su nuevo token en la p\u00e1gina https://dashboard.cc-3.site/ Server Status \u00b6 Finalmente, ya que todo esto utiliza recursos de AWS EC2 y que es un servicio que consume cr\u00e9ditos del staff el servidor se apagar\u00e1 cuando haya terminado la fecha l\u00edmite para subir el laboratorio al autograder indicada en el GES, as\u00ed que tomen en cuenta esto. Cuando el servidor est\u00e1 prendido y est\u00e1 recibiendo peticiones de ustedes lo notar\u00e1n en el pie de p\u00e1gina: El punto verde significa que el servidor esta recibiendo peticiones y a la derecha les dice el tama\u00f1o de la cola (submits pendientes de calificar). Cuando est\u00e9 as\u00ed pueden mandar sus archivos al autograder. Cuando el servidor est\u00e1 apagado lo notar\u00e1n de igual manera: El punto rojo significa que el servidor no est\u00e1 aceptando peticiones, as\u00ed que si ven esto son malas noticias si no han terminado la asignaci\u00f3n. Si ustedes notan este punto rojo y todav\u00eda su calificaci\u00f3n les aparece pendiente (porque hicieron submit antes), no se preocupen ya est\u00e1 en camino a ser calificado y en su momento les aparecer\u00e1 su nota. NOTA : recuerden hacer submit, primero generando su nuevo token luego: ./submit","title":"2: C y MM"},{"location":"labs/lab02/#lab-2-c-avanzado-y-manejo-de-memoria","text":"","title":"Lab 2 - C Avanzado y Manejo de Memoria"},{"location":"labs/lab02/#objetivos","text":"Manipular los bits de n\u00fameros binarios. Aprendan a utilizar sus nuevos poderes. Practicar trabajar con la asignaci\u00f3n de memoria de manera din\u00e1mica (esa cosa de malloc ). Aprovechar toda la memoria no utilizada. Pensar c\u00f3mo el manejo de memoria din\u00e1mica los puede hacer mejores personas. Son bromas, pero s\u00f3lo los puede volver mejores programadores.","title":"Objetivos"},{"location":"labs/lab02/#preparacion","text":"De primero, deben de descargar todos los archivos que necesitar\u00e1n para completar este laboratorio, estos se encuentran aqu\u00ed . Recuerden que deben aceptar la asignaci\u00f3n y se les crear\u00e1 autom\u00e1ticamente un repositorio con una extensi\u00f3n que termina con su usuario. Recuerden que este ser\u00e1 revisado en b\u00fasqueda de copia o plagio, as\u00ed que no lo hagan. De lo contrario, ser\u00e1 sancionado acorde al reglamento de la universidad. Ahora, ya pueden ejecutar en la terminal el comando que les descargar\u00e1 los archivos base en el directorio a su elecci\u00f3n: git clone link_al_lab","title":"Preparaci\u00f3n"},{"location":"labs/lab02/#ejercicio-1-operando-bits","text":"Para este inciso, su trabajo es completar los archivos ex1/get_bit.c , ex1/set_bit.c y ex1/flip_bit.c de manera que las funciones cumplan con su tarea (as\u00ed como el nombre de las funciones sugiere). Para ello deber\u00e1n utilizar las operaciones de bits b\u00e1sicas: and (&), or (|), xor (^), not (~) y los corrimientos a la derecha (>>) y a la izquierda (<<). Deben evitar el uso de ciclos o condicionales. \u00a1\u00a1\u00a1\u00a1No usen ciclos ni condicionales!!!! Eso significa que mientras realicen el ejercicio no pueden y no deben de escribir las palabras: if, else, do, while, for, switch o algo de \u00edndole similar. Por favor no traten de enga\u00f1arnos, todo el personal involucrado (esperamos) sabe c\u00f3mo se miran todas estas palabras, entonces si encontramos una de ellas... El autograder analiza su c\u00f3digo de todas formas... \u00af\\_(\u30c4)_/\u00af sorry not sorry NOTA IMPORTANTE: Considerar que n es un valor que inicia en la posici\u00f3n cero, contando desde la derecha, por lo que el bit que se encuentra hasta la derecha es el bit cero. // Return the nth bit of x. // Assume 0 <= n <= 31 unsigned get_bit ( unsigned x , unsigned n ); // Set the nth bit of the value of x to v. // Assume 0 <= n <= 31, and v is 0 or 1 void set_bit ( unsigned * x , unsigned n , unsigned v ); // Flip the nth bit of the value of x. // Assume 0 <= n <= 31 void flip_bit ( unsigned * x , unsigned n ); Ayuda para set_bit : La parte complicada es no saber el valor del bit antes de cambiarlo. Pero, sabemos que 0 | x = x , pero \u00bfpodemos aprovecharnos de esto? \u00bfEs posible volverlo cero? Una vez terminen de editar las funciones, pueden compilar y correr el c\u00f3digo con: make bit_ops ./bit_ops Lo cual imprimir\u00e1 el resultado de algunas pruebas. Si tienen curiosidad pueden revisar con libertad la carpeta tests/ que contiene las pruebas que se van a realizar en cada ejercicio de este laboratorio y que reflejan bastante lo que evaluar\u00e1 el autograder, por ejemplo el archivo que se utiliza para este ejercicio es tests/bit_ops_test.c . De ahora en adelante hasta que esten 100% seguros de que tienen completo el laboratorio o ya est\u00e9 cerca la hora de entregar su laboratorio, pueden mandar sus archivos como en los laboratorios pasados utilizando ./submit <TOKEN> . Acu\u00e9rdense de realizar el proceso de \"hacerle push\" al archivo para subirlo al repositorio de GitHub.","title":"Ejercicio 1: Operando Bits"},{"location":"labs/lab02/#ejercicio-2-registro-de-corrimiento-con-retroalimentacion-lineal","text":"En este ejercicio deben de implementar una funci\u00f3n que compute la siguiente iteraci\u00f3n de un registro de corrimiento de retroalimentaci\u00f3n lineal (LFSR por sus siglas en ingl\u00e9s). \u00a1Algunas aplicaciones que utilizan LFSRs son: televisi\u00f3n digital, tel\u00e9fonos con acceso m\u00faltiple por divisi\u00f3n de c\u00f3digo, Ethernet, USB 3.0 y mucho m\u00e1s! Esta funci\u00f3n deber\u00e1 generar n\u00fameros pseudo-aleatorios utilizando operadores binarios. Para un poco de informaci\u00f3n adicional, pueden visitar el siguiente link de Wikipedia . En el archivo ex2/lfsr_calculate.c deben de completar la funci\u00f3n lfsr_calculate() de manera que realice lo siguiente:","title":"Ejercicio 2: Registro de Corrimiento con Retroalimentaci\u00f3n Lineal"},{"location":"labs/lab02/#diagrama-del-hardware-explicacion-mas-abajo","text":"","title":"Diagrama del Hardware (Explicaci\u00f3n M\u00e1s Abajo)"},{"location":"labs/lab02/#explicacion-del-diagrama-de-arriba","text":"En cada llamada de lfsr_calculate() , deben de correr el contenido del registro un bit hacia la derecha. Este corrimiento no es ni l\u00f3gico, ni aritm\u00e9tico. En el lado izquierdo deben de colocar un bit equivalente a un XOR de los bits que estaban, originalmente, en las posiciones 1, 3, 4 y 6. El objeto que parece un faro de autom\u00f3vil curvado es un XOR, el cual recibe dos entradas (a, b) y devuelve en su salida a^b. A diferencia del ejercicio 1, las posiciones de los bits inician con 1 . Despu\u00e9s que hayan implementado de manera correcta lfsr_calculate() , compilen y c\u00f3rranlo. Su respuesta debe ser similar a lo siguiente: make lfsr ./lfsr My number is: 1 My number is: 5185 My number is: 38801 My number is: 52819 My number is: 21116 My number is: 54726 My number is: 26552 My number is: 46916 My number is: 41728 My number is: 26004 My number is: 62850 My number is: 40625 My number is: 647 My number is: 12837 My number is: 7043 My number is: 26003 My number is: 35845 My number is: 61398 My number is: 42863 My number is: 57133 My number is: 59156 My number is: 13312 My number is: 16285 ... etc etc ... Got 65535 numbers before cycling! Congratulations! It works! De nuevo, recu\u00e9rdense de hacer el push.","title":"Explicaci\u00f3n del Diagrama de Arriba"},{"location":"labs/lab02/#ejercicio-3-manejo-de-memoria","text":"Este ejercicio requiere de los archivos: tests/include/vector.h , tests/vector_test.c y ex3/vector.c , en donde les proveemos con la base para la implementaci\u00f3n de un arreglo de longitud variable. Este inciso busca que se familiaricen con el uso de los \"structs\" de C, as\u00ed como el manejo de memoria en este lenguaje. En otras palabras, no se preocupen por los detalles pr\u00e1cticos de esta estructura de datos un tanto extra\u00f1a. S\u00f3lo no lo hagan. Su trabajo es completar las funciones vector_new() , vector_get() , vector_delete() y vector_set() en ex3/vector.c de manera que tests/vector-test.c corra sin errores de manejo de memoria.","title":"Ejercicio 3: Manejo de Memoria"},{"location":"labs/lab02/#como-funciona-un-vector_t","text":"Posee un int size que indica cu\u00e1ntos elementos posee actualmente. En otras palabras, el size es igual al \u00edndice de la \u00faltima posici\u00f3n que ha sido alterada del vector. Por ejemplo, si se tiene un vector con un size de 5 y se altera su ducent\u00e9cimo bit (\u00edndice iniciando en cero), su tama\u00f1o se ver\u00e1 actualizado a 201. La longitud por defecto del vector vector_new es de 1. Tiene un int *data , un arreglo din\u00e1mico de enteros que contiene los valores de los componentes del vector. Si se altera el ducent\u00e9cimo elemento de un vector v a 8 entonces el elemento modificado (de nuevo, iniciando en cero) de v->data deber\u00eda evaluar a 8. El valor de un vector vector_new es 0 por defecto. El valor de cualquier componente de alg\u00fan vector que no ha sido expl\u00edcitamente editado es 0. Si se deseara conocer el valor en la quinta posici\u00f3n de un vector, pero s\u00f3lo se ha alterado el valor de los primeras dos, la interrogante tendr\u00eda como respuesta 0. Adem\u00e1s, si se quisiera el contenido en la s\u00e9ptima posici\u00f3n de un vector de longitud igual a 5, tambi\u00e9n ser\u00eda 0. NO devolver\u00eda un error. Es momento de revisar el c\u00f3digo de ex3/vector.c si no lo han hecho. Aqu\u00ed hay comentarios complementarios que describen c\u00f3mo deber\u00edan de correr las funciones. Recuerden que los usuarios de su estructura de datos vector_t deben asumir que todas las entradas al vector son 0, a menos que hayan sido definidas de otra manera por ellos. Tengan esto en mente, porque malloc no hace esto por ustedes.","title":"\u00bfC\u00f3mo funciona un vector_t?"},{"location":"labs/lab02/#que-deben-hacer","text":"Completen vector_new , la versi\u00f3n correcta. Hay exactamente seis (6) espacios para que escriban una expresi\u00f3n en C, indicados con el comentario que dice /* YOUR CODE HERE */ . Escriban una expresi\u00f3n en estos sitios. Esto significa no m\u00e1s de una l\u00ednea de c\u00f3digo. Existen comentarios adicionales que describen qu\u00e9 deber\u00eda de suceder en la l\u00ednea de c\u00f3digo inferior a cada divisi\u00f3n. Terminen vector_get() de la misma manera en que lo hicieron para la funci\u00f3n anterior: de manera respetuosa, dispuesto a aprender, con mente abierta y conscientes de qu\u00e9 es lo que est\u00e1n escribiendo, ya que esta es la mejor forma de programar. Complementen vector_delete() . Una soluci\u00f3n satisfactoria no deber\u00eda de llevar m\u00e1s de dos l\u00edneas de c\u00f3digo. Corrijan a vector_set() . Esta es la m\u00e1s complicada. Bienvenidos a las ligas mayores. El problema de manipular una posici\u00f3n/\u00edndice arbitrario en un vector v es que es posible que no se haya reservado suficiente espacio con malloc en vector->data (s\u00ed, eso significa que tuvieron que haber guardado memoria con malloc ). Piensen c\u00f3mo administrar la memoria para lograr esto, para ver qu\u00e9 hacer con la data que estaba ah\u00ed antes y de qu\u00e9 otras cosas deben de hacer en su nuevo bloque de datos. Ayuda: Recuerden que los \u00edndices que no hayan sido alterados deben de ser cero. Hay distintas formas de acabar resolviendo esta funci\u00f3n. Consideren el uso de las 3 funciones __alloc , porque pueden resultar \u00fatiles... Saber c\u00f3mo reorganizar y liberar memoria es importante para la programaci\u00f3n en C. Piensen que el manejo de memoria es como un parqueo, si hay carros parqueados y los due\u00f1os nunca se van, entonces no tienen espacio para nuevos carros. Y recuerden que deber\u00edan tener un 'heap' vac\u00edo al terminar su programa. Utilicen free y todo estar\u00e1 bien.","title":"\u00bfQu\u00e9 deben hacer?"},{"location":"labs/lab02/#calificacion","text":"Como en todos los dem\u00e1s laboratorios, hay un autograder y este no es la excepci\u00f3n. El staff trabajo bastante para que su experiencia en este curso sea de las mejores, por eso ahora pueden visitar la siguiente p\u00e1gina https://dashboard.cc-3.site/ en donde al iniciar sesi\u00f3n, con su cuenta de galileo , puedan ver el reporte de notas de los laboratorios y proyectos.","title":"Calificaci\u00f3n"},{"location":"labs/lab02/#submit","text":"Si ustedes navegan hacia la p\u00e1gina de laboratorios , all\u00ed van a aparecer el estado de sus laboratorios, si ya est\u00e1n calificados o est\u00e1n pendientes de calificar por el autograder, la fecha y hora en que lo subieron al hacer ./submit y el output de la consola y esto en tiempo real. De esta manera pueden obtener el feedback m\u00e1s rapidamente en caso en el GES todav\u00eda no est\u00e9n subidas las notas. Como notar\u00e1n en este laboratorio y en adelante ahora cuando hagan submit, el resultado no les aparecer\u00e1 inmediatamente en la consola, sino que se subir\u00e1 a nuestros servidores, entrar\u00e1 a una cola de espera y eventualmente ser\u00e1 calificado. Si el autograder todav\u00eda no ha terminado de calificarles sus archivos no les dejar\u00e1 volver hacer submit, esto es para animarlos a que hagan primero sus pruebas locales con los tests que les damos antes de subir los archivos al autograder. Recuerden para hacer submit al autograder siempre es: ./submit TOKEN NOTA : Tienen que crear su nuevo token en la p\u00e1gina https://dashboard.cc-3.site/","title":"Submit"},{"location":"labs/lab02/#server-status","text":"Finalmente, ya que todo esto utiliza recursos de AWS EC2 y que es un servicio que consume cr\u00e9ditos del staff el servidor se apagar\u00e1 cuando haya terminado la fecha l\u00edmite para subir el laboratorio al autograder indicada en el GES, as\u00ed que tomen en cuenta esto. Cuando el servidor est\u00e1 prendido y est\u00e1 recibiendo peticiones de ustedes lo notar\u00e1n en el pie de p\u00e1gina: El punto verde significa que el servidor esta recibiendo peticiones y a la derecha les dice el tama\u00f1o de la cola (submits pendientes de calificar). Cuando est\u00e9 as\u00ed pueden mandar sus archivos al autograder. Cuando el servidor est\u00e1 apagado lo notar\u00e1n de igual manera: El punto rojo significa que el servidor no est\u00e1 aceptando peticiones, as\u00ed que si ven esto son malas noticias si no han terminado la asignaci\u00f3n. Si ustedes notan este punto rojo y todav\u00eda su calificaci\u00f3n les aparece pendiente (porque hicieron submit antes), no se preocupen ya est\u00e1 en camino a ser calificado y en su momento les aparecer\u00e1 su nota. NOTA : recuerden hacer submit, primero generando su nuevo token luego: ./submit","title":"Server Status"},{"location":"labs/lab03/","text":"Lab 3 - RISC-V \u00b6 Objetivos \u00b6 Practicar, corriendo y debuggeando c\u00f3digo ensamblador RISC-V. Escribir funciones en RISC-V con el procedimiento correcto de llamadas a funciones. Tener una idea de como traducir c\u00f3digo en C a RISC-V. Lecturas \u00b6 P&H: 2.12 Preparaci\u00f3n \u00b6 Para comenzar con el laboratorio primero tienen que tener todos los archivos base, estos se encuentran aqu\u00ed . Recuerden que deben aceptar la asignaci\u00f3n de GitHub Classroom y se les crear\u00e1 autom\u00e1ticamente un repositorio con una extensi\u00f3n que termina con su usuario de GitHub. Cuando ya se haya creado el repositorio, pueden ejecutar los siguientes comandos abriendo una terminal ( CTRL + T ): git clone <link del repositorio> NOTA : Tienen que reemplazar <link del repositorio> con el link del repositorio que se cre\u00f3. Introducci\u00f3n a Lenguaje Ensamblador RISC-V \u00b6 Los siguientes ejercicios utilizan un ensamblador y simulador de RISC-V, desarrollado por nuestro auxiliar Andr\u00e9s Castellanos . El simulador se llama V-Sim y es un proyecto open source inspirado, inicialmente, en el lengendario SPIM y, posteriormente, en MARS y VENUS para la versi\u00f3n gr\u00e1fica. Para instalarlo en su computadora s\u00f3lo necesitan ejecutar en una terminal uno de los siguientes comandos: Con cURL : curl https://git.io/fh9sW -L -o vsim && chmod +x vsim && . ./vsim && rm vsim Con wget : wget -O vsim https://git.io/fh9sW && chmod +x vsim && . ./vsim && rm vsim Y, por \u00faltimo, hacer source a su bash profile source ~/.bashrc Cosas b\u00e1sicas en V-Sim: \u00b6 A continuaci\u00f3n, les vamos a dar una peque\u00f1a gu\u00eda de V-Sim, para m\u00e1s informaci\u00f3n visiten la p\u00e1gina de documentaci\u00f3n en https://www.riscvsim.com . Pueden crear archivos, editarlos y borrarlos desde la pesta\u00f1a \"Editor\". Los programas empiezan en la etiqueta global main , es decir que tienen que definir una etiqueta llamada main y declararla como global. .globl main main: li a0 , 10 ecall # exit Las etiquetas terminan con dos puntos como ven en el ejemplo anterior. Los comentarios comienzan con el simbolo \"#\" o \";\". NO PUEDEN poner m\u00e1s de una instrucci\u00f3n por l\u00ednea. Cuando hayan terminado de editar las instrucciones que conforman su c\u00f3digo, guarden y presionen F3 para preparar la ejecuci\u00f3n. Los programas siempre tienen que terminar con un ecall de exit y esto se logra poniendo un 10 en a0 ( exactamente como el ejemplo anterior ). Esto le indica al programa que tiene que terminar. Las instrucciones ecall son an\u00e1logas a los \"System Calls\" (llamadas al sistema) y nos permiten hacer cosas como imprimir a consola o reservar memoria din\u00e1mica. Ejercicio 1: Familiariz\u00e1ndote con V-Sim \u00b6 Para este ejercicio ustedes van a familiarizarse con V-Sim corriendo un programa sencillo de RISC-V y, luego, contestar\u00e1n unas preguntas. Abran una terminal ( CTRL + T ) y dir\u00edjanse a la carpeta del repositorio que clonaron. Abran el modo GUI de V-Sim ejecutando en la terminal vsim . Desde el editor abran el archivo llamado ex1.s que esta en la carpeta ex1 . En la barra de herramientas de V-Sim, vayan a settings y aseg\u00farense de que Assemble Only Selected Tab est\u00e9 seleccionado con un cheque verde. Presionen F3 . Esto va a preparar el c\u00f3digo para que pueda ser ejecutado y simulado. Si hacen click a la pesta\u00f1a \"Editor\", su simulaci\u00f3n se va a reiniciar. En el simulador, para ejecutar la siguiente instrucci\u00f3n, presionen el bot\u00f3n que dice \"step\". Para regresar un paso atr\u00e1s, presionen el bot\u00f3n que dice \"backstep\". Para correr todo el programa hasta que termine, presionen el bot\u00f3n que dice \"go\". Para volver a empezar el programa nuevamente, presionen el bot\u00f3n que dice \"reset\". Para ver el contenido de los 32 registros en la parte derecha del simulador, hay una pesta\u00f1a que dice RVI . La consola est\u00e1 en la parte de abajo del simulador. Para ver el contenido de la memoria, en el mismo lugar que los registros hay una pesta\u00f1a que dice Memory , pueden navegar a diferentes secciones de la memoria haciendo click derecho encima de la tabla que muestra el estado de la memoria. Preguntas \u00b6 Ahora que ya han corrido su primer programa de RISC-V y que ganaron experiencia con V-Sim pueden contestar las siguientes preguntas en el archivo ex1.txt que se encuentra en la carpeta ex1 . \u00bfQu\u00e9 significan las directivas .data , .word , .text , es decir, para qu\u00e9 las utilizan? Escriban s\u00f3lo una de las siguientes letras para responder. Pista: Piensen acerca de las cuatro secciones de memoria. A) Son como etiquetas sirven para hacer referencia a cosas que est\u00e1n en memoria, con .data apuntamos hacia los datos con .word hacia palabras de 32 bits y con .text hacia texto. B) .data le indica al ensamblador que guarde los siguientes elementos en la secci\u00f3n est\u00e1tica de la memoria, .word que guarde una palabra de 32 bits en memoria en la secci\u00f3n est\u00e1tica de datos y .text que estamos en la secci\u00f3n de texto y entonces deber\u00edamos escribir instrucciones de ensamblador. C) .data es para guardar datos en la secci\u00f3n de datos de la memoria, .word es para guardar palabras de 32 bits en la secci\u00f3n de palabras de la memoria, .text es para guardar texto ascii en la secci\u00f3n de texto de la memoria. D) .data y .word no son directivas de ensamblador, y .text siempre est\u00e1 por defecto y ni se tendr\u00eda que poner. Corran por completo el programa. \u00bfQu\u00e9 n\u00famero da como \"output\"? \u00bfQu\u00e9 representa el n\u00famero que da como output el programa? Escriban s\u00f3lo una de las siguientes letras para responder: A) N\u00famero \u00e1ureo B) Factorial de 9 C) Fibonnaci de 9 D) Factorial de 10 \u00bfEn qu\u00e9 direcci\u00f3n de memoria (en hexadecimal) est\u00e1 almacenado \"n\"? Pista: Miren el contenido de los registros. Sin utilizar la pesta\u00f1a \"Editor\", hagan que el programa calcule el 13\u00ba n\u00famero (tomando en cuenta que el \u00edndice empieza en 0) de la sucesi\u00f3n de Fibonacci, modificando manualmente el valor de un registro. Encontrar\u00e1n \u00fatil de primero correr l\u00ednea por l\u00ednea el c\u00f3digo. Si prefieren ver los valores en decimal, cambien esto haciendo click derecho sobre la tabla de registros y presionando \"Decimal Display Mode\". \u00bfQu\u00e9 registro modificaron? Ejercicio 2: Traduciendo de C a RISC-V \u00b6 Desde V-Sim abran el archivo ex2.s que est\u00e1 en la carpeta ex2 y, desde alg\u00fan editor de texto de su preferencia, abran ex2.c , que est\u00e1 en la misma carpeta. El c\u00f3digo ensamblador que se provee (archivo ex2.s) es una traducci\u00f3n del programa escrito en C (archivo ex2.c) pero en RISC-V. Su tarea es encontrar/explicar los siguientes componentes de este archivo escrito en lenguaje ensamblador en el archivo de texto llamado ex2.txt , que tambi\u00e9n est\u00e1 en la misma carpeta. Preguntas \u00b6 \u00bfCu\u00e1l es el registro que representa la variable k ? \u00bfCu\u00e1les son los registros que act\u00faan como punteros a los arreglos source y dest (separados por coma)? \u00bfDe qu\u00e9 n\u00famero de l\u00ednea a que n\u00famero l\u00ednea se encuentra el loop (separado por coma)? \u00bfEn qu\u00e9 n\u00famero de l\u00ednea se copia el contenido de source a dest ?, es decir \u00bfd\u00f3nde se puede observar dest[k] = source[k] ?. \u00bfC\u00f3mo son manipulados los punteros en el c\u00f3digo? Escriban s\u00f3lo una de las siguientes letras para responder: A) En cada iteraci\u00f3n se le suma k a cada puntero, que es el equivalente en C a arreglo[k] . B) En cada iteraci\u00f3n se le suma k * 4 a cada puntero, que es equivalente en C a arreglo[k] . C) En cada iteraci\u00f3n se le hace corrimiento l\u00f3gico a la derecha a cada puntero, que es equivalente en C a arreglo[k] . D) En cada iteraci\u00f3n se le suma +1 a cada puntero, que es equivalente en C a arreglo[k] . Ejercicio 3: Factorial. \u00b6 En este ejercicio, tienen que implementar la funci\u00f3n de factorial en RISC-V que toma un s\u00f3lo par\u00e1metro entero $n$ y retorna $n!$. Pueden encontrar un esqueleto de esta funci\u00f3n en el archivo factorial.s , que se encuentra en la carpeta ex3 del repositorio que clonaron. Ustedes s\u00f3lo necesitan agregar las instrucciones bajo la etiqueta factorial , y el argumento que se pasa a la funci\u00f3n va en el registro a0 . Pueden resolver este problema ya sea de forma recursiva o iterativa. Aseg\u00farense de que su funci\u00f3n retorne de forma apropidada lo siguiente $3! = 6$, $7! = 5040$ y $8! = 40320$. Ejercicio 4: List Map \u00b6 Para este ejercicio van a utilizar el archivo list_map.s que se encuentra en la carpeta ex4 . En este ejercicio, van a completar una funci\u00f3n de \"map\" con listas encadenadas en RISC-V. La funci\u00f3n se simplificar\u00e1 en mutar la lista en cuesti\u00f3n, es decir que tomar\u00e1 una lista encadenada como entrada y va a retornar la lista con los valores modificados. Nuestro procedimiento de \"map\" toma dos par\u00e1metros, el primero ser\u00e1 la direcci\u00f3n del nodo \"head\" de una lista encadenada, cuyos valores son enteros de 32 bits. Entonces, en C, la estructura se define como: struct node { int value ; struct node * next ; }; El segundo par\u00e1metro ser\u00e1 la direcci\u00f3n de una funci\u00f3n que toma un entero como argumento y devuelve un entero. Usaremos la instrucci\u00f3n \"jalr\" de RISC-V para llamar a esta funci\u00f3n con los valores de cada nodo de la lista. Nuestra funci\u00f3n \"map\" ir\u00e1 recorriendo la lista recursivamente, aplicando la funci\u00f3n a cada valor de la lista y almacenando el valor devuelto al nodo correspondiente. En C, la funci\u00f3n se ver\u00eda algo como esta: void map ( struct node * head , int ( * f )( int )) { if ( ! head ) { return ; } head -> value = f ( head -> value ); map ( head -> next , f ); } Si no hab\u00edan visto lo de int (*f)(int) antes, no se preocupen demasiado. Significa b\u00e1sicamente que f es un puntero a una funci\u00f3n de C, f entonces puede ser utilizado exactamente como cualquier otra funci\u00f3n. Les ser\u00e1 \u00fatil acudir al green card de RISC-V que pueden encontrar aqu\u00ed para completar este ejercicio. Hay exactamente 9 espacios (8 en map y 1 en main ), en el c\u00f3digo que se provee, donde dice YOUR_INSTRUCTION_HERE . Reemplacen esos espacios con las instrucciones de su implementaci\u00f3n de map, y escriban una simple llamada a map con square como argumento de la funci\u00f3n. Hay comentarios en el c\u00f3digo que explican qu\u00e9 deber\u00eda hacer, o cumplir, cada instrucci\u00f3n. Cuando hayan rellenado los espacios con las instrucciones correctas, pueden correr el c\u00f3digo pulsando en F3 y luego el bot\u00f3n Go , al hacer esto, deber\u00eda de darles como output lo siguiente: 9 8 7 6 5 4 3 2 1 0 81 64 49 36 25 16 9 4 1 0 La primera l\u00ednea es la lista original, y la segunda es la lista modificada despu\u00e9s de que se aplic\u00f3 la funci\u00f3n \"map\". Calificaci\u00f3n \u00b6 Cuando hayan terminado su laboratorio, o crean que est\u00e1n listos para obtener su nota, pueden subir su laboratorio al autograder utilizando: ./submit <TOKEN> NOTA : Tienen que reemplazar <TOKEN> por el token que les da la siguiente p\u00e1gina Luego, cuando haya sido calificado, pueden ver su resultado en https://dashboard.cc-3.site/ .","title":"3: RISC-V"},{"location":"labs/lab03/#lab-3-risc-v","text":"","title":"Lab 3 - RISC-V"},{"location":"labs/lab03/#objetivos","text":"Practicar, corriendo y debuggeando c\u00f3digo ensamblador RISC-V. Escribir funciones en RISC-V con el procedimiento correcto de llamadas a funciones. Tener una idea de como traducir c\u00f3digo en C a RISC-V.","title":"Objetivos"},{"location":"labs/lab03/#lecturas","text":"P&H: 2.12","title":"Lecturas"},{"location":"labs/lab03/#preparacion","text":"Para comenzar con el laboratorio primero tienen que tener todos los archivos base, estos se encuentran aqu\u00ed . Recuerden que deben aceptar la asignaci\u00f3n de GitHub Classroom y se les crear\u00e1 autom\u00e1ticamente un repositorio con una extensi\u00f3n que termina con su usuario de GitHub. Cuando ya se haya creado el repositorio, pueden ejecutar los siguientes comandos abriendo una terminal ( CTRL + T ): git clone <link del repositorio> NOTA : Tienen que reemplazar <link del repositorio> con el link del repositorio que se cre\u00f3.","title":"Preparaci\u00f3n"},{"location":"labs/lab03/#introduccion-a-lenguaje-ensamblador-risc-v","text":"Los siguientes ejercicios utilizan un ensamblador y simulador de RISC-V, desarrollado por nuestro auxiliar Andr\u00e9s Castellanos . El simulador se llama V-Sim y es un proyecto open source inspirado, inicialmente, en el lengendario SPIM y, posteriormente, en MARS y VENUS para la versi\u00f3n gr\u00e1fica. Para instalarlo en su computadora s\u00f3lo necesitan ejecutar en una terminal uno de los siguientes comandos: Con cURL : curl https://git.io/fh9sW -L -o vsim && chmod +x vsim && . ./vsim && rm vsim Con wget : wget -O vsim https://git.io/fh9sW && chmod +x vsim && . ./vsim && rm vsim Y, por \u00faltimo, hacer source a su bash profile source ~/.bashrc","title":"Introducci\u00f3n a Lenguaje Ensamblador RISC-V"},{"location":"labs/lab03/#cosas-basicas-en-v-sim","text":"A continuaci\u00f3n, les vamos a dar una peque\u00f1a gu\u00eda de V-Sim, para m\u00e1s informaci\u00f3n visiten la p\u00e1gina de documentaci\u00f3n en https://www.riscvsim.com . Pueden crear archivos, editarlos y borrarlos desde la pesta\u00f1a \"Editor\". Los programas empiezan en la etiqueta global main , es decir que tienen que definir una etiqueta llamada main y declararla como global. .globl main main: li a0 , 10 ecall # exit Las etiquetas terminan con dos puntos como ven en el ejemplo anterior. Los comentarios comienzan con el simbolo \"#\" o \";\". NO PUEDEN poner m\u00e1s de una instrucci\u00f3n por l\u00ednea. Cuando hayan terminado de editar las instrucciones que conforman su c\u00f3digo, guarden y presionen F3 para preparar la ejecuci\u00f3n. Los programas siempre tienen que terminar con un ecall de exit y esto se logra poniendo un 10 en a0 ( exactamente como el ejemplo anterior ). Esto le indica al programa que tiene que terminar. Las instrucciones ecall son an\u00e1logas a los \"System Calls\" (llamadas al sistema) y nos permiten hacer cosas como imprimir a consola o reservar memoria din\u00e1mica.","title":"Cosas b\u00e1sicas en V-Sim:"},{"location":"labs/lab03/#ejercicio-1-familiarizandote-con-v-sim","text":"Para este ejercicio ustedes van a familiarizarse con V-Sim corriendo un programa sencillo de RISC-V y, luego, contestar\u00e1n unas preguntas. Abran una terminal ( CTRL + T ) y dir\u00edjanse a la carpeta del repositorio que clonaron. Abran el modo GUI de V-Sim ejecutando en la terminal vsim . Desde el editor abran el archivo llamado ex1.s que esta en la carpeta ex1 . En la barra de herramientas de V-Sim, vayan a settings y aseg\u00farense de que Assemble Only Selected Tab est\u00e9 seleccionado con un cheque verde. Presionen F3 . Esto va a preparar el c\u00f3digo para que pueda ser ejecutado y simulado. Si hacen click a la pesta\u00f1a \"Editor\", su simulaci\u00f3n se va a reiniciar. En el simulador, para ejecutar la siguiente instrucci\u00f3n, presionen el bot\u00f3n que dice \"step\". Para regresar un paso atr\u00e1s, presionen el bot\u00f3n que dice \"backstep\". Para correr todo el programa hasta que termine, presionen el bot\u00f3n que dice \"go\". Para volver a empezar el programa nuevamente, presionen el bot\u00f3n que dice \"reset\". Para ver el contenido de los 32 registros en la parte derecha del simulador, hay una pesta\u00f1a que dice RVI . La consola est\u00e1 en la parte de abajo del simulador. Para ver el contenido de la memoria, en el mismo lugar que los registros hay una pesta\u00f1a que dice Memory , pueden navegar a diferentes secciones de la memoria haciendo click derecho encima de la tabla que muestra el estado de la memoria.","title":"Ejercicio 1: Familiariz\u00e1ndote con V-Sim"},{"location":"labs/lab03/#preguntas","text":"Ahora que ya han corrido su primer programa de RISC-V y que ganaron experiencia con V-Sim pueden contestar las siguientes preguntas en el archivo ex1.txt que se encuentra en la carpeta ex1 . \u00bfQu\u00e9 significan las directivas .data , .word , .text , es decir, para qu\u00e9 las utilizan? Escriban s\u00f3lo una de las siguientes letras para responder. Pista: Piensen acerca de las cuatro secciones de memoria. A) Son como etiquetas sirven para hacer referencia a cosas que est\u00e1n en memoria, con .data apuntamos hacia los datos con .word hacia palabras de 32 bits y con .text hacia texto. B) .data le indica al ensamblador que guarde los siguientes elementos en la secci\u00f3n est\u00e1tica de la memoria, .word que guarde una palabra de 32 bits en memoria en la secci\u00f3n est\u00e1tica de datos y .text que estamos en la secci\u00f3n de texto y entonces deber\u00edamos escribir instrucciones de ensamblador. C) .data es para guardar datos en la secci\u00f3n de datos de la memoria, .word es para guardar palabras de 32 bits en la secci\u00f3n de palabras de la memoria, .text es para guardar texto ascii en la secci\u00f3n de texto de la memoria. D) .data y .word no son directivas de ensamblador, y .text siempre est\u00e1 por defecto y ni se tendr\u00eda que poner. Corran por completo el programa. \u00bfQu\u00e9 n\u00famero da como \"output\"? \u00bfQu\u00e9 representa el n\u00famero que da como output el programa? Escriban s\u00f3lo una de las siguientes letras para responder: A) N\u00famero \u00e1ureo B) Factorial de 9 C) Fibonnaci de 9 D) Factorial de 10 \u00bfEn qu\u00e9 direcci\u00f3n de memoria (en hexadecimal) est\u00e1 almacenado \"n\"? Pista: Miren el contenido de los registros. Sin utilizar la pesta\u00f1a \"Editor\", hagan que el programa calcule el 13\u00ba n\u00famero (tomando en cuenta que el \u00edndice empieza en 0) de la sucesi\u00f3n de Fibonacci, modificando manualmente el valor de un registro. Encontrar\u00e1n \u00fatil de primero correr l\u00ednea por l\u00ednea el c\u00f3digo. Si prefieren ver los valores en decimal, cambien esto haciendo click derecho sobre la tabla de registros y presionando \"Decimal Display Mode\". \u00bfQu\u00e9 registro modificaron?","title":"Preguntas"},{"location":"labs/lab03/#ejercicio-2-traduciendo-de-c-a-risc-v","text":"Desde V-Sim abran el archivo ex2.s que est\u00e1 en la carpeta ex2 y, desde alg\u00fan editor de texto de su preferencia, abran ex2.c , que est\u00e1 en la misma carpeta. El c\u00f3digo ensamblador que se provee (archivo ex2.s) es una traducci\u00f3n del programa escrito en C (archivo ex2.c) pero en RISC-V. Su tarea es encontrar/explicar los siguientes componentes de este archivo escrito en lenguaje ensamblador en el archivo de texto llamado ex2.txt , que tambi\u00e9n est\u00e1 en la misma carpeta.","title":"Ejercicio 2: Traduciendo de C a RISC-V"},{"location":"labs/lab03/#preguntas_1","text":"\u00bfCu\u00e1l es el registro que representa la variable k ? \u00bfCu\u00e1les son los registros que act\u00faan como punteros a los arreglos source y dest (separados por coma)? \u00bfDe qu\u00e9 n\u00famero de l\u00ednea a que n\u00famero l\u00ednea se encuentra el loop (separado por coma)? \u00bfEn qu\u00e9 n\u00famero de l\u00ednea se copia el contenido de source a dest ?, es decir \u00bfd\u00f3nde se puede observar dest[k] = source[k] ?. \u00bfC\u00f3mo son manipulados los punteros en el c\u00f3digo? Escriban s\u00f3lo una de las siguientes letras para responder: A) En cada iteraci\u00f3n se le suma k a cada puntero, que es el equivalente en C a arreglo[k] . B) En cada iteraci\u00f3n se le suma k * 4 a cada puntero, que es equivalente en C a arreglo[k] . C) En cada iteraci\u00f3n se le hace corrimiento l\u00f3gico a la derecha a cada puntero, que es equivalente en C a arreglo[k] . D) En cada iteraci\u00f3n se le suma +1 a cada puntero, que es equivalente en C a arreglo[k] .","title":"Preguntas"},{"location":"labs/lab03/#ejercicio-3-factorial","text":"En este ejercicio, tienen que implementar la funci\u00f3n de factorial en RISC-V que toma un s\u00f3lo par\u00e1metro entero $n$ y retorna $n!$. Pueden encontrar un esqueleto de esta funci\u00f3n en el archivo factorial.s , que se encuentra en la carpeta ex3 del repositorio que clonaron. Ustedes s\u00f3lo necesitan agregar las instrucciones bajo la etiqueta factorial , y el argumento que se pasa a la funci\u00f3n va en el registro a0 . Pueden resolver este problema ya sea de forma recursiva o iterativa. Aseg\u00farense de que su funci\u00f3n retorne de forma apropidada lo siguiente $3! = 6$, $7! = 5040$ y $8! = 40320$.","title":"Ejercicio 3: Factorial."},{"location":"labs/lab03/#ejercicio-4-list-map","text":"Para este ejercicio van a utilizar el archivo list_map.s que se encuentra en la carpeta ex4 . En este ejercicio, van a completar una funci\u00f3n de \"map\" con listas encadenadas en RISC-V. La funci\u00f3n se simplificar\u00e1 en mutar la lista en cuesti\u00f3n, es decir que tomar\u00e1 una lista encadenada como entrada y va a retornar la lista con los valores modificados. Nuestro procedimiento de \"map\" toma dos par\u00e1metros, el primero ser\u00e1 la direcci\u00f3n del nodo \"head\" de una lista encadenada, cuyos valores son enteros de 32 bits. Entonces, en C, la estructura se define como: struct node { int value ; struct node * next ; }; El segundo par\u00e1metro ser\u00e1 la direcci\u00f3n de una funci\u00f3n que toma un entero como argumento y devuelve un entero. Usaremos la instrucci\u00f3n \"jalr\" de RISC-V para llamar a esta funci\u00f3n con los valores de cada nodo de la lista. Nuestra funci\u00f3n \"map\" ir\u00e1 recorriendo la lista recursivamente, aplicando la funci\u00f3n a cada valor de la lista y almacenando el valor devuelto al nodo correspondiente. En C, la funci\u00f3n se ver\u00eda algo como esta: void map ( struct node * head , int ( * f )( int )) { if ( ! head ) { return ; } head -> value = f ( head -> value ); map ( head -> next , f ); } Si no hab\u00edan visto lo de int (*f)(int) antes, no se preocupen demasiado. Significa b\u00e1sicamente que f es un puntero a una funci\u00f3n de C, f entonces puede ser utilizado exactamente como cualquier otra funci\u00f3n. Les ser\u00e1 \u00fatil acudir al green card de RISC-V que pueden encontrar aqu\u00ed para completar este ejercicio. Hay exactamente 9 espacios (8 en map y 1 en main ), en el c\u00f3digo que se provee, donde dice YOUR_INSTRUCTION_HERE . Reemplacen esos espacios con las instrucciones de su implementaci\u00f3n de map, y escriban una simple llamada a map con square como argumento de la funci\u00f3n. Hay comentarios en el c\u00f3digo que explican qu\u00e9 deber\u00eda hacer, o cumplir, cada instrucci\u00f3n. Cuando hayan rellenado los espacios con las instrucciones correctas, pueden correr el c\u00f3digo pulsando en F3 y luego el bot\u00f3n Go , al hacer esto, deber\u00eda de darles como output lo siguiente: 9 8 7 6 5 4 3 2 1 0 81 64 49 36 25 16 9 4 1 0 La primera l\u00ednea es la lista original, y la segunda es la lista modificada despu\u00e9s de que se aplic\u00f3 la funci\u00f3n \"map\".","title":"Ejercicio 4:  List Map"},{"location":"labs/lab03/#calificacion","text":"Cuando hayan terminado su laboratorio, o crean que est\u00e1n listos para obtener su nota, pueden subir su laboratorio al autograder utilizando: ./submit <TOKEN> NOTA : Tienen que reemplazar <TOKEN> por el token que les da la siguiente p\u00e1gina Luego, cuando haya sido calificado, pueden ver su resultado en https://dashboard.cc-3.site/ .","title":"Calificaci\u00f3n"},{"location":"labs/lab04/","text":"Lab 4 - RISC-V \u00b6 Objetivos \u00b6 Divertirse con RISC-V Encontrar los errores de Ali Hacer algo imposible Pensar en la idea de hacer lo imposible Lecturas \u00b6 P&H: 2.12 Preparaci\u00f3n \u00b6 Para comenzar con el laboratorio primero tienen que tener todos los archivos base, estos se encuentran aqu\u00ed . Recuerden que deben aceptar la asignaci\u00f3n de GitHub Classroom y se les crear\u00e1 autom\u00e1ticamente un repositorio con una extensi\u00f3n que termina con su usuario de GitHub. Cuando ya se haya creado el repositorio, pueden ejecutar los siguientes comandos abriendo una terminal ( CTRL + T ): git clone <link del repositorio> NOTA : Tienen que reemplazar <link del repositorio> con el link del repositorio que se cre\u00f3. Ejercicio 1: Depurando megalistmanips.s \u00b6 Hace mucho tiempo, su catedr\u00e1tico Ali era un principiante en RISC-V, y escribi\u00f3 su soluci\u00f3n a un lab en este archivo: megalistmanips.s . Ustedes, ahora que ya son expertos en RISC-V, deben arreglar los bugs que cometi\u00f3 Ali. El objetivo principal de este ejercicio es que encuentren los errores en la funci\u00f3n map en megalistmanips.s . Antes de hacer eso, familiar\u00edcense con lo que la funci\u00f3n trata de hacer. En el lab anterior, ten\u00edamos una lista encadenada de enteros, ahora nuestra estructura de datos es una lista encadena cuyo valor en cada nodo es un arreglo de enteros. Recuerden que cuando se trabaja con arreglos en structs, necesitamos almacenar expl\u00edcitamente el tama\u00f1o del array. En c\u00f3digo de C, el struct se ver\u00eda as\u00ed: struct node { int * arr ; int size ; struct node * next ; }; Aqu\u00ed tambi\u00e9n est\u00e1 lo que la nueva funci\u00f3n map hace: atraviesa la lista encadenada y para cada elemento del arreglo de cada nodo, aplica la funci\u00f3n y vuelve a guardarlo en el array. En C, esto se mirar\u00eda de la siguiente manera: void map ( struct node * head , int ( * f )( int )) { if ( ! head ) { return ; } for ( int i = 0 ; i < head -> size ; i ++ ) { head -> arr [ i ] = f ( head -> arr [ i ]); } map ( head -> next , f ); } Lean todos los comentarios en la funci\u00f3n map en megalistmanips.s (antes de que retorne con jr ra ), y aseg\u00farense de que las l\u00edneas hagan lo que el comentario dice. Algunas pistas: \u00bfPor qu\u00e9 necesitamos guardar cosas en el stack antes de llamar a jal ? \u00bfCu\u00e1l es la diferencia entre add t0, s0, x0 y lw t0, 0(s0) ? Presten atenci\u00f3n a los tipos de los atributos en el struct . \u00a1Gracias por hacer el ejercicio! Estamos seguros de que Ali se estar\u00e1 preguntando d\u00f3nde estaban para ayudarlo cuando no entend\u00eda RISC-V hace un tiempo atr\u00e1s. Ejercicio 2: Escriban una funci\u00f3n sin utilizar branches \u00b6 Consideren la funci\u00f3n $f$ de valor discreto definida en el set de enteros ${-3, -2, -1, 0, 1, 2, 3}$. Esta es la definici\u00f3n de la funci\u00f3n: $\\begin{align} &f(-3) = 6\\\\ &f(-2) = 61\\\\ &f(-1) = 17\\\\ &f(0) = -38\\\\ &f(1) = 19\\\\ &f(2) = 42\\\\ &f(3) = 5 \\end{align}$ No les vamos a mentir, es una funci\u00f3n muy tonta. Sin embargo, su tarea es implementarla en RISC-V, con la condici\u00f3n de que NO pueden utilizar las instrucciones de branch por ning\u00fan motivo. Por suerte alguna persona ha dejado por accidente un array de enteros en la secci\u00f3n .data de discrete_fn.s . \u00bfC\u00f3mo pueden utilizarlo para tener ventaja sobre eso y completar esta tarea que aparenta ser imposible? Calificaci\u00f3n \u00b6 Cuando hayan terminado su laboratorio, o crean que est\u00e1n listos para obtener su nota, pueden subir su laboratorio al autograder utilizando: ./submit <TOKEN> NOTA : Tienen que reemplazar <TOKEN> por el token que les da la siguiente p\u00e1gina Luego, cuando haya sido calificado, pueden ver su resultado en https://dashboard.cc-3.site/ .","title":"4: RISC-V"},{"location":"labs/lab04/#lab-4-risc-v","text":"","title":"Lab 4 - RISC-V"},{"location":"labs/lab04/#objetivos","text":"Divertirse con RISC-V Encontrar los errores de Ali Hacer algo imposible Pensar en la idea de hacer lo imposible","title":"Objetivos"},{"location":"labs/lab04/#lecturas","text":"P&H: 2.12","title":"Lecturas"},{"location":"labs/lab04/#preparacion","text":"Para comenzar con el laboratorio primero tienen que tener todos los archivos base, estos se encuentran aqu\u00ed . Recuerden que deben aceptar la asignaci\u00f3n de GitHub Classroom y se les crear\u00e1 autom\u00e1ticamente un repositorio con una extensi\u00f3n que termina con su usuario de GitHub. Cuando ya se haya creado el repositorio, pueden ejecutar los siguientes comandos abriendo una terminal ( CTRL + T ): git clone <link del repositorio> NOTA : Tienen que reemplazar <link del repositorio> con el link del repositorio que se cre\u00f3.","title":"Preparaci\u00f3n"},{"location":"labs/lab04/#ejercicio-1-depurando-megalistmanipss","text":"Hace mucho tiempo, su catedr\u00e1tico Ali era un principiante en RISC-V, y escribi\u00f3 su soluci\u00f3n a un lab en este archivo: megalistmanips.s . Ustedes, ahora que ya son expertos en RISC-V, deben arreglar los bugs que cometi\u00f3 Ali. El objetivo principal de este ejercicio es que encuentren los errores en la funci\u00f3n map en megalistmanips.s . Antes de hacer eso, familiar\u00edcense con lo que la funci\u00f3n trata de hacer. En el lab anterior, ten\u00edamos una lista encadenada de enteros, ahora nuestra estructura de datos es una lista encadena cuyo valor en cada nodo es un arreglo de enteros. Recuerden que cuando se trabaja con arreglos en structs, necesitamos almacenar expl\u00edcitamente el tama\u00f1o del array. En c\u00f3digo de C, el struct se ver\u00eda as\u00ed: struct node { int * arr ; int size ; struct node * next ; }; Aqu\u00ed tambi\u00e9n est\u00e1 lo que la nueva funci\u00f3n map hace: atraviesa la lista encadenada y para cada elemento del arreglo de cada nodo, aplica la funci\u00f3n y vuelve a guardarlo en el array. En C, esto se mirar\u00eda de la siguiente manera: void map ( struct node * head , int ( * f )( int )) { if ( ! head ) { return ; } for ( int i = 0 ; i < head -> size ; i ++ ) { head -> arr [ i ] = f ( head -> arr [ i ]); } map ( head -> next , f ); } Lean todos los comentarios en la funci\u00f3n map en megalistmanips.s (antes de que retorne con jr ra ), y aseg\u00farense de que las l\u00edneas hagan lo que el comentario dice. Algunas pistas: \u00bfPor qu\u00e9 necesitamos guardar cosas en el stack antes de llamar a jal ? \u00bfCu\u00e1l es la diferencia entre add t0, s0, x0 y lw t0, 0(s0) ? Presten atenci\u00f3n a los tipos de los atributos en el struct . \u00a1Gracias por hacer el ejercicio! Estamos seguros de que Ali se estar\u00e1 preguntando d\u00f3nde estaban para ayudarlo cuando no entend\u00eda RISC-V hace un tiempo atr\u00e1s.","title":"Ejercicio 1: Depurando megalistmanips.s"},{"location":"labs/lab04/#ejercicio-2-escriban-una-funcion-sin-utilizar-branches","text":"Consideren la funci\u00f3n $f$ de valor discreto definida en el set de enteros ${-3, -2, -1, 0, 1, 2, 3}$. Esta es la definici\u00f3n de la funci\u00f3n: $\\begin{align} &f(-3) = 6\\\\ &f(-2) = 61\\\\ &f(-1) = 17\\\\ &f(0) = -38\\\\ &f(1) = 19\\\\ &f(2) = 42\\\\ &f(3) = 5 \\end{align}$ No les vamos a mentir, es una funci\u00f3n muy tonta. Sin embargo, su tarea es implementarla en RISC-V, con la condici\u00f3n de que NO pueden utilizar las instrucciones de branch por ning\u00fan motivo. Por suerte alguna persona ha dejado por accidente un array de enteros en la secci\u00f3n .data de discrete_fn.s . \u00bfC\u00f3mo pueden utilizarlo para tener ventaja sobre eso y completar esta tarea que aparenta ser imposible?","title":"Ejercicio 2: Escriban una funci\u00f3n sin utilizar branches"},{"location":"labs/lab04/#calificacion","text":"Cuando hayan terminado su laboratorio, o crean que est\u00e1n listos para obtener su nota, pueden subir su laboratorio al autograder utilizando: ./submit <TOKEN> NOTA : Tienen que reemplazar <TOKEN> por el token que les da la siguiente p\u00e1gina Luego, cuando haya sido calificado, pueden ver su resultado en https://dashboard.cc-3.site/ .","title":"Calificaci\u00f3n"},{"location":"notes/00_Numbers-Representation/","text":"Representaci\u00f3n Num\u00e9rica \u00b6 Como las computadoras representan n\u00fameros Los humanos pensamos en base 10, esto se debe a que usamos los 10 dedos de las manos para contar. Sin embargo los n\u00fameros pueden ser representado en cualquier base. Por ejemplo 123 (en base 10) se representa como 0b 1111011 (Notar el 0b al inicio) en base 2. Los n\u00fameros se guardan en la memoria de la computadora (ram, cache, registros, etc.) como una serie de se\u00f1ales electr\u00f3nicas (altas y bajas) por lo que se consideran n\u00fameros en base 2. Conversi\u00f3n de binario a decimal \u00b6 Para convertir un n\u00famero binario a decimal multiplicamos cada bit, empezando por el bit menos significativo, por potencias de 2. Por convenci\u00f3n consideraremos el bit menos significativo como el bit m\u00e1s a la derecha del n\u00famero binario (as\u00ed como el d\u00edgito de menor valor es el que eta m\u00e1s a la derecha en un numero decimal). Ejemplo \u00b6 Representar el n\u00famero 0b10011011 en base 10. Asuma que se encuentra en notaci\u00f3n sin signo. $$1 {\\color{red}\\times 2^7} + 0 {\\color{red}\\times 2^6} + 0 {\\color{red}\\times 2^5} + 1 {\\color{red}\\times 2^4} + 1 {\\color{red}\\times 2^3} +0 {\\color{red}\\times 2^2} + 1{\\color{red}\\times 2^1} + 1 {\\color{red}\\times 2^0}$$ $$=128 + 0 +0+16+8+0+2+1=155$$ Entonces 0b10011011 = 155 Conversi\u00f3n de decimal a binario \u00b6 Para hacer la conversi\u00f3n de decimal a binario, hay que dividir el n\u00famero decimal entre dos y anotar en una columna a la derecha el resto (un 0 si el resultado de la divisi\u00f3n es par y un 1 si es impar). Ejemplo \u00b6 Representar en numero 109 en base binaria, en su notaci\u00f3n sin signo. N N/2 N%2 109 54 1 54 27 0 27 13 1 13 6 1 6 3 0 3 1 1 1 0 1 Noten que terminamos la division cuando N/2 es 0. El n\u00famero binario resultante ser\u00edan entonces todos los residuos N%2 siendo el bit menos significativo el de la primera fila, y el bit m\u00e1s significativo el de la ultima fila: 0b1101101 Conversi\u00f3n de binario a hexadecimal \u00b6 El sistema hexadecimal tiene como base 16. Para suplir los digitos que faltan, usamos las letras A, B, C, D, E y F para representar los valores 10, 11,12,13, 14 y 15 respectivamente. Para convertir un n\u00famero binario a hexadecimal puede convertir el n\u00famero a base 10 y luego a base 16 o crear grupos de 4 bits (empezando por el bit menos significativo) y convertirlos a hexadecimal directamente. Ejemplo \u00b6 Representar el n\u00famero 0b10011011 en hexadecimal. Agrupado tenemos $0\\text{b}{\\color{red}1001}\\, {\\color{blue}1011}$. 1011 corresponde a 11 en base 10, es decir a 'A' en hexadecimal. 1001 corresponde a 9 en base 10, es decir a '9 en hexadecimal. Entonces 0b10011011 = 0x9A. Representar el n\u00famero 0b11101101101101 en hexadecimal. Agrupado tenemos $0\\text{b}{\\color{red}11}{1011}\\, {\\color{blue}0110} \\, {\\color{green}1101}$. 1101 corresponde a D en hexadecimal. 0110 corresponde a 6 en hexadecimal. 1011 corresponde a B en hexadecimal. 0011 corresponde a 3 en hexadecimal (notar que se le agreg\u00f3 dos ceros). Entonces 0b11101101101101 = 0x3B6D. - Para convertir un n\u00famero decimal a hexadecimal seguimos un procedimiento similar al empleado para convertir un n\u00famero decimal a binario, excepto que el dividendo debe cambiarse por 16. Representaci\u00f3n de n\u00fameros con signo \u00b6 Hasta el momento, solo se han tratado n\u00fameros binarios que representan n\u00fameros enteros positivos. Pero tambien necesitamos una forma de representar en binario n\u00fameros como el -6, -100, etc. 1. Signo Magnitud \u00b6 Cuando representamos n\u00fameros decimales negativos, se le antepone el s\u00edmbolo - para indicar que el n\u00famero es negativo. Es posible intentar lo mismo en binario, pero en vez de usar ese s\u00edmbolo, usar un 0 o un 1 para diferenciar entre numeros positivos y negativos. Usaremos el bit m\u00e1s significativo para especificar el signo del n\u00famero Un 1 denotar\u00e1 que el n\u00famero es negativo y un 0 que el n\u00famero es positivo. Ejemplo: \u00b6 El n\u00famero 0b11110101 = -117 Porque el 0b1110101 = 117 y como el bit m\u00e1s significativo es 1, el n\u00famero es negativo. El n\u00famero 0b01110101 = 117. El n\u00famero 0b10000001 = -1 El n\u00famero 0b00000001 = 1 Hay varias cosas que deben notarse con respecto de esta representaci\u00f3n. Estas son las m\u00e1s importantes: La cantidad de n\u00fameros que se pueden representar con la misma cantidad de bits disminuye. En los ejemplos anteriores se utilizan 8 bits, pero como el bit m\u00e1s significativo es de signo, el n\u00famero positivo m\u00e1s grande que podemos representar el $2^7-1=127$ en comparaci\u00f3n con $2^8 -1=255$ si no se usara signo. Hay dos \"0\". \u00bfC\u00f3mo se interpreta 0b10000000? Sumar y restar requiere m\u00e1s trabajo; m\u00e1s adelante ver\u00e1n que se necesitan circuitos m\u00e1s complejos para realizar estas operaciones. 2. Complemento a uno \u00b6 Para representar un n\u00famero en complemento a uno se invierten todos los bits de la representaci\u00f3n binaria del n\u00famero (se intercambia 1 por 0 y viceversa). Ejemplo \u00b6 Representar el n\u00famero -101 en complemento a uno. El n\u00famero 101 = 0b01100101 invirtiendo todos los bits obtenemos. -101 = 0b10011010. Complemento a uno facilita m\u00e1s las operaciones matem\u00e1ticas, pero tenemos ciertos problemas a\u00fan: - Existen dos ceros todavia: 0b00000000 y 0b11111111 - Las operaciones matem\u00e1ticas a\u00fan cuestan un poco mas. Por ejemplo, si sumamos 2 y -2 usando 4 bits: 0b0010 + 0b1101 = 0b1111 que es uno de los ceros, pero a\u00fan no es el la respuesta que deberiamos obtener. 3. Complemento a dos \u00b6 Para representar un n\u00famero en complemento a dos se le suma uno al complemento a uno del numero. Ejemplo \u00b6 Representar el n\u00famero -101 en complemento a dos. 101= 0b01100101 que en complemento a uno es 0b10011010, luego, es necesario sumare 1 a numero anterior: 0b10011010 +1 = 0b10011001 Con complemento a dos: - Eliminamos el segundo cero - Simplificamos las sumas y restas de gran manera: a+b siempre utiliza el mismo algoritmo, independientemente de si a y b son positivos o negativos. a-b es lo mismo que sumar a con el complemento a 2 de b Extensi\u00f3n de Signo \u00b6 \u00bfQu\u00e9 pasa si quiero representar un n\u00famero con 'm\u00e1s' bits? - Es de esperar que se preserve el valor del n\u00famero y el signo - En complemento a dos se 'rellenan' los 'espacios' faltantes con el bit de signo. Ejemplo \u00b6 Representar el n\u00famero 0b1111110001 (-15 en decimal) utilizando diecis\u00e9is bits. $-15 = \\text{0b}{\\color{red}111111}1111110001$ Los n\u00fameros escritos en color rojo se copiaron para extender el signo. - Tomar en cuenta que 1 word = 4 bytes = 32 bits - Corrimientos aritm\u00e9ticos y l\u00f3gicos - Operadores || y && en c","title":"N\u00fameros"},{"location":"notes/00_Numbers-Representation/#representacion-numerica","text":"Como las computadoras representan n\u00fameros Los humanos pensamos en base 10, esto se debe a que usamos los 10 dedos de las manos para contar. Sin embargo los n\u00fameros pueden ser representado en cualquier base. Por ejemplo 123 (en base 10) se representa como 0b 1111011 (Notar el 0b al inicio) en base 2. Los n\u00fameros se guardan en la memoria de la computadora (ram, cache, registros, etc.) como una serie de se\u00f1ales electr\u00f3nicas (altas y bajas) por lo que se consideran n\u00fameros en base 2.","title":"Representaci\u00f3n Num\u00e9rica"},{"location":"notes/00_Numbers-Representation/#conversion-de-binario-a-decimal","text":"Para convertir un n\u00famero binario a decimal multiplicamos cada bit, empezando por el bit menos significativo, por potencias de 2. Por convenci\u00f3n consideraremos el bit menos significativo como el bit m\u00e1s a la derecha del n\u00famero binario (as\u00ed como el d\u00edgito de menor valor es el que eta m\u00e1s a la derecha en un numero decimal).","title":"Conversi\u00f3n de binario a decimal"},{"location":"notes/00_Numbers-Representation/#ejemplo","text":"Representar el n\u00famero 0b10011011 en base 10. Asuma que se encuentra en notaci\u00f3n sin signo. $$1 {\\color{red}\\times 2^7} + 0 {\\color{red}\\times 2^6} + 0 {\\color{red}\\times 2^5} + 1 {\\color{red}\\times 2^4} + 1 {\\color{red}\\times 2^3} +0 {\\color{red}\\times 2^2} + 1{\\color{red}\\times 2^1} + 1 {\\color{red}\\times 2^0}$$ $$=128 + 0 +0+16+8+0+2+1=155$$ Entonces 0b10011011 = 155","title":"Ejemplo"},{"location":"notes/00_Numbers-Representation/#conversion-de-decimal-a-binario","text":"Para hacer la conversi\u00f3n de decimal a binario, hay que dividir el n\u00famero decimal entre dos y anotar en una columna a la derecha el resto (un 0 si el resultado de la divisi\u00f3n es par y un 1 si es impar).","title":"Conversi\u00f3n de decimal a binario"},{"location":"notes/00_Numbers-Representation/#ejemplo_1","text":"Representar en numero 109 en base binaria, en su notaci\u00f3n sin signo. N N/2 N%2 109 54 1 54 27 0 27 13 1 13 6 1 6 3 0 3 1 1 1 0 1 Noten que terminamos la division cuando N/2 es 0. El n\u00famero binario resultante ser\u00edan entonces todos los residuos N%2 siendo el bit menos significativo el de la primera fila, y el bit m\u00e1s significativo el de la ultima fila: 0b1101101","title":"Ejemplo"},{"location":"notes/00_Numbers-Representation/#conversion-de-binario-a-hexadecimal","text":"El sistema hexadecimal tiene como base 16. Para suplir los digitos que faltan, usamos las letras A, B, C, D, E y F para representar los valores 10, 11,12,13, 14 y 15 respectivamente. Para convertir un n\u00famero binario a hexadecimal puede convertir el n\u00famero a base 10 y luego a base 16 o crear grupos de 4 bits (empezando por el bit menos significativo) y convertirlos a hexadecimal directamente.","title":"Conversi\u00f3n de binario a hexadecimal"},{"location":"notes/00_Numbers-Representation/#ejemplo_2","text":"Representar el n\u00famero 0b10011011 en hexadecimal. Agrupado tenemos $0\\text{b}{\\color{red}1001}\\, {\\color{blue}1011}$. 1011 corresponde a 11 en base 10, es decir a 'A' en hexadecimal. 1001 corresponde a 9 en base 10, es decir a '9 en hexadecimal. Entonces 0b10011011 = 0x9A. Representar el n\u00famero 0b11101101101101 en hexadecimal. Agrupado tenemos $0\\text{b}{\\color{red}11}{1011}\\, {\\color{blue}0110} \\, {\\color{green}1101}$. 1101 corresponde a D en hexadecimal. 0110 corresponde a 6 en hexadecimal. 1011 corresponde a B en hexadecimal. 0011 corresponde a 3 en hexadecimal (notar que se le agreg\u00f3 dos ceros). Entonces 0b11101101101101 = 0x3B6D. - Para convertir un n\u00famero decimal a hexadecimal seguimos un procedimiento similar al empleado para convertir un n\u00famero decimal a binario, excepto que el dividendo debe cambiarse por 16.","title":"Ejemplo"},{"location":"notes/00_Numbers-Representation/#representacion-de-numeros-con-signo","text":"Hasta el momento, solo se han tratado n\u00fameros binarios que representan n\u00fameros enteros positivos. Pero tambien necesitamos una forma de representar en binario n\u00fameros como el -6, -100, etc.","title":"Representaci\u00f3n de n\u00fameros con signo"},{"location":"notes/00_Numbers-Representation/#1-signo-magnitud","text":"Cuando representamos n\u00fameros decimales negativos, se le antepone el s\u00edmbolo - para indicar que el n\u00famero es negativo. Es posible intentar lo mismo en binario, pero en vez de usar ese s\u00edmbolo, usar un 0 o un 1 para diferenciar entre numeros positivos y negativos. Usaremos el bit m\u00e1s significativo para especificar el signo del n\u00famero Un 1 denotar\u00e1 que el n\u00famero es negativo y un 0 que el n\u00famero es positivo.","title":"1. Signo Magnitud"},{"location":"notes/00_Numbers-Representation/#ejemplo_3","text":"El n\u00famero 0b11110101 = -117 Porque el 0b1110101 = 117 y como el bit m\u00e1s significativo es 1, el n\u00famero es negativo. El n\u00famero 0b01110101 = 117. El n\u00famero 0b10000001 = -1 El n\u00famero 0b00000001 = 1 Hay varias cosas que deben notarse con respecto de esta representaci\u00f3n. Estas son las m\u00e1s importantes: La cantidad de n\u00fameros que se pueden representar con la misma cantidad de bits disminuye. En los ejemplos anteriores se utilizan 8 bits, pero como el bit m\u00e1s significativo es de signo, el n\u00famero positivo m\u00e1s grande que podemos representar el $2^7-1=127$ en comparaci\u00f3n con $2^8 -1=255$ si no se usara signo. Hay dos \"0\". \u00bfC\u00f3mo se interpreta 0b10000000? Sumar y restar requiere m\u00e1s trabajo; m\u00e1s adelante ver\u00e1n que se necesitan circuitos m\u00e1s complejos para realizar estas operaciones.","title":"Ejemplo:"},{"location":"notes/00_Numbers-Representation/#2-complemento-a-uno","text":"Para representar un n\u00famero en complemento a uno se invierten todos los bits de la representaci\u00f3n binaria del n\u00famero (se intercambia 1 por 0 y viceversa).","title":"2. Complemento a uno"},{"location":"notes/00_Numbers-Representation/#ejemplo_4","text":"Representar el n\u00famero -101 en complemento a uno. El n\u00famero 101 = 0b01100101 invirtiendo todos los bits obtenemos. -101 = 0b10011010. Complemento a uno facilita m\u00e1s las operaciones matem\u00e1ticas, pero tenemos ciertos problemas a\u00fan: - Existen dos ceros todavia: 0b00000000 y 0b11111111 - Las operaciones matem\u00e1ticas a\u00fan cuestan un poco mas. Por ejemplo, si sumamos 2 y -2 usando 4 bits: 0b0010 + 0b1101 = 0b1111 que es uno de los ceros, pero a\u00fan no es el la respuesta que deberiamos obtener.","title":"Ejemplo"},{"location":"notes/00_Numbers-Representation/#3-complemento-a-dos","text":"Para representar un n\u00famero en complemento a dos se le suma uno al complemento a uno del numero.","title":"3. Complemento a dos"},{"location":"notes/00_Numbers-Representation/#ejemplo_5","text":"Representar el n\u00famero -101 en complemento a dos. 101= 0b01100101 que en complemento a uno es 0b10011010, luego, es necesario sumare 1 a numero anterior: 0b10011010 +1 = 0b10011001 Con complemento a dos: - Eliminamos el segundo cero - Simplificamos las sumas y restas de gran manera: a+b siempre utiliza el mismo algoritmo, independientemente de si a y b son positivos o negativos. a-b es lo mismo que sumar a con el complemento a 2 de b","title":"Ejemplo"},{"location":"notes/00_Numbers-Representation/#extension-de-signo","text":"\u00bfQu\u00e9 pasa si quiero representar un n\u00famero con 'm\u00e1s' bits? - Es de esperar que se preserve el valor del n\u00famero y el signo - En complemento a dos se 'rellenan' los 'espacios' faltantes con el bit de signo.","title":"Extensi\u00f3n de Signo"},{"location":"notes/00_Numbers-Representation/#ejemplo_6","text":"Representar el n\u00famero 0b1111110001 (-15 en decimal) utilizando diecis\u00e9is bits. $-15 = \\text{0b}{\\color{red}111111}1111110001$ Los n\u00fameros escritos en color rojo se copiaron para extender el signo. - Tomar en cuenta que 1 word = 4 bytes = 32 bits - Corrimientos aritm\u00e9ticos y l\u00f3gicos - Operadores || y && en c","title":"Ejemplo"},{"location":"notes/01_C/","text":"Introducci\u00f3n a C \u00b6 C es un lenguaje de programaci\u00f3n desarrollado en el a\u00f1o 1972 por Dennis Ritchie. El lenguaje C es un lenguaje estructurado el cual a pesar de ser un lenguaje de \"alto nivel\", da acceso a hacer uso de la memoria, registros, etc. C es un lenguaje compilado; se compila una vez para cada arquitectura y se genera un binario que se puede ejecutar directamente. Para poder compilar y ejecutar un archivo llamado HelloWorld.c, se realiza de la siguiente manera: $ gcc HelloWorld . c // se compila el archivo $ . / a . out // se ejecuta el programa $ Hello World //output del programa, en este caso Notese que el compilador que estamos utilizando se llama gcc . gcc * se encuentra por defecto en la mayoria de sistemas operativos con kernel linux . Cuando nosotros no especificamos un nombre para el archivo de salida, cgg lo nombra, por defecto, a.out**. Si queremos especificar un nombre para el archivo de salida entonces podemos utilizar la bandera -o : $ gcc - o Hello HelloWorld . c // se compila el archivo $ . / Hello // se ejecuta el programa $ Hello World //output del programa, en este caso Comentarios en c \u00b6 // para realizar comentarios de una l\u00ednea /* TODO LO QUE ESTE DENTRO DE ESTA PARTE ES UN COMENTARIO */ ``` ~ ## Tipos de declaraci\u00f3n Las variables deben ser declaradas antes de usarse y el tipo de la variable no puede ser cambiado . En C , el tama\u00f1o de la variable depende de la arquitectura en la cual se este trabajando ( x_86 , x_86_84 , ARM , RISC - V , etc .). Algo muy importante que diferencia lenguajes como Java de C , es que en C , si no se inicializa el valor de la variable , la podemos utilizar sin problemas , pero contendr\u00e1 informaci\u00f3n \"basura\" , es decir , los datos que estaban ubicados previamente en la direcci\u00f3n de memoria en donde la variable fue guardada . ## Declaraci\u00f3n de constantes ``` C #define CONSTANTE_DEFINE 25 enum T_ENUM { CONSTANTE_ENUM = 25 }; const int CONSTANTE_VARIABLE = 25 ; Valores Booleanos en C \u00b6 Es un importante mencionar que en C, las variables tipo booleanas no existen. En vez de eso, todo valor diferente de 0 se considera verdadero, es decir si se desea representar el valor falso se debe utilizar un 0. Funciones en C \u00b6 En la declaraci\u00f3n de la funci\u00f3n debe ir el tipo de dato del valor de retorno y de todos los argumentos. void para declarar funciones sin nigun retorno. Las funciones en C deben ser declaradas antes de ser usadas; esto implica que tendremos problemas con funciones de este tipo: int funcion1 ( int x ){ if ( x < 10 ){ return function2 ( x ); } return x + 1 ; } int funcion2 ( int x ){ if ( x >= 10 ){ return function1 ( x ); } return x - 1 ; } Noten que aqui function1(int x) ejecuta function2(int x) , pero function2(int x) esta definida abajo de function1(int x) . Para solucionar este problema, declaramos las funciones antes de definirlas: int function1 ( int x ); int function2 ( int x ); int funcion1 ( int x ){ if ( x < 10 ){ return function2 ( x ); } return x + 1 ; } int funcion2 ( int x ){ if ( x >= 10 ){ return function1 ( x ); } return x - 1 ; } Ejemplo: Funci\u00f3n que retorna un valor entero. \u00b6 int funcion1 (){ x = 10 ; return x ; } Ejemplo: Funci\u00f3n que no tiene un valor de retorno y que recibe un entero como argumento. \u00b6 void function2 ( int x ){ printf ( \"Hola Mundo %d!\" , x ); } Estructuras en c \u00b6 Es un tipo de dato compuesto el cual permite almacenar un conjunto de datos de tipos diferentes. Es muy similar a lo que en java se conoce como clases, pero sin m\u00e9todos. Ejemplo: \u00b6 int main ( void ){ /*definimos una estructura en C llamada Point que contiene 2 variables de tipo entero. */ typedef struct { int x , y ; } Point ; Point p1 ; //se define una variable de tipo Point llamada p1 //asignanci\u00f3n de valores a las variables x y y de la variable p1. p1 . x = 2 ; p1 . y = 4 ; return 0 ; } Punteros en c \u00b6 Un puntero es una variable la cual guarda la direcci\u00f3n de memoria de otra variable o de alg\u00fan dato. Es necesario al igual que una simple variable asignar el tipo que representa. Ejemplo: \u00b6 int * pi ; //declaraci\u00f3n de un puntero de datos enteros. char * pc ; //declaraci\u00f3n de un puntero d\u00e9 datos tipo char. Ejemplo: Puntero de tipo arbitrario. \u00b6 //definici\u00f3n de un puntero el cual puede ser asignado a diferentes tipos. void * vp ; Podemos incluso definir un puntero que apunta a un puntero Ejemplo: Puntero de Punteros \u00b6 //definici\u00f3n una variable, un puntero que apunta a ella, y un puntero que apunta a este puntero char c = '1' ; char * p = & c ; char ** args = & p ; Ejemplo: Asiginar Valores Usando Punteros \u00b6 int x = 10 ; int * pi = & x ; //al puntero pi se le asigna la direcci\u00f3n de memoria de la variable x. int valorx = * pi ; // en la variable valorx se almacena el valor al cual apunta la variable pi, en este ejemplo es 10 C pasa los argumentos a una funci\u00f3n por valor, esto quiere decir que la informaci\u00f3n de la variable que se recibe en la funci\u00f3n es almacenada en una diferente direcci\u00f3n de memoria por lo tanto si la variable se altera dentro de la funci\u00f3n, solo ser\u00e1 modificada en el contexto de la funci\u00f3n. Para poder modificar el valor de una variable x declarada en una funci\u00f3n A desde una funci\u00f3n B , enviamos un puntero que apunta a x como argumento a la funci\u00f3n B : Ejemplo: \u00b6 void addOne ( int * x ){ ( * x ) ++ ; } int functionA (){ int x = 10 ; addOne ( & x ); return x ; } Noten el usuo de los par\u00e9ntesis, sin los par\u00e9ntesis, aumentariamos en 1 el puntero, pero al agregarlos, aumentamos en 1 el valor al que apunta el puntero Manejo de Memoria en C \u00b6 Podemos diferenciar varias estructuras de memoria existentes al momento de ejecutar un programa: - \u00c0rea de Texto: Almacena las instrucciones que estamos ejecutando - \u00c0rea de Datos: Almacena datos como numeros y strings que son constantes globales en nuestro programa - Stack: Almacena datos estaticos como variables, arreglos de tama\u00f1o predefinito, etc. Estos datos tienen la caracteristica de que no existen en todo momento de la ejecuci\u00f3n del programa. Por ejemplo, una variable x definida en cierta funci\u00f3n solo existir\u00e1 cuando esa funci\u00f3n se este ejecutando. Algunas cosas a tomar en cuenta sobre el stack, aunque no las veremos directamente en C, son las siguientes: - Tiene 3 operaciones b\u00e1sicas de un stack: push, pop, top (observar que hay) - CUIDADO con la ubicacion del Stack; en assembler veremos que el Stack crece habia abajo , lo que significa que cuando agregamos un dato, la direcci\u00f3n de memoria disminuye - A nivel ensamblador existe un registro llamado Stack Pointer o SP . Probablemente el registro m\u00e1s usado en assembler - Las variables locales y los par\u00e1metros de las funciones se guardan en el Stack - La direcci\u00f3n de retorno tambien se guarda en el Stack - El compilador es el que se encarga de pedir memoria en cada llamada y devolverla cuando se termina, es decir, el Stack es \"transparente\" al programador de C Heap: Almacena datos din\u00e1micos , como por ejemplo, un arreglo del tama\u00f1o indicado por el usuario. En C, el Heap es la unica estructura de memoria que es administrada directamente por el programador (reservar, liberar y respetar el espacio asignado). El heap, a diferencia del Stack, crece a direcciones de memorias m\u00e1s altas. Manejo del Heap \u00b6 funci\u00f3n malloc() : los devuelve un bloque de memoria. No los inicializa con ning\u00fan valor. ptr = ( cast - type * ) malloc ( byte - size ) // prt es un puntero #### Ejemplo // ptr es puntero a un \"bloque\" de 100 enteros. ptr = ( int * ) malloc ( 100 * sizeof ( int )); funci\u00f3n calloc() : bloque de memoria inicializada con ceros. Es una operaci\u00f3n lenta. Evitar usarla en cuanto sea posible. funci\u00f3n free() : libera un bloque de memoria que previamente pedimos. cuidado con usar malloc sin el free. \"Aqu\u00ed no hay garbage collector\" Puede ser lento buscar espacio disponible Recordar que manejar el heap es tarea del programador. Uso de Valgrid \u00b6 Se puede descargar de: http://valgrind.org/ - Ayuda a la depuraci\u00f3n de problemas de memoria. Puede servir para detectar problemas como fugas de memoria (memory leak). Clasificaci\u00f3n de Bugs \u00b6 Bohr Bugs sabemos en precisamente en donde est\u00e1 (como los electones en el modelo at\u00f3mico de Bohr) F\u00e1ciles de reproducir Heinsenbugs Dif\u00edciles de diagnosticar Dificiles de reproducir","title":"C"},{"location":"notes/01_C/#introduccion-a-c","text":"C es un lenguaje de programaci\u00f3n desarrollado en el a\u00f1o 1972 por Dennis Ritchie. El lenguaje C es un lenguaje estructurado el cual a pesar de ser un lenguaje de \"alto nivel\", da acceso a hacer uso de la memoria, registros, etc. C es un lenguaje compilado; se compila una vez para cada arquitectura y se genera un binario que se puede ejecutar directamente. Para poder compilar y ejecutar un archivo llamado HelloWorld.c, se realiza de la siguiente manera: $ gcc HelloWorld . c // se compila el archivo $ . / a . out // se ejecuta el programa $ Hello World //output del programa, en este caso Notese que el compilador que estamos utilizando se llama gcc . gcc * se encuentra por defecto en la mayoria de sistemas operativos con kernel linux . Cuando nosotros no especificamos un nombre para el archivo de salida, cgg lo nombra, por defecto, a.out**. Si queremos especificar un nombre para el archivo de salida entonces podemos utilizar la bandera -o : $ gcc - o Hello HelloWorld . c // se compila el archivo $ . / Hello // se ejecuta el programa $ Hello World //output del programa, en este caso","title":"Introducci\u00f3n a C"},{"location":"notes/01_C/#comentarios-en-c","text":"// para realizar comentarios de una l\u00ednea /* TODO LO QUE ESTE DENTRO DE ESTA PARTE ES UN COMENTARIO */ ``` ~ ## Tipos de declaraci\u00f3n Las variables deben ser declaradas antes de usarse y el tipo de la variable no puede ser cambiado . En C , el tama\u00f1o de la variable depende de la arquitectura en la cual se este trabajando ( x_86 , x_86_84 , ARM , RISC - V , etc .). Algo muy importante que diferencia lenguajes como Java de C , es que en C , si no se inicializa el valor de la variable , la podemos utilizar sin problemas , pero contendr\u00e1 informaci\u00f3n \"basura\" , es decir , los datos que estaban ubicados previamente en la direcci\u00f3n de memoria en donde la variable fue guardada . ## Declaraci\u00f3n de constantes ``` C #define CONSTANTE_DEFINE 25 enum T_ENUM { CONSTANTE_ENUM = 25 }; const int CONSTANTE_VARIABLE = 25 ;","title":"Comentarios en c"},{"location":"notes/01_C/#valores-booleanos-en-c","text":"Es un importante mencionar que en C, las variables tipo booleanas no existen. En vez de eso, todo valor diferente de 0 se considera verdadero, es decir si se desea representar el valor falso se debe utilizar un 0.","title":"Valores Booleanos en C"},{"location":"notes/01_C/#funciones-en-c","text":"En la declaraci\u00f3n de la funci\u00f3n debe ir el tipo de dato del valor de retorno y de todos los argumentos. void para declarar funciones sin nigun retorno. Las funciones en C deben ser declaradas antes de ser usadas; esto implica que tendremos problemas con funciones de este tipo: int funcion1 ( int x ){ if ( x < 10 ){ return function2 ( x ); } return x + 1 ; } int funcion2 ( int x ){ if ( x >= 10 ){ return function1 ( x ); } return x - 1 ; } Noten que aqui function1(int x) ejecuta function2(int x) , pero function2(int x) esta definida abajo de function1(int x) . Para solucionar este problema, declaramos las funciones antes de definirlas: int function1 ( int x ); int function2 ( int x ); int funcion1 ( int x ){ if ( x < 10 ){ return function2 ( x ); } return x + 1 ; } int funcion2 ( int x ){ if ( x >= 10 ){ return function1 ( x ); } return x - 1 ; }","title":"Funciones en C"},{"location":"notes/01_C/#ejemplo-funcion-que-retorna-un-valor-entero","text":"int funcion1 (){ x = 10 ; return x ; }","title":"Ejemplo: Funci\u00f3n que retorna un valor entero."},{"location":"notes/01_C/#ejemplo-funcion-que-no-tiene-un-valor-de-retorno-y-que-recibe-un-entero-como-argumento","text":"void function2 ( int x ){ printf ( \"Hola Mundo %d!\" , x ); }","title":"Ejemplo: Funci\u00f3n que no tiene un valor de retorno y que recibe un entero como argumento."},{"location":"notes/01_C/#estructuras-en-c","text":"Es un tipo de dato compuesto el cual permite almacenar un conjunto de datos de tipos diferentes. Es muy similar a lo que en java se conoce como clases, pero sin m\u00e9todos.","title":"Estructuras en c"},{"location":"notes/01_C/#ejemplo","text":"int main ( void ){ /*definimos una estructura en C llamada Point que contiene 2 variables de tipo entero. */ typedef struct { int x , y ; } Point ; Point p1 ; //se define una variable de tipo Point llamada p1 //asignanci\u00f3n de valores a las variables x y y de la variable p1. p1 . x = 2 ; p1 . y = 4 ; return 0 ; }","title":"Ejemplo:"},{"location":"notes/01_C/#punteros-en-c","text":"Un puntero es una variable la cual guarda la direcci\u00f3n de memoria de otra variable o de alg\u00fan dato. Es necesario al igual que una simple variable asignar el tipo que representa.","title":"Punteros en c"},{"location":"notes/01_C/#ejemplo_1","text":"int * pi ; //declaraci\u00f3n de un puntero de datos enteros. char * pc ; //declaraci\u00f3n de un puntero d\u00e9 datos tipo char.","title":"Ejemplo:"},{"location":"notes/01_C/#ejemplo-puntero-de-tipo-arbitrario","text":"//definici\u00f3n de un puntero el cual puede ser asignado a diferentes tipos. void * vp ; Podemos incluso definir un puntero que apunta a un puntero","title":"Ejemplo: Puntero de tipo arbitrario."},{"location":"notes/01_C/#ejemplo-puntero-de-punteros","text":"//definici\u00f3n una variable, un puntero que apunta a ella, y un puntero que apunta a este puntero char c = '1' ; char * p = & c ; char ** args = & p ;","title":"Ejemplo: Puntero de Punteros"},{"location":"notes/01_C/#ejemplo-asiginar-valores-usando-punteros","text":"int x = 10 ; int * pi = & x ; //al puntero pi se le asigna la direcci\u00f3n de memoria de la variable x. int valorx = * pi ; // en la variable valorx se almacena el valor al cual apunta la variable pi, en este ejemplo es 10 C pasa los argumentos a una funci\u00f3n por valor, esto quiere decir que la informaci\u00f3n de la variable que se recibe en la funci\u00f3n es almacenada en una diferente direcci\u00f3n de memoria por lo tanto si la variable se altera dentro de la funci\u00f3n, solo ser\u00e1 modificada en el contexto de la funci\u00f3n. Para poder modificar el valor de una variable x declarada en una funci\u00f3n A desde una funci\u00f3n B , enviamos un puntero que apunta a x como argumento a la funci\u00f3n B :","title":"Ejemplo: Asiginar Valores Usando Punteros"},{"location":"notes/01_C/#ejemplo_2","text":"void addOne ( int * x ){ ( * x ) ++ ; } int functionA (){ int x = 10 ; addOne ( & x ); return x ; } Noten el usuo de los par\u00e9ntesis, sin los par\u00e9ntesis, aumentariamos en 1 el puntero, pero al agregarlos, aumentamos en 1 el valor al que apunta el puntero","title":"Ejemplo:"},{"location":"notes/01_C/#manejo-de-memoria-en-c","text":"Podemos diferenciar varias estructuras de memoria existentes al momento de ejecutar un programa: - \u00c0rea de Texto: Almacena las instrucciones que estamos ejecutando - \u00c0rea de Datos: Almacena datos como numeros y strings que son constantes globales en nuestro programa - Stack: Almacena datos estaticos como variables, arreglos de tama\u00f1o predefinito, etc. Estos datos tienen la caracteristica de que no existen en todo momento de la ejecuci\u00f3n del programa. Por ejemplo, una variable x definida en cierta funci\u00f3n solo existir\u00e1 cuando esa funci\u00f3n se este ejecutando. Algunas cosas a tomar en cuenta sobre el stack, aunque no las veremos directamente en C, son las siguientes: - Tiene 3 operaciones b\u00e1sicas de un stack: push, pop, top (observar que hay) - CUIDADO con la ubicacion del Stack; en assembler veremos que el Stack crece habia abajo , lo que significa que cuando agregamos un dato, la direcci\u00f3n de memoria disminuye - A nivel ensamblador existe un registro llamado Stack Pointer o SP . Probablemente el registro m\u00e1s usado en assembler - Las variables locales y los par\u00e1metros de las funciones se guardan en el Stack - La direcci\u00f3n de retorno tambien se guarda en el Stack - El compilador es el que se encarga de pedir memoria en cada llamada y devolverla cuando se termina, es decir, el Stack es \"transparente\" al programador de C Heap: Almacena datos din\u00e1micos , como por ejemplo, un arreglo del tama\u00f1o indicado por el usuario. En C, el Heap es la unica estructura de memoria que es administrada directamente por el programador (reservar, liberar y respetar el espacio asignado). El heap, a diferencia del Stack, crece a direcciones de memorias m\u00e1s altas.","title":"Manejo de Memoria en C"},{"location":"notes/01_C/#manejo-del-heap","text":"funci\u00f3n malloc() : los devuelve un bloque de memoria. No los inicializa con ning\u00fan valor. ptr = ( cast - type * ) malloc ( byte - size ) // prt es un puntero #### Ejemplo // ptr es puntero a un \"bloque\" de 100 enteros. ptr = ( int * ) malloc ( 100 * sizeof ( int )); funci\u00f3n calloc() : bloque de memoria inicializada con ceros. Es una operaci\u00f3n lenta. Evitar usarla en cuanto sea posible. funci\u00f3n free() : libera un bloque de memoria que previamente pedimos. cuidado con usar malloc sin el free. \"Aqu\u00ed no hay garbage collector\" Puede ser lento buscar espacio disponible Recordar que manejar el heap es tarea del programador.","title":"Manejo del Heap"},{"location":"notes/01_C/#uso-de-valgrid","text":"Se puede descargar de: http://valgrind.org/ - Ayuda a la depuraci\u00f3n de problemas de memoria. Puede servir para detectar problemas como fugas de memoria (memory leak).","title":"Uso de Valgrid"},{"location":"notes/01_C/#clasificacion-de-bugs","text":"Bohr Bugs sabemos en precisamente en donde est\u00e1 (como los electones en el modelo at\u00f3mico de Bohr) F\u00e1ciles de reproducir Heinsenbugs Dif\u00edciles de diagnosticar Dificiles de reproducir","title":"Clasificaci\u00f3n de Bugs"},{"location":"notes/02_Intro-RISCV/","text":"Introducci\u00f3n a RISC V \u00b6 Estos son algunos de los t\u00e9rminos m\u00e1s importantes de este tema: - ISA (probablemente uno de los t\u00e9rminos mas importantes del curso): Es el pegamento que une el hardware con el software . Una especie de \"contrato\" que nos dice lo que s\u00ed podemos hacer porque tiene un soporte por el hardware . El ISA o Instruction Set Architecture es el set de instrucciones reales soportadas por el procesador sobre el que estamos trabajando. - RISC: Reduced Instruction Set Computer - Un ejemplo de procesadores RISC son los procesadores MIPS, ARM y RISC-V. - Este tipo de procesadores utiliza muchos regitros (32 registros de 32 bits cada uno, por ejemplo) - Se caracteriza por tener pocas instrucciones, siendo todas de un tama\u00f1o fijo (32 bits, por ejemplo) - Existen pocas instrucciones para acceder a memoria, (2 basicamente: lw y sw ) - La base de los procesadores RISC es soportar pocas instrucciones, pero hacerlas muy eficientemente - CISC: Complex Instruction Set Computer - x86 x86_64 (Intel) - Este tipo de procesadores utiliza pocos regitros - Soporta una cantidad de instrucciones mucho mayor a los procesadores RISC, y muchas de estas instrucciones no son de un tama\u00f1o fijo - La base de los procesadores CISC es soportar la mayor cantidad de instrucciones posibles para darle multiples opciones a los desarrolladores \u00bfQu\u00e9 es RISC-V? \u00b6 RISC-V es la quinta versi\u00f3n de procesadores RISC dise\u00f1ador por Berkeley De licencia libre Los registros son \u00a1muy! r\u00e1pidos (y caros) y se encuentran dentro del procesador Tiene un formato rigido: operacion registro_destino registro_fuente1 registro_fuente2 Esta es la distribuci\u00f3n de registros utilizada en procesadores RISC-V (nombrados del x0 al x31): Registros Nombre Funci\u00f3n x0 ZERO Alambrado a tierra. x0 siempre contiene el valor 0x00000000 x1 RA Return Address: Contiene la direcci\u00f3n de retorno de la funci\u00f3n actual x2 SP Stack Pointer: Es un puntero a la cabeza del Stack x3 GP Global Pointer: Es un puntero a la secci\u00f3n global de Data x4 TP Thread Pointer: No lo utiilizaremos en este curso, pero cabe mencionar su existencia x5-x7 t0-t2 Temporaries: Registros de proposito general que no se conservan en llamadas a funciones x8 s0/fp Saved Register (Frame Pointer): Registro seguro , se debe conservar su valor entre llamadas. El frame pointer contiene la direcci\u00f3n justo antes de la llamada a una funci\u00f3n. Sirve para regresar el stack a su posici\u00f3n original al regresar de una funci\u00f3n x9 s1 Saved Register: Registro seguro de prop\u00f3sito general, se debe conservar su valor entre llamadas x10-x11 a0-a1 Function Arguments & Return Values: Registros utilizados para enviar argumentos en las llamadas a funciones. Tambien son usados como valor de retorno de las funciones x12-x17 a2-a7 Function Arguments: Registros utilizados para enviar argumentos en las llamadas a funciones x18-x27 s2-s11 Saved Registers: Registros seguros de prop\u00f3sito general, se debe conservar su valor entre llamadas x28-x31 t3-t6 Temporaries: Registros de proposito general que no se conservan en llamadas a funciones Algunos Ejemplos en RISC-V \u00b6 Convertir un ciclo a Ensamblador en RISC-V \u00b6 int a [ 20 ]; int sum = 0 ; for ( int i = 0 ; i < 20 ; i ++ ){ sum += a [ i ]; } # Asumimos A = x8 addi x5, x0, 0 # sum = 0 addi x6, x0, 0 # i = 0 addi x28, x0, 20 # x28 = 20 Condition: blt x6, x28, For # Evaluamos la condici\u00f3n antes de empezar el ciclo j EndFor # Si es falsa terminamos el ciclo For: lw x7, 0(x8) add x5, x5, x7 # sum+=A[i] addi x8, x8, 4 # A++ \u00bfPor qu\u00e9 +4? addi x6, x6, 1 # i++ j Condition EndFor: Partes de un Ciclo \u00b6 Inicializaci\u00f3n: fuera del ciclo Condici\u00f3n: para go to step, while y for queremos queremos un true para seguir. False para detenernos Instrucciones: \u00bfqu\u00e9 me pide el problema? Step: un peque\u00f1o cambio entre una iteraci\u00f3n y otra, se relaciona con la condici\u00f3n. Funciones \u00b6 Entre llamadas a funciones, pueden haber muchos valores que se sobreescriben. Una soluci\u00f3n simple a este problema es guardar estos valores en el Stack. Antes de hacer una llamada a una funci\u00f3n, el caller debe almacenar valores como los argumentos recibidos (si es que recibio alguno), su return address , y los valores que desee preservar en registros seguros (guardando el contenido actual de estos registros antes de sobreescribirlo). Es importante mencionar que, cualquier espacio reservado en el stack al inicio de una funci\u00f3n, debe ser liberado antes de retornar de ella. Esto garantiza que cuando se regrese a la funci\u00f3n anterior, el stack quedar\u00e1 en la misma posici\u00f3n de antes de ejecutar la funci\u00f3n. Ejemplo Funci\u00f3n \u00b6 La siguiente funci\u00f3n en C int sum ( int x , int y ){ return x + y ; } Se traduce a function_sum: add a0, a0, a1 #los argumentos vienen en a0 y a1, y el valor de retorno se devuelve en a0 jr ra #sabemos que ra tiene la direcci\u00f3n de retorno Ahora veamos como se codifica la llamada a esta funci\u00f3n int x = 1 ; int y = 1 ; sum ( x , y ); addi a0, zero, 1 #int x = 1 addi a1, zero, 1 #int y = 1 addi sp, sp, -12 #reservamos espacio en el stack para las variables y el return address sw ra, 0(sp) # sw s0, 4(sp) #guardamos los registros en el stack sw s1, 8(sp) # add s0, a0, zero add s1, a1, zero #guardamos los valores de las variables el registros seguros para no perderlos jal function_sum #saltamos a la funcion add t0, zero, a0 #nuestro valor de retorno esta en a0, lo pasamos a cualquier otro registro add a0, zero, s0 #restauramos nuestra variable x en a0 add a1, zero, s1 #restauramos nuestra variable y en a1 lw ra, 0(sp) # lw s0, 4(sp) #restauramos los registros seguros y el return address lw s1, 8(sp) # addi sp, sp, 12 #regresamos el stack a la posici\u00f3n original","title":"RISC-V"},{"location":"notes/02_Intro-RISCV/#introduccion-a-risc-v","text":"Estos son algunos de los t\u00e9rminos m\u00e1s importantes de este tema: - ISA (probablemente uno de los t\u00e9rminos mas importantes del curso): Es el pegamento que une el hardware con el software . Una especie de \"contrato\" que nos dice lo que s\u00ed podemos hacer porque tiene un soporte por el hardware . El ISA o Instruction Set Architecture es el set de instrucciones reales soportadas por el procesador sobre el que estamos trabajando. - RISC: Reduced Instruction Set Computer - Un ejemplo de procesadores RISC son los procesadores MIPS, ARM y RISC-V. - Este tipo de procesadores utiliza muchos regitros (32 registros de 32 bits cada uno, por ejemplo) - Se caracteriza por tener pocas instrucciones, siendo todas de un tama\u00f1o fijo (32 bits, por ejemplo) - Existen pocas instrucciones para acceder a memoria, (2 basicamente: lw y sw ) - La base de los procesadores RISC es soportar pocas instrucciones, pero hacerlas muy eficientemente - CISC: Complex Instruction Set Computer - x86 x86_64 (Intel) - Este tipo de procesadores utiliza pocos regitros - Soporta una cantidad de instrucciones mucho mayor a los procesadores RISC, y muchas de estas instrucciones no son de un tama\u00f1o fijo - La base de los procesadores CISC es soportar la mayor cantidad de instrucciones posibles para darle multiples opciones a los desarrolladores","title":"Introducci\u00f3n a RISC V"},{"location":"notes/02_Intro-RISCV/#que-es-risc-v","text":"RISC-V es la quinta versi\u00f3n de procesadores RISC dise\u00f1ador por Berkeley De licencia libre Los registros son \u00a1muy! r\u00e1pidos (y caros) y se encuentran dentro del procesador Tiene un formato rigido: operacion registro_destino registro_fuente1 registro_fuente2 Esta es la distribuci\u00f3n de registros utilizada en procesadores RISC-V (nombrados del x0 al x31): Registros Nombre Funci\u00f3n x0 ZERO Alambrado a tierra. x0 siempre contiene el valor 0x00000000 x1 RA Return Address: Contiene la direcci\u00f3n de retorno de la funci\u00f3n actual x2 SP Stack Pointer: Es un puntero a la cabeza del Stack x3 GP Global Pointer: Es un puntero a la secci\u00f3n global de Data x4 TP Thread Pointer: No lo utiilizaremos en este curso, pero cabe mencionar su existencia x5-x7 t0-t2 Temporaries: Registros de proposito general que no se conservan en llamadas a funciones x8 s0/fp Saved Register (Frame Pointer): Registro seguro , se debe conservar su valor entre llamadas. El frame pointer contiene la direcci\u00f3n justo antes de la llamada a una funci\u00f3n. Sirve para regresar el stack a su posici\u00f3n original al regresar de una funci\u00f3n x9 s1 Saved Register: Registro seguro de prop\u00f3sito general, se debe conservar su valor entre llamadas x10-x11 a0-a1 Function Arguments & Return Values: Registros utilizados para enviar argumentos en las llamadas a funciones. Tambien son usados como valor de retorno de las funciones x12-x17 a2-a7 Function Arguments: Registros utilizados para enviar argumentos en las llamadas a funciones x18-x27 s2-s11 Saved Registers: Registros seguros de prop\u00f3sito general, se debe conservar su valor entre llamadas x28-x31 t3-t6 Temporaries: Registros de proposito general que no se conservan en llamadas a funciones","title":"\u00bfQu\u00e9 es RISC-V?"},{"location":"notes/02_Intro-RISCV/#algunos-ejemplos-en-risc-v","text":"","title":"Algunos Ejemplos en RISC-V"},{"location":"notes/02_Intro-RISCV/#convertir-un-ciclo-a-ensamblador-en-risc-v","text":"int a [ 20 ]; int sum = 0 ; for ( int i = 0 ; i < 20 ; i ++ ){ sum += a [ i ]; } # Asumimos A = x8 addi x5, x0, 0 # sum = 0 addi x6, x0, 0 # i = 0 addi x28, x0, 20 # x28 = 20 Condition: blt x6, x28, For # Evaluamos la condici\u00f3n antes de empezar el ciclo j EndFor # Si es falsa terminamos el ciclo For: lw x7, 0(x8) add x5, x5, x7 # sum+=A[i] addi x8, x8, 4 # A++ \u00bfPor qu\u00e9 +4? addi x6, x6, 1 # i++ j Condition EndFor:","title":"Convertir un ciclo a Ensamblador en RISC-V"},{"location":"notes/02_Intro-RISCV/#partes-de-un-ciclo","text":"Inicializaci\u00f3n: fuera del ciclo Condici\u00f3n: para go to step, while y for queremos queremos un true para seguir. False para detenernos Instrucciones: \u00bfqu\u00e9 me pide el problema? Step: un peque\u00f1o cambio entre una iteraci\u00f3n y otra, se relaciona con la condici\u00f3n.","title":"Partes de un Ciclo"},{"location":"notes/02_Intro-RISCV/#funciones","text":"Entre llamadas a funciones, pueden haber muchos valores que se sobreescriben. Una soluci\u00f3n simple a este problema es guardar estos valores en el Stack. Antes de hacer una llamada a una funci\u00f3n, el caller debe almacenar valores como los argumentos recibidos (si es que recibio alguno), su return address , y los valores que desee preservar en registros seguros (guardando el contenido actual de estos registros antes de sobreescribirlo). Es importante mencionar que, cualquier espacio reservado en el stack al inicio de una funci\u00f3n, debe ser liberado antes de retornar de ella. Esto garantiza que cuando se regrese a la funci\u00f3n anterior, el stack quedar\u00e1 en la misma posici\u00f3n de antes de ejecutar la funci\u00f3n.","title":"Funciones"},{"location":"notes/02_Intro-RISCV/#ejemplo-funcion","text":"La siguiente funci\u00f3n en C int sum ( int x , int y ){ return x + y ; } Se traduce a function_sum: add a0, a0, a1 #los argumentos vienen en a0 y a1, y el valor de retorno se devuelve en a0 jr ra #sabemos que ra tiene la direcci\u00f3n de retorno Ahora veamos como se codifica la llamada a esta funci\u00f3n int x = 1 ; int y = 1 ; sum ( x , y ); addi a0, zero, 1 #int x = 1 addi a1, zero, 1 #int y = 1 addi sp, sp, -12 #reservamos espacio en el stack para las variables y el return address sw ra, 0(sp) # sw s0, 4(sp) #guardamos los registros en el stack sw s1, 8(sp) # add s0, a0, zero add s1, a1, zero #guardamos los valores de las variables el registros seguros para no perderlos jal function_sum #saltamos a la funcion add t0, zero, a0 #nuestro valor de retorno esta en a0, lo pasamos a cualquier otro registro add a0, zero, s0 #restauramos nuestra variable x en a0 add a1, zero, s1 #restauramos nuestra variable y en a1 lw ra, 0(sp) # lw s0, 4(sp) #restauramos los registros seguros y el return address lw s1, 8(sp) # addi sp, sp, 12 #regresamos el stack a la posici\u00f3n original","title":"Ejemplo Funci\u00f3n"},{"location":"notes/03_Functions-And-Instruction-Format/","text":"Funciones \u00b6 Entre llamadas a funciones, pueden haber muchos valores que se sobreescriben. Una soluci\u00f3n simple a este problema es guardar estos valores en el Stack. Antes de hacer una llamada a una funci\u00f3n, el caller debe almacenar valores como los argumentos recibidos (si es que recibio alguno), su return address , y los valores que desee preservar en registros seguros (guardando el contenido actual de estos registros antes de sobreescribirlo). Es importante mencionar que, cualquier espacio reservado en el stack al inicio de una funci\u00f3n, debe ser liberado antes de retornar de ella. Esto garantiza que cuando se regrese a la funci\u00f3n anterior, el stack quedar\u00e1 en la misma posici\u00f3n de antes de ejecutar la funci\u00f3n. Ejemplo Funci\u00f3n \u00b6 La siguiente funci\u00f3n en C int sum ( int x , int y ){ return x + y ; } Se traduce a function_sum: add a0, a0, a1 #los argumentos vienen en a0 y a1, y el valor de retorno se devuelve en a0 jr ra #sabemos que ra tiene la direcci\u00f3n de retorno Ahora veamos como se codifica la llamada a esta funci\u00f3n int x = 1 ; int y = 1 ; sum ( x , y ); addi a0, zero, 1 #int x = 1 addi a1, zero, 1 #int y = 1 addi sp, sp, -12 #reservamos espacio en el stack para las variables y el return address sw ra, 0(sp) # sw s0, 4(sp) #guardamos los registros en el stack sw s1, 8(sp) # add s0, a0, zero add s1, a1, zero #guardamos los valores de las variables el registros seguros para no perderlos jal function_sum #saltamos a la funcion add t0, zero, a0 #nuestro valor de retorno esta en a0, lo pasamos a cualquier otro registro add a0, zero, s0 #restauramos nuestra variable x en a0 add a1, zero, s1 #restauramos nuestra variable y en a1 lw ra, 0(sp) # lw s0, 4(sp) #restauramos los registros seguros y el return address lw s1, 8(sp) # addi sp, sp, 12 #regresamos el stack a la posici\u00f3n original RISC V Instruction Formats \u00b6 Gran idea: almacenar los programas en la computadora (Programa almacenado) \u00a1Lectura recomendada: https://es.wikipedia.org/wiki/John_von_Neumann ! Nacen dos grandes arquitecturas: Harvard (instrucciones y datos separados) Von Neumann (programas y datos en una memoria en com\u00fan) Program counter: alambrado a un sumador para moverse de 4 en 4 (que es el tama\u00f1o de instruccci\u00f3n) \u00f3 cuando hay saltos. \u00bfqu\u00e9 pasa con los programas que se distriuyen en forma binaria? 6 tipos b\u00e1sicos de instrucciones: R: operaciones aritm\u00e9ticas con dos registros I: operaciones con valores inmediatos S: para stores B: para branch's U: para upper immediate (20 bits) J: para jump Formato R \u00b6 32 bits dividido en 6 campos (7, 5,5,3,5,7 bits respectivamente) funct7 | rs2 | rs1 | funct3 | rd | opcode -- | --|--|--|--|--| 7 bits | 5 bits|5 bits | 3 bits | 5 bits | 7 bits el opcode nos especifica parcialmente que instrucci\u00f3n es funct7 + funct3: combinado con el opcode, decriben que operaci\u00f3n hacer. Las tipo I y las R tienen el mismo funct3 Formato I \u00b6 imm | rs1 | funct3 | rd | opcode -- |--|--|--|--| 12 bits | 5 bits | 3 bits | 5 bits | 7 bits - imm puede tener valores en el rango [-2048, 2047]","title":"Funciones"},{"location":"notes/03_Functions-And-Instruction-Format/#funciones","text":"Entre llamadas a funciones, pueden haber muchos valores que se sobreescriben. Una soluci\u00f3n simple a este problema es guardar estos valores en el Stack. Antes de hacer una llamada a una funci\u00f3n, el caller debe almacenar valores como los argumentos recibidos (si es que recibio alguno), su return address , y los valores que desee preservar en registros seguros (guardando el contenido actual de estos registros antes de sobreescribirlo). Es importante mencionar que, cualquier espacio reservado en el stack al inicio de una funci\u00f3n, debe ser liberado antes de retornar de ella. Esto garantiza que cuando se regrese a la funci\u00f3n anterior, el stack quedar\u00e1 en la misma posici\u00f3n de antes de ejecutar la funci\u00f3n.","title":"Funciones"},{"location":"notes/03_Functions-And-Instruction-Format/#ejemplo-funcion","text":"La siguiente funci\u00f3n en C int sum ( int x , int y ){ return x + y ; } Se traduce a function_sum: add a0, a0, a1 #los argumentos vienen en a0 y a1, y el valor de retorno se devuelve en a0 jr ra #sabemos que ra tiene la direcci\u00f3n de retorno Ahora veamos como se codifica la llamada a esta funci\u00f3n int x = 1 ; int y = 1 ; sum ( x , y ); addi a0, zero, 1 #int x = 1 addi a1, zero, 1 #int y = 1 addi sp, sp, -12 #reservamos espacio en el stack para las variables y el return address sw ra, 0(sp) # sw s0, 4(sp) #guardamos los registros en el stack sw s1, 8(sp) # add s0, a0, zero add s1, a1, zero #guardamos los valores de las variables el registros seguros para no perderlos jal function_sum #saltamos a la funcion add t0, zero, a0 #nuestro valor de retorno esta en a0, lo pasamos a cualquier otro registro add a0, zero, s0 #restauramos nuestra variable x en a0 add a1, zero, s1 #restauramos nuestra variable y en a1 lw ra, 0(sp) # lw s0, 4(sp) #restauramos los registros seguros y el return address lw s1, 8(sp) # addi sp, sp, 12 #regresamos el stack a la posici\u00f3n original","title":"Ejemplo Funci\u00f3n"},{"location":"notes/03_Functions-And-Instruction-Format/#risc-v-instruction-formats","text":"Gran idea: almacenar los programas en la computadora (Programa almacenado) \u00a1Lectura recomendada: https://es.wikipedia.org/wiki/John_von_Neumann ! Nacen dos grandes arquitecturas: Harvard (instrucciones y datos separados) Von Neumann (programas y datos en una memoria en com\u00fan) Program counter: alambrado a un sumador para moverse de 4 en 4 (que es el tama\u00f1o de instruccci\u00f3n) \u00f3 cuando hay saltos. \u00bfqu\u00e9 pasa con los programas que se distriuyen en forma binaria? 6 tipos b\u00e1sicos de instrucciones: R: operaciones aritm\u00e9ticas con dos registros I: operaciones con valores inmediatos S: para stores B: para branch's U: para upper immediate (20 bits) J: para jump","title":"RISC V Instruction Formats"},{"location":"notes/03_Functions-And-Instruction-Format/#formato-r","text":"32 bits dividido en 6 campos (7, 5,5,3,5,7 bits respectivamente) funct7 | rs2 | rs1 | funct3 | rd | opcode -- | --|--|--|--|--| 7 bits | 5 bits|5 bits | 3 bits | 5 bits | 7 bits el opcode nos especifica parcialmente que instrucci\u00f3n es funct7 + funct3: combinado con el opcode, decriben que operaci\u00f3n hacer. Las tipo I y las R tienen el mismo funct3","title":"Formato R"},{"location":"notes/03_Functions-And-Instruction-Format/#formato-i","text":"imm | rs1 | funct3 | rd | opcode -- |--|--|--|--| 12 bits | 5 bits | 3 bits | 5 bits | 7 bits - imm puede tener valores en el rango [-2048, 2047]","title":"Formato I"},{"location":"notes/03_Instruction-Format/","text":"RISC V Instruction Formats \u00b6 Gran idea: almacenar los programas en la computadora (Programa almacenado) \u00a1Lectura recomendada: https://es.wikipedia.org/wiki/John_von_Neumann ! Nacen dos grandes arquitecturas: Harvard (instrucciones y datos separados) Von Neumann (programas y datos en una memoria en com\u00fan) Program counter: alambrado a un sumador para moverse de 4 en 4 (que es el tama\u00f1o de instruccci\u00f3n) \u00f3 cuando hay saltos. \u00bfqu\u00e9 pasa con los programas que se distriuyen en forma binaria? 6 tipos b\u00e1sicos de instrucciones: R: operaciones aritm\u00e9ticas con dos registros I: operaciones con valores inmediatos S: para stores B: para branch's U: para upper immediate (20 bits) J: para jump Formato R \u00b6 32 bits dividido en 6 campos (7, 5,5,3,5,7 bits respectivamente) funct7 | rs2 | rs1 | funct3 | rd | opcode -- | --|--|--|--|--| 7 bits | 5 bits|5 bits | 3 bits | 5 bits | 7 bits el opcode nos especifica parcialmente que instrucci\u00f3n es funct7 + funct3: combinado con el opcode, decriben que operaci\u00f3n hacer. Las tipo I y las R tienen el mismo funct3 Formato I \u00b6 imm | rs1 | funct3 | rd | opcode -- |--|--|--|--| 12 bits | 5 bits | 3 bits | 5 bits | 7 bits - imm puede tener valores en el rango [-2048, 2047] - Las instrucciones load son tipo I Formato S \u00b6 imm[5:11] rs2 rs1 function3 imm[0:4] opcode 7 bits 5 bits 5 bits 3 bits 5 bits 7 bits - A pesar de que en assembler los loads y stores son similares, en lenguaje de m\u00e1quina son dos tipos diferentes de instrucciones. Esto se debe a que los stores no tienen registro destino - La raz\u00f3n por la que los 5 bits menos significativos del valor inmediato est\u00e1n donde estan, es para mantener rs1 y rs2 en las mismas posiciones Formato J \u00b6 imm[20] imm[10:1] imm[11] imm[19:12] rd opcode 1 bits 10 bits 1 bits 8 bits 5 bits 7 bits Formato B \u00b6 imm[12] imm[10:5] rs2 rs1 func3 imm[4:1] imm[11] opcode 1 bit 6 bits 5 bits 5 bits 3 bits 4 bits 1 bit 7 bits - El valor inmediato representa la cantidad de halfwords (2 bytes) que se van a saltar, en representaci\u00f3n complemento a 2. Se utilizan halfwords y no words para mantener compatibilidad con la versi\u00f3n reducida de de RISC-V que utiliza instrucciones de 16 bits.","title":"RISC V Instruction Formats"},{"location":"notes/03_Instruction-Format/#risc-v-instruction-formats","text":"Gran idea: almacenar los programas en la computadora (Programa almacenado) \u00a1Lectura recomendada: https://es.wikipedia.org/wiki/John_von_Neumann ! Nacen dos grandes arquitecturas: Harvard (instrucciones y datos separados) Von Neumann (programas y datos en una memoria en com\u00fan) Program counter: alambrado a un sumador para moverse de 4 en 4 (que es el tama\u00f1o de instruccci\u00f3n) \u00f3 cuando hay saltos. \u00bfqu\u00e9 pasa con los programas que se distriuyen en forma binaria? 6 tipos b\u00e1sicos de instrucciones: R: operaciones aritm\u00e9ticas con dos registros I: operaciones con valores inmediatos S: para stores B: para branch's U: para upper immediate (20 bits) J: para jump","title":"RISC V Instruction Formats"},{"location":"notes/03_Instruction-Format/#formato-r","text":"32 bits dividido en 6 campos (7, 5,5,3,5,7 bits respectivamente) funct7 | rs2 | rs1 | funct3 | rd | opcode -- | --|--|--|--|--| 7 bits | 5 bits|5 bits | 3 bits | 5 bits | 7 bits el opcode nos especifica parcialmente que instrucci\u00f3n es funct7 + funct3: combinado con el opcode, decriben que operaci\u00f3n hacer. Las tipo I y las R tienen el mismo funct3","title":"Formato R"},{"location":"notes/03_Instruction-Format/#formato-i","text":"imm | rs1 | funct3 | rd | opcode -- |--|--|--|--| 12 bits | 5 bits | 3 bits | 5 bits | 7 bits - imm puede tener valores en el rango [-2048, 2047] - Las instrucciones load son tipo I","title":"Formato I"},{"location":"notes/03_Instruction-Format/#formato-s","text":"imm[5:11] rs2 rs1 function3 imm[0:4] opcode 7 bits 5 bits 5 bits 3 bits 5 bits 7 bits - A pesar de que en assembler los loads y stores son similares, en lenguaje de m\u00e1quina son dos tipos diferentes de instrucciones. Esto se debe a que los stores no tienen registro destino - La raz\u00f3n por la que los 5 bits menos significativos del valor inmediato est\u00e1n donde estan, es para mantener rs1 y rs2 en las mismas posiciones","title":"Formato S"},{"location":"notes/03_Instruction-Format/#formato-j","text":"imm[20] imm[10:1] imm[11] imm[19:12] rd opcode 1 bits 10 bits 1 bits 8 bits 5 bits 7 bits","title":"Formato J"},{"location":"notes/03_Instruction-Format/#formato-b","text":"imm[12] imm[10:5] rs2 rs1 func3 imm[4:1] imm[11] opcode 1 bit 6 bits 5 bits 5 bits 3 bits 4 bits 1 bit 7 bits - El valor inmediato representa la cantidad de halfwords (2 bytes) que se van a saltar, en representaci\u00f3n complemento a 2. Se utilizan halfwords y no words para mantener compatibilidad con la versi\u00f3n reducida de de RISC-V que utiliza instrucciones de 16 bits.","title":"Formato B"},{"location":"projs/proj01/","text":"Proyecto 1: C y RISC-V \u00b6 Objetivos \u00b6 Mejorar sus habilidades de programaci\u00f3n en C. Conocer algunos de los detalles de RISC-V. Prepararse para lo que viene m\u00e1s adelante en el curso. Requisitos de Conocimiento \u00b6 Para realizar este proyecto ustedes tienen que tener claros algunos conceptos, de lo contrario ser\u00e1 bastante dif\u00edcil e inc\u00f3modo empezar a trabajar. Les recomendamos que antes de empezar est\u00e9n totalmente seguros que dominan al 100% los siguientes puntos: Operaciones binarias en C ( xor , or , and , etc). Operaciones aritm\u00e9ticas con signo y sin signo en C. Type casting en C. Control de flujo en C ( switch , if , etc). Funciones en C. Entender qu\u00e9 son las estructuras ( struct ) en C. Entender c\u00f3mo funcionan las uniones ( union ) en C. Uso correcto de printf . Entender la estructura del set de instrucciones de RISC-V. Programar en lenguaje ensamblador RISC-V. Si creen que no tienen claro alguno de estos temas al 100%, por favor no duden en ir a consultar los libros y material correspondiente del curso, por ejemplo K&R , es indispensable. En Lecturas Recomendadas pueden encontrar algunas lecturas que tocan los puntos antes mencionados y otras cosas que tambi\u00e9n les pueden servir, nunca est\u00e1 dem\u00e1s tener un poco m\u00e1s de informaci\u00f3n. Lecturas Recomendadas \u00b6 Gu\u00eda Pr\u00e1ctica de RISC-V: 2 K&R: 6 P&H: B-43 Introducci\u00f3n \u00b6 En este proyecto ustedes deben de crear un emulador que pueda ejecutar un subconjunto de instrucciones de RISC-V . Ustedes se van a encargar de hacer un programa que decodifique y ejecute varias instrucciones de RISC-V. Consid\u00e9renlo como una versi\u00f3n miniatura de V-Sim . RISC-V Green Card \u00b6 Aqu\u00ed hay dos RISC-V Green Cards que pueden consultar y as\u00ed tener m\u00e1s herramientras que les pueden ayudar a completar el proyecto. La primera tiene informaci\u00f3n acerca de los opcodes y otros campos de cada uno de los diferentes formatos de instrucci\u00f3n, por lo que esta ser\u00eda su mejor opci\u00f3n. Preparaci\u00f3n \u00b6 Antes de comenzar aseg\u00farense de que hayan le\u00eddo y comprendido todas las instrucciones del proyecto de principio a fin . Si tienen alguna pregunta pueden consultar la secci\u00f3n de preguntas frecuentes para ver si ya ha sido resuelta, de lo contrario por favor dir\u00edjanse a Slack y pregunten en los canales correspondientes. Para comenzar con el proyecto, primero tienen que tener todos los archivos base, estos se encuentran aqu\u00ed . Tienen permitido trabajar en parejas o de forma individual, por lo que al aceptar la asignaci\u00f3n les preguntar\u00e1 si desean crear un grupo nuevo o unirse a uno ya existente. Si crean un grupo nuevo, ingresen un nombre que represente al grupo y que no est\u00e9 ya en los grupos existentes. Si desean unirse a un grupo ya creado, tienen que buscar el nombre del grupo y pulsar el bot\u00f3n que dice join Tienen que tener mucho cuidado al unirse a un grupo ya existente, ya que esto no se puede cambiar despu\u00e9s, adem\u00e1s lo consideraremos como PLAGIO si lo realizan de manera incorrecta, ya que al hacer esto pueden tener acceso al repositorio del otro miembro del grupo. Ya sea que se unan o creen un nuevo grupo, al finalizar el proceso les crear\u00e1 autom\u00e1ticamente un repositorio con una extensi\u00f3n que termina con su nombre de grupo. Ya habiendo hecho todo eso, pueden ejecutar los siguientes comandos abriendo una terminal ( CTRL + T ): git clone <link del repositorio> NOTA : Tienen que reemplazar <link del repositorio> con el link del repositorio que se cre\u00f3. Estructura del Proyecto \u00b6 Cuando hayan clonado el repositorio, se van a encontrar con los siguientes archivos: Makefile part1.c part2.c README.md riscv.c riscvcode/ riscv.h submit types.h utils.c utils.h Los \u00fanicos archivos que pueden modificar son: part1.c : Este es el archivo que van a modificar en la parte 1 del proyecto. utils.c : Archivo auxiliar que contendr\u00e1 varias funciones de ayuda para la parte 1 y 2 del proyecto. part2.c : Este es el archivo que van a modificar en la parte 2 del proyecto. Ustedes NO pueden crear otros archivos ni crear archivos de cabecera .h . Si necesitan agregar funciones de ayuda, por favor col\u00f3quenlas en los archivos C correspondientes ( utils.c , part1.c , part2.c ). Si ustedes no siguen estas recomendaciones, su c\u00f3digo no va a compilar en el autograder y obtendr\u00e1n 0 como nota . Otros archivos que necesitan consultar detenidamente para entender el proyecto: type.h : Archivo de cabecera que tiene los tipos de datos que ustedes van a utilizar. Makefile : Para compilar y probar su c\u00f3digo. riscvcode/* : Archivos para hacer algunas pruebas. utils.h : Archivo que contiene el formato de las instrucciones a ser utilizadas en la parte 1 del proyecto. Archivos que no es necesario que los revisen, pero si son curiosos: riscv.h : tiene declaraciones de funciones que se utilizan en la parte 1 y 2 del proyecto. riscv.c : programa encargado de probar la parte 1 y 2 del proyecto, el simulador como tal. El emulador de RISC-V \u00b6 Los archivos proporcionados en el repositorio que crearon con GitHub Classroom son la base para un emulador de RISC-V. Primero, ustedes deber\u00e1n agregar c\u00f3digo en part1.c y utils.c para imprimir las instrucciones en ensamblador correspondientes al c\u00f3digo de m\u00e1quina (binario). Una vez realizaron esto, ustedes completar\u00e1n el programa agregando c\u00f3digo en el archivo parte2.c para ejecutar cada instrucci\u00f3n (incluyendo los accesos a memoria). Su simulador debe de ser capaz de entender cada una de las instrucciones siguientes ya codificadas en c\u00f3digo de m\u00e1quina (binario), nosotros ya les damos una tabla de los tipos de instrucciones que debe de ser capaz de manejar su emulador. Es muy IMPORTANTE que ustedes lean y entiendan las definiciones encontradas en types.h antes de empezar su proyecto. Si tiene alguna duda, o encuentran algo que no entiendan respecto a las mismas consulten el cap\u00edtulo 6 de K&R, que habla sobre estructuras, bitfields y uniones . Set de Instrucciones \u00b6 El set de instrucciones que su emulador debe soportar esta listado a continuaci\u00f3n. Toda la informaci\u00f3n ac\u00e1 es copiada desde RISC-V green card , como ayuda adicional pueden utilizar la hoja proporcionada anteriormente. Tipo R \u00b6 FORMATO DE UNA INSTRUCCI\u00d3N DE TIPO R R-TYPE funct7 rs2 rs1 funct3 rd opcode Bits 7 5 5 3 5 7 INTRUCCIONES TIPO R (OPCODE 0x33) INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N add rd , rs1 , rs2 0x0 0x00 R [ rd ] < - R [ rs1 ] + R [ rs2 ] mul rd , rs1 , rs2 0x0 0x01 R [ rd ] < -( R [ rs1 ] * R [ rs2 ]) [31:0] sub rd , rs1 , rs2 0x0 0x20 R [ rd ] < - R [ rs1 ] - R [ rs2 ] sll rd , rs1 , rs2 0x1 0x00 R [ rd ] < - R [ rs1 ] < < R [ rs2 ] mulh rd , rs1 , rs2 0x1 0x01 R [ rd ] < -( R [ rs1 ] * R [ rs2 ]) [63:32] slt rd , rs1 , rs2 0x2 0x00 R [ rd ] < -( R [ rs1 ] < R [ rs2 ]) ? 1 : 0 xor rd , rs1 , rs2 0x4 0x00 R [ rd ] < - R [ rs1 ] ^ R [ rs2 ] div rd , rs1 , rs2 0x4 0x01 R [ rd ] < - R [ rs1 ] / R [ rs2 ] srl rd , rs1 , rs2 0x5 0x00 R [ rd ] < - R [ rs1 ] >> R [ rs2 ] sra rd , rs1 , rs2 0x5 0x20 R [ rd ] < - R [ rs1 ] >> R [ rs2 ] or rd , rs1 , rs2 0x6 0x00 R [ rd ] < - R [ rs1 ] | R [ rs2 ] rem rd , rs1 , rs2 0x6 0x01 R [ rd ] < - R [ rs1 ] % R [ rs2 ] and rd , rs1 , rs2 0x7 0x00 R [ rd ] < - R [ rs1 ] & R [ rs2 ] Tipo I \u00b6 FORMATO DE UNA INSTRUCCI\u00d3N DE TIPO I I-TYPE imm[11:0] rs1 funct3 rd opcode Bits 12 5 3 5 7 INTRUCCIONES TIPO I (OPCODE 0x03) INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N lb rd, offset ( rs1 ) 0x0 R [ rd ]<- SignExt(Mem( R [ rs1 ] + offset , byte )) lh rd, offset ( rs1 ) 0x1 R [ rd ]<- SignExt(Mem( R [ rs1 ] + offset , half )) lw rd, offset ( rs1 ) 0x2 R [ rd ]<- Mem( R [ rs1 ] + offset , word ) INTRUCCIONES TIPO I (OPCODE 0x13) INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N addi rd, rs1, imm 0x0 R [ rd ]<- R [ rs1 ] + imm slli rd, rs1, imm 0x1 0x00 R [ rd ]<- R [ rs1 ] << imm slti rd, rs1, imm 0x2 R [ rd ]<- ( R [ rs1 ] < imm ) ? 1 : 0 xori rd, rs1, imm 0x4 R [ rd ]<- R [ rs1 ] ^ imm srli rd, rs1, imm 0x5 0x00 R [ rd ]<- R [ rs1 ] >> imm srai rd, rs1, imm 0x5 0x20 R [ rd ]<- R [ rs1 ] >> imm ori rd, rs1, imm 0x6 R [ rd ]<- R [ rs1 ] | imm andi rd, rs1, imm 0x7 R [ rd ]<- R [ rs1 ] & imm INTRUCCIONES TIPO I (OPCODE 0x67) INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N jalr 0x0 R [ rd ]<- PC + 4 PC <- R [ rs1 ] + imm INTRUCCIONES TIPO I (OPCODE 0x73) INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N ecall 0x0 0x000 (Transfiere el control al Sistema Operativo) a0 = 1 imprime el valor contenido en a1 como entero. a0 = 10 es exit o un indicador de final de c\u00f3digo. Tipo S \u00b6 FORMATO DE UNA INSTRUCCI\u00d3N DE TIPO S S-TYPE imm[11:5] rs2 rs1 funct3 imm[4:0] opcode Bits 7 5 5 3 5 7 INTRUCCIONES TIPO S (OPCODE 0x23) INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N sb rs2 , offset ( rs1 ) 0x0 Mem( R [ rs1 ] + offset )<- R [ rs2 ][7:0] sh rs2 , offset ( rs1 ) 0x1 Mem( R [ rs1 ] + offset )<- R [ rs2 ][15:0] sw rs2 , offset ( rs1 ) 0x2 Mem( R [ rs1 ] + offset )<- R [ rs2 ] Tipo SB \u00b6 FORMATO DE UNA INSTRUCCI\u00d3N DE TIPO SB SB-TYPE imm[12] imm[10:5] rs2 rs1 funct3 imm[4:1] imm[11] opcode Bits 1 6 5 5 3 4 1 7 INTRUCCIONES TIPO SB (OPCODE 0x63) INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N beq rs1 , rs2 , offset 0x0 if( R [ rs1 ] == R [ rs2 ]) PC <- PC + { offset , 1b'0} bne rs1 , rs2 , offset 0x1 if( R [ rs1 ] != R [ rs2 ]) PC <- PC + { offset , 1b'0} Tipo U \u00b6 FORMATO DE UNA INSTRUCCI\u00d3N DE TIPO U U-TYPE imm[31:12] rd opcode Bits 20 5 7 INTRUCCIONES TIPO U (OPCODE 0x17) INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N auipc rd , offset R [ rd ]<- PC + { offset , 12b'0} INTRUCCIONES TIPO U (OPCODE 0x37) INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N lui rd , offset R [ rd ]<- { offset , 12b'0} Tipo UJ \u00b6 FORMATO DE UNA INSTRUCCI\u00d3N DE TIPO UJ UJ-TYPE imm[20] imm[10:1] imm[11] imm[19:12] rd opcode Bits 1 10 1 8 5 7 INTRUCCIONES TIPO UJ (OPCODE 0x6F) INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N jal rd , imm R [ rd ]<- PC + 4 PC <- PC + { imm , 1b'0} Al igual que la arquitectura RISC-V normal, el sistema RISC-V que est\u00e1n implementando es little-endian. Esto significa que cuando se le da un valor compuesto de m\u00faltiples bytes, el byte menos significativo se almacena en la direcci\u00f3n m\u00e1s baja. Consulten la p\u00e1gina B-43 de P&H (4\u00aa edici\u00f3n) para obtener informaci\u00f3n sobre endianness. Estructura del C\u00f3digo \u00b6 El c\u00f3digo base que les fue proporcionado funciona de la siguiente manera: Lee los programas en c\u00f3digo de m\u00e1quina que se encuentran en la memoria (Empezando en la direcci\u00f3n 0x01000 ). Para \"ejecutar\" el programa este es pasado como un par\u00e1metro en la l\u00ednea de comandos. Cada programa tiene 1 MiB de memoria y la unidad m\u00ednima de direccionamiento son los bytes. Todos los registros de RISC-V son inicializados en 0 y el program counter ( pc ) hacia la direcci\u00f3n 0x01000 . Las \u00fanicas excepciones a las inicializaciones antes mencionadas son el stack pointer ( sp ) que tiene un valor inicial de 0xEFFFF y el global pointer ( gp ) que tiene un valor inicial de 0x03000 . En el contexto de su emulador, el global pointer hace referencia a la secci\u00f3n est\u00e1tica de su memoria. Los registros y el program counter est\u00e1n definidos en el Processor struct definido en types.h . Se definieron banderas con las cuales puede manejar la interacci\u00f3n con el usuario. Dependiendo de la opci\u00f3n especificada en la l\u00ednea de comandos, el simulador mostrar\u00e1 un dissassembly dump ( -d ) o se ejecutar\u00e1 el programa. Habr\u00e1 m\u00e1s informaci\u00f3n sobre las opciones de l\u00ednea de comandos m\u00e1s adelante. Lo que prosigue es qu\u00e9 entra al flujo de simulaci\u00f3n principal, el cual ejecuta una \u00fanica instrucci\u00f3n repetitivamente hasta que la simulaci\u00f3n se completa. La ejecuci\u00f3n de una instrucci\u00f3n realiza las siguientes tareas: Trae una instrucci\u00f3n desde la memoria, usando el pc como direcci\u00f3n ( fetch ). Examina el opcode/funct3 para determinar que instrucci\u00f3n es ( decode ). Ejecuta la instrucci\u00f3n y actualiza el pc ( execute ). Opciones en la l\u00ednea de comandos \u00b6 -i : Corre el simulador en modo interactivo ( interactive ), es decir que se ejecutar\u00e1 una instrucci\u00f3n a la vez al presionar enter . Cada instrucci\u00f3n es mostrada en su forma desensamblada. -t : Corre el simulador en modo rastreo ( trace ), en donde cada instrucci\u00f3n es ejecutada y es mostrada al usuario. -r : Indica al simulador que imprima el contenido de los 32 registros despu\u00e9s de que es ejecutada cada instrucci\u00f3n. Esta opci\u00f3n es m\u00e1s \u00fatil cuando se combina con la opci\u00f3n -i . -d : Indica al simulador que desensamble el programa completo y que termine sin ejecutarlo. En la parte 2, ustedes deber\u00e1n implementar los siguientes m\u00e9todos: El execute_instruction() . Los diferentes executes . El store() . El load() . Para cuando ustedes hayan terminado la implementaci\u00f3n de todos los m\u00e9todos, el simulador ser\u00e1 capaz de manejar todas las instrucciones de la tabla anterior. Parte 1 \u00b6 Su primera tarea es implementar un desensamblador al completar el m\u00e9todo decode_instruction() en el archivo part1.c junto a otras funciones. El objetivo de esta parte, es que, dada una instrucci\u00f3n en c\u00f3digo de m\u00e1quina, ustedes deber\u00e1n traducirla a su instrucci\u00f3n en lenguaje ensamblador RISC-V (e.g. add x1, x2, x3 ). Para esta parte, ustedes no har\u00e1n referencia a los registros por nombre sino por su n\u00famero (como est\u00e1 definido en RISC-V Green Card ). Cuando impriman las instrucciones revisen las constantes definidas en utils.h , ya que estas le pueden ser de ayuda. M\u00e1s detalles sobre los requisitos a continuaci\u00f3n. Requisitos Parte 1 \u00b6 Imprimir el nombre de la instrucci\u00f3n. Si la instrucci\u00f3n tiene argumentos, impriman un tab ( \\t ). Imprimir todos los argumentos, siguiendo el orden y formato dado en la columna de INSTRUCCI\u00d3N de las tablas mostradas anteriormente. Los argumentos son generalmente separados por coma ( lw / sw , usan tambi\u00e9n par\u00e9ntesis), pero no est\u00e1n separados por espacios. Ustedes encontrar\u00e1n de ayuda revisar el archivo utils.h . Los registros que son argumentos de la instrucci\u00f3n son impresos con una x seguido del n\u00famero de registro, en decimal. (e.g. x0 o x31 ) Todos los inmediatos deben mostrarse como un n\u00famero decimal con signo. Los corrimientos (e.g. para slli ) se imprimen como n\u00fameros decimales sin signo (e.g. 0 a 31). Imprimir un salto de l\u00ednea ( \\n ) al final de cada instrucci\u00f3n. Se estar\u00e1 utilizando un autograder para calificar esta tarea. Si su output difiere del nuestro debido a errores de formato, no obtendr\u00e1n nota. Nosotros les proveemos ciertas pruebas. Sin embargo, dado que estas pruebas s\u00f3lo cubren un subconjunto de todos los escenarios posibles, pasar estas pruebas no significa que su c\u00f3digo est\u00e9 libre de errores. Ustedes deber\u00e1n identificar todos los casos y probarlos. Para completar la funcionalidad de la parte 1, deben de completar lo siguiente: La funci\u00f3n decode_instrucction() en part1.c . Los diferentes writes en part1.c . Los diferentes prints en part1.c . Los diferentes gets en utils.c . La funci\u00f3n bitSigner en utils.c . Ustedes deben de correr el test brindado para su proyecto escribiendo el siguiente comando. Si ustedes pasan el test, ver\u00e1n en su consola el siguiente output. make part1 gcc -g -Wall -Werror -Wfatal-errors -O2 -o riscv utils.c part1.c part2.c riscv.c simple_disasm TEST PASSED! multiply_disasm TEST PASSED! random_disasm TEST PASSED! ---------Disassembly Tests Complete--------- Probando la Parte 1 \u00b6 Los tests que se les dieron no eval\u00faan todas las posibilidades, por eso mismo ustedes pueden ( deben ) crear sus propios archivos de prueba para comprobar su funcionamiento. Si ustedes desean correr un test en espec\u00edfico, pueden usar el siguiente comando para ello: make [test_name]_disasm Para crear sus propios archivos de prueba, primero necesitar\u00e1n crear c\u00f3digo de m\u00e1quina. Para ello pueden ayudarse de V-Sim o hacerlo a mano. Si utilizan V-Sim tienen que crear un archivo .s y hacer un dump del c\u00f3digo de m\u00e1quina utilizando la bandera -code en la terminal: vsim <archivo>.s -code <test_name>.input Ustedes deben de poner las instrucciones en c\u00f3digo de m\u00e1quina en un archivo llamado [test_name].input y colocar el archivo dentro de la carpeta riscvcode/code . Despu\u00e9s, deben crear el archivo [test_name].solution el cual contendr\u00e1 las instrucciones que se espera obtener; y colocar el archivo en la carpeta riscvcode/ref . Vean las pruebas proporcionadas como ejemplos de este tipo de archivos. Para integrar sus pruebas en el comando make , ustedes deben de modificar el archivo Makefile . En la l\u00ednea 4 del archivo Makefile , donde dice ASM_TESTS , agregar [test_name] a la lista con espacios entre cada nombre de archivo: SOURCES := utils.c part1.c part2.c riscv.c HEADERS := types.h utils.h riscv.h ASM_TESTS := simple multiply random test_name Si su instrucci\u00f3n desensamblada no es igual a la esperada, ustedes obtendr\u00e1n la diferencia entre el output esperado y el output que devolvieron. Aseg\u00farense de al menos pasar esta prueba antes de enviar la parte 1 al autograder . # Output Esperado < 00001014 : lui x8, 1048575 --- # Output Devuelto > 00001014 : Invalid Instruction: 0xfffff437 Calificaci\u00f3n Parte 1 \u00b6 Recuerden que para la primera parte, s\u00f3lo deben modificar los archivos part1.c y utils.c , esto representa el 50% de su nota as\u00ed que pueden enviar sus archivos al autograder para verificar su nota de esta parte haciendo: ./submit <TOKEN> Si est\u00e1n trabajando en pareja, AMBOS miembros del grupo tienen que hacer el submit con su respectivo TOKEN . Parte 2 \u00b6 Su segunda tarea es completar el emulador implementando los m\u00e9todos execute_instruction() . execute() 's, store() y load() del archivo part2.c . Requisitos \u00b6 Esta parte consistir\u00e1 en implementar la funcionalidad de cada instrucci\u00f3n. Por favor implementen las funciones descritas a continuaci\u00f3n (todas en part2.c ): execute_instruction() : Ejecuta la instrucci\u00f3n proporcionada como par\u00e1metro. Esta deber\u00eda modificar los registros apropiados, realizar las llamadas a memoria necesarias y actualizar el program counter para apuntar a la siguiente instrucci\u00f3n a ejecutar. execute() 's: Varias funciones de ayuda para ser llamadas en ciertas condiciones para ciertas instrucciones. Es su decisi\u00f3n usar estas funciones, pero estas les ayudar\u00e1n de gran manera a organizar el c\u00f3digo. store() : Toma una direcci\u00f3n, un tama\u00f1o, un valor y almacena los primeros (tama\u00f1o) bytes del valor dado en la direcci\u00f3n dada. Cuando el par\u00e1metro check_align sea 1 se validar\u00e1n las restricciones de alineaci\u00f3n. Se incluy\u00f3 este par\u00e1metro para obligar a las instrucciones a estar alineadas por palabras de memoria (word-aligned). Cuando implementen el store y load , este par\u00e1metro debe ser 0 dado que RISC-V no hace cumplir las restricciones de alineaci\u00f3n. load() : Toma una direcci\u00f3n y un tama\u00f1o, y retorna los siguientes (tama\u00f1o) bytes empezando en la direcci\u00f3n dada. El check_align funciona de la misma forma que en store() . Probando la Parte 2 \u00b6 Les hemos adjuntado un self-checking assembly test que prueba varias de las instruciones, sin embargo este test no es exhaustivo y no prueba todas las instrucciones. A continuaci\u00f3n, se ejemplifica c\u00f3mo ejecutar los test (el output es de una soluci\u00f3n correcta). make part2 gcc -Wall -Werror -Wfatal-errors -O2 -o riscv utils.c part1.c part2.c riscv.c simple_execute TEST PASSED! multiply_execute TEST PASSED! random_execute TEST PASSED! -----------Execute Tests Complete----------- Lo m\u00e1s probable es que ustedes tenga errores al empezar a realizar la parte 2, entonces prueben el modo de rastreo ( trace ) descrito en Opciones en la l\u00ednea de Comandos . Les hemos dado unos cuantos tests m\u00e1s, adem\u00e1s de la posibilidad de escribir test propios. Como en la parte 1, ustedes tendr\u00e1n que crear archivos .input . Sin embargo, para la parte 2, ustedes deber\u00e1n nombrar su archivo soluci\u00f3n con una extensi\u00f3n .trace . Creen el nuevo archivo de ensamblador en el directorio riscvcode (utilicen riscvcode/simple.input como plantilla). Agreguen el nombre base del test a la lista de ASM_TESTS en el Makefile . Para realizar esto s\u00f3lo agreguen [test_name] al final de la l\u00ednea 4. Ahora compilen su test de ensamblador y ejec\u00fatenlo escribiendo el siguiente comando: make [ test_name ] _execute Ustedes pueden, y en efecto deben, escribir sus propios test para probar instrucciones espec\u00edficas y todos los posibles casos. Adem\u00e1s, ustedes deben compilar y probar su c\u00f3digo despu\u00e9s de cada grupo de instrucciones implementadas. De lo contrario ser\u00e1 muy dif\u00edcil probar su proyecto si esperan hasta el final. Calificaci\u00f3n Parte 2 \u00b6 Al completar esta parte ustedes s\u00f3lo deber\u00edan haber modificado los archivos part1.c , part2.c y utils.c , deben realizar commit de todos los cambios realizados y enviar el link de su repositorio por medio del GES. Para obtener su nota completa tienen que hacer: ./submit <TOKEN> Si est\u00e1n trabajando en pareja, AMBOS miembros del grupo tienen que hacer el submit con su respectivo TOKEN . Preguntas Frecuentes \u00b6 1. \u00bfC\u00f3mo puedo empezar? \u00b6 Lo mejor es revisar types.h y analizar la estructura Instruction para empezar a trabajar en la parte1.c , por ejemplo como acceder a cada campo de cada diferente tipo de instrucci\u00f3n y al opcode tambi\u00e9n. Por ejemplo, para acceder al opcode pueden utilizar: instruction . opcode siendo instruction una variable que representa una \"instancia\" de la estructura Instruction . Luego de esto, pueden ver c\u00f3mo accediendo a estos campos pueden decodificar la instrucci\u00f3n y as\u00ed lograr imprimirla. 2. En mi m\u00e1quina local saco 100% y en el autograder 0, \u00bfpor qu\u00e9? \u00b6 Al trabajar con uniones y estructuras de C y al utilizar la bandera -O2 pueden pasar cosas muy raras, una de ellas es el strict aliasing , por eso les recomendamos probar su c\u00f3digo en la m\u00e1quina virtual que les proporcionamos, as\u00ed est\u00e1n totalmente seguros de que c\u00f3digo funciona correctamente. 3. Me da Floating-point Exception (core dumped) al hacer algunas operaciones aritm\u00e9ticas, \u00bfpor qu\u00e9? \u00b6 Generalmente esto se da porque se divide por 0 o hay overflow utilizando variables enteras con signo. Por ejemplo: Division por 0 int x = 10 ; int y = 0 ; int z = x / y ; Overflow int32_t x = 0x80000000 ; int32_t y = 0xffffffff ; int32_t z = x / y ; La soluci\u00f3n para la divisi\u00f3n por 0 es simplemente tienen que devolver -1 como dice la especificaci\u00f3n de RISC-V y para el residuo devolver el primer argumento de la operaci\u00f3n, en el caso de overflow la soluci\u00f3n es castear las variables a un tipo con m\u00e1s bytes: int32_t z = ( int32_t )(( int64_t ) x / ( int64_t ) y ); 4. En la parte 1 el formato nunca es el esperado por las pruebas, \u00bfpor qu\u00e9? \u00b6 Seguramente no est\u00e1n utilizando el formato correcto, les recomendamos que utilicen las siguientes macros para imprimir las instrucciones que se encuentran en el archivo utils.h : #define RTYPE_FORMAT \"%s\\tx%d, x%d, x%d\\n\" #define ITYPE_FORMAT \"%s\\tx%d, x%d, %d\\n\" #define JALR_FORMAT \"jalr\\tx%d, x%d, %d\\n\" #define MEM_FORMAT \"%s\\tx%d, %d(x%d)\\n\" #define AUIPC_FORMAT \"auipc\\tx%d, %d\\n\" #define LUI_FORMAT \"lui\\tx%d, %d\\n\" #define JAL_FORMAT \"jal\\tx%d, %d\\n\" #define BRANCH_FORMAT \"%s\\tx%d, x%d, %d\\n\" #define ECALL_FORMAT \"ecall\\n\" 5. \u00bfPuedo crear mis propias funciones? \u00b6 S\u00ed, siempre y cuando estas est\u00e9n declaradas, ya sea en part1.c , part2.c o utils.c , ya que son los \u00fanicos archivos que se env\u00edan al autograder. Sin embargo, NO est\u00e1 permitido renombrar o eliminar las siguientes funciones : /* archivo part1.c */ void decode_instruction ( Instruction i ); /* archivo part2.c */ void execute_instruction ( Instruction instruction , Processor * processor , Byte * memory ); void store ( Byte * memory , Address address , Alignment alignment , Word value , int ); Word load ( Byte * memory , Address address , Alignment alignment , int ); Ya que el simulador riscv.c espera que estas est\u00e9n definidas.","title":"1: C y RISC-V"},{"location":"projs/proj01/#proyecto-1-c-y-risc-v","text":"","title":"Proyecto 1: C y RISC-V"},{"location":"projs/proj01/#objetivos","text":"Mejorar sus habilidades de programaci\u00f3n en C. Conocer algunos de los detalles de RISC-V. Prepararse para lo que viene m\u00e1s adelante en el curso.","title":"Objetivos"},{"location":"projs/proj01/#requisitos-de-conocimiento","text":"Para realizar este proyecto ustedes tienen que tener claros algunos conceptos, de lo contrario ser\u00e1 bastante dif\u00edcil e inc\u00f3modo empezar a trabajar. Les recomendamos que antes de empezar est\u00e9n totalmente seguros que dominan al 100% los siguientes puntos: Operaciones binarias en C ( xor , or , and , etc). Operaciones aritm\u00e9ticas con signo y sin signo en C. Type casting en C. Control de flujo en C ( switch , if , etc). Funciones en C. Entender qu\u00e9 son las estructuras ( struct ) en C. Entender c\u00f3mo funcionan las uniones ( union ) en C. Uso correcto de printf . Entender la estructura del set de instrucciones de RISC-V. Programar en lenguaje ensamblador RISC-V. Si creen que no tienen claro alguno de estos temas al 100%, por favor no duden en ir a consultar los libros y material correspondiente del curso, por ejemplo K&R , es indispensable. En Lecturas Recomendadas pueden encontrar algunas lecturas que tocan los puntos antes mencionados y otras cosas que tambi\u00e9n les pueden servir, nunca est\u00e1 dem\u00e1s tener un poco m\u00e1s de informaci\u00f3n.","title":"Requisitos de Conocimiento"},{"location":"projs/proj01/#lecturas-recomendadas","text":"Gu\u00eda Pr\u00e1ctica de RISC-V: 2 K&R: 6 P&H: B-43","title":"Lecturas Recomendadas"},{"location":"projs/proj01/#introduccion","text":"En este proyecto ustedes deben de crear un emulador que pueda ejecutar un subconjunto de instrucciones de RISC-V . Ustedes se van a encargar de hacer un programa que decodifique y ejecute varias instrucciones de RISC-V. Consid\u00e9renlo como una versi\u00f3n miniatura de V-Sim .","title":"Introducci\u00f3n"},{"location":"projs/proj01/#risc-v-green-card","text":"Aqu\u00ed hay dos RISC-V Green Cards que pueden consultar y as\u00ed tener m\u00e1s herramientras que les pueden ayudar a completar el proyecto. La primera tiene informaci\u00f3n acerca de los opcodes y otros campos de cada uno de los diferentes formatos de instrucci\u00f3n, por lo que esta ser\u00eda su mejor opci\u00f3n.","title":"RISC-V Green Card"},{"location":"projs/proj01/#preparacion","text":"Antes de comenzar aseg\u00farense de que hayan le\u00eddo y comprendido todas las instrucciones del proyecto de principio a fin . Si tienen alguna pregunta pueden consultar la secci\u00f3n de preguntas frecuentes para ver si ya ha sido resuelta, de lo contrario por favor dir\u00edjanse a Slack y pregunten en los canales correspondientes. Para comenzar con el proyecto, primero tienen que tener todos los archivos base, estos se encuentran aqu\u00ed . Tienen permitido trabajar en parejas o de forma individual, por lo que al aceptar la asignaci\u00f3n les preguntar\u00e1 si desean crear un grupo nuevo o unirse a uno ya existente. Si crean un grupo nuevo, ingresen un nombre que represente al grupo y que no est\u00e9 ya en los grupos existentes. Si desean unirse a un grupo ya creado, tienen que buscar el nombre del grupo y pulsar el bot\u00f3n que dice join Tienen que tener mucho cuidado al unirse a un grupo ya existente, ya que esto no se puede cambiar despu\u00e9s, adem\u00e1s lo consideraremos como PLAGIO si lo realizan de manera incorrecta, ya que al hacer esto pueden tener acceso al repositorio del otro miembro del grupo. Ya sea que se unan o creen un nuevo grupo, al finalizar el proceso les crear\u00e1 autom\u00e1ticamente un repositorio con una extensi\u00f3n que termina con su nombre de grupo. Ya habiendo hecho todo eso, pueden ejecutar los siguientes comandos abriendo una terminal ( CTRL + T ): git clone <link del repositorio> NOTA : Tienen que reemplazar <link del repositorio> con el link del repositorio que se cre\u00f3.","title":"Preparaci\u00f3n"},{"location":"projs/proj01/#estructura-del-proyecto","text":"Cuando hayan clonado el repositorio, se van a encontrar con los siguientes archivos: Makefile part1.c part2.c README.md riscv.c riscvcode/ riscv.h submit types.h utils.c utils.h Los \u00fanicos archivos que pueden modificar son: part1.c : Este es el archivo que van a modificar en la parte 1 del proyecto. utils.c : Archivo auxiliar que contendr\u00e1 varias funciones de ayuda para la parte 1 y 2 del proyecto. part2.c : Este es el archivo que van a modificar en la parte 2 del proyecto. Ustedes NO pueden crear otros archivos ni crear archivos de cabecera .h . Si necesitan agregar funciones de ayuda, por favor col\u00f3quenlas en los archivos C correspondientes ( utils.c , part1.c , part2.c ). Si ustedes no siguen estas recomendaciones, su c\u00f3digo no va a compilar en el autograder y obtendr\u00e1n 0 como nota . Otros archivos que necesitan consultar detenidamente para entender el proyecto: type.h : Archivo de cabecera que tiene los tipos de datos que ustedes van a utilizar. Makefile : Para compilar y probar su c\u00f3digo. riscvcode/* : Archivos para hacer algunas pruebas. utils.h : Archivo que contiene el formato de las instrucciones a ser utilizadas en la parte 1 del proyecto. Archivos que no es necesario que los revisen, pero si son curiosos: riscv.h : tiene declaraciones de funciones que se utilizan en la parte 1 y 2 del proyecto. riscv.c : programa encargado de probar la parte 1 y 2 del proyecto, el simulador como tal.","title":"Estructura del Proyecto"},{"location":"projs/proj01/#el-emulador-de-risc-v","text":"Los archivos proporcionados en el repositorio que crearon con GitHub Classroom son la base para un emulador de RISC-V. Primero, ustedes deber\u00e1n agregar c\u00f3digo en part1.c y utils.c para imprimir las instrucciones en ensamblador correspondientes al c\u00f3digo de m\u00e1quina (binario). Una vez realizaron esto, ustedes completar\u00e1n el programa agregando c\u00f3digo en el archivo parte2.c para ejecutar cada instrucci\u00f3n (incluyendo los accesos a memoria). Su simulador debe de ser capaz de entender cada una de las instrucciones siguientes ya codificadas en c\u00f3digo de m\u00e1quina (binario), nosotros ya les damos una tabla de los tipos de instrucciones que debe de ser capaz de manejar su emulador. Es muy IMPORTANTE que ustedes lean y entiendan las definiciones encontradas en types.h antes de empezar su proyecto. Si tiene alguna duda, o encuentran algo que no entiendan respecto a las mismas consulten el cap\u00edtulo 6 de K&R, que habla sobre estructuras, bitfields y uniones .","title":"El emulador de RISC-V"},{"location":"projs/proj01/#set-de-instrucciones","text":"El set de instrucciones que su emulador debe soportar esta listado a continuaci\u00f3n. Toda la informaci\u00f3n ac\u00e1 es copiada desde RISC-V green card , como ayuda adicional pueden utilizar la hoja proporcionada anteriormente.","title":"Set de Instrucciones"},{"location":"projs/proj01/#tipo-r","text":"FORMATO DE UNA INSTRUCCI\u00d3N DE TIPO R R-TYPE funct7 rs2 rs1 funct3 rd opcode Bits 7 5 5 3 5 7 INTRUCCIONES TIPO R (OPCODE 0x33) INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N add rd , rs1 , rs2 0x0 0x00 R [ rd ] < - R [ rs1 ] + R [ rs2 ] mul rd , rs1 , rs2 0x0 0x01 R [ rd ] < -( R [ rs1 ] * R [ rs2 ]) [31:0] sub rd , rs1 , rs2 0x0 0x20 R [ rd ] < - R [ rs1 ] - R [ rs2 ] sll rd , rs1 , rs2 0x1 0x00 R [ rd ] < - R [ rs1 ] < < R [ rs2 ] mulh rd , rs1 , rs2 0x1 0x01 R [ rd ] < -( R [ rs1 ] * R [ rs2 ]) [63:32] slt rd , rs1 , rs2 0x2 0x00 R [ rd ] < -( R [ rs1 ] < R [ rs2 ]) ? 1 : 0 xor rd , rs1 , rs2 0x4 0x00 R [ rd ] < - R [ rs1 ] ^ R [ rs2 ] div rd , rs1 , rs2 0x4 0x01 R [ rd ] < - R [ rs1 ] / R [ rs2 ] srl rd , rs1 , rs2 0x5 0x00 R [ rd ] < - R [ rs1 ] >> R [ rs2 ] sra rd , rs1 , rs2 0x5 0x20 R [ rd ] < - R [ rs1 ] >> R [ rs2 ] or rd , rs1 , rs2 0x6 0x00 R [ rd ] < - R [ rs1 ] | R [ rs2 ] rem rd , rs1 , rs2 0x6 0x01 R [ rd ] < - R [ rs1 ] % R [ rs2 ] and rd , rs1 , rs2 0x7 0x00 R [ rd ] < - R [ rs1 ] & R [ rs2 ]","title":"Tipo R"},{"location":"projs/proj01/#tipo-i","text":"FORMATO DE UNA INSTRUCCI\u00d3N DE TIPO I I-TYPE imm[11:0] rs1 funct3 rd opcode Bits 12 5 3 5 7 INTRUCCIONES TIPO I (OPCODE 0x03) INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N lb rd, offset ( rs1 ) 0x0 R [ rd ]<- SignExt(Mem( R [ rs1 ] + offset , byte )) lh rd, offset ( rs1 ) 0x1 R [ rd ]<- SignExt(Mem( R [ rs1 ] + offset , half )) lw rd, offset ( rs1 ) 0x2 R [ rd ]<- Mem( R [ rs1 ] + offset , word ) INTRUCCIONES TIPO I (OPCODE 0x13) INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N addi rd, rs1, imm 0x0 R [ rd ]<- R [ rs1 ] + imm slli rd, rs1, imm 0x1 0x00 R [ rd ]<- R [ rs1 ] << imm slti rd, rs1, imm 0x2 R [ rd ]<- ( R [ rs1 ] < imm ) ? 1 : 0 xori rd, rs1, imm 0x4 R [ rd ]<- R [ rs1 ] ^ imm srli rd, rs1, imm 0x5 0x00 R [ rd ]<- R [ rs1 ] >> imm srai rd, rs1, imm 0x5 0x20 R [ rd ]<- R [ rs1 ] >> imm ori rd, rs1, imm 0x6 R [ rd ]<- R [ rs1 ] | imm andi rd, rs1, imm 0x7 R [ rd ]<- R [ rs1 ] & imm INTRUCCIONES TIPO I (OPCODE 0x67) INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N jalr 0x0 R [ rd ]<- PC + 4 PC <- R [ rs1 ] + imm INTRUCCIONES TIPO I (OPCODE 0x73) INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N ecall 0x0 0x000 (Transfiere el control al Sistema Operativo) a0 = 1 imprime el valor contenido en a1 como entero. a0 = 10 es exit o un indicador de final de c\u00f3digo.","title":"Tipo I"},{"location":"projs/proj01/#tipo-s","text":"FORMATO DE UNA INSTRUCCI\u00d3N DE TIPO S S-TYPE imm[11:5] rs2 rs1 funct3 imm[4:0] opcode Bits 7 5 5 3 5 7 INTRUCCIONES TIPO S (OPCODE 0x23) INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N sb rs2 , offset ( rs1 ) 0x0 Mem( R [ rs1 ] + offset )<- R [ rs2 ][7:0] sh rs2 , offset ( rs1 ) 0x1 Mem( R [ rs1 ] + offset )<- R [ rs2 ][15:0] sw rs2 , offset ( rs1 ) 0x2 Mem( R [ rs1 ] + offset )<- R [ rs2 ]","title":"Tipo S"},{"location":"projs/proj01/#tipo-sb","text":"FORMATO DE UNA INSTRUCCI\u00d3N DE TIPO SB SB-TYPE imm[12] imm[10:5] rs2 rs1 funct3 imm[4:1] imm[11] opcode Bits 1 6 5 5 3 4 1 7 INTRUCCIONES TIPO SB (OPCODE 0x63) INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N beq rs1 , rs2 , offset 0x0 if( R [ rs1 ] == R [ rs2 ]) PC <- PC + { offset , 1b'0} bne rs1 , rs2 , offset 0x1 if( R [ rs1 ] != R [ rs2 ]) PC <- PC + { offset , 1b'0}","title":"Tipo SB"},{"location":"projs/proj01/#tipo-u","text":"FORMATO DE UNA INSTRUCCI\u00d3N DE TIPO U U-TYPE imm[31:12] rd opcode Bits 20 5 7 INTRUCCIONES TIPO U (OPCODE 0x17) INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N auipc rd , offset R [ rd ]<- PC + { offset , 12b'0} INTRUCCIONES TIPO U (OPCODE 0x37) INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N lui rd , offset R [ rd ]<- { offset , 12b'0}","title":"Tipo U"},{"location":"projs/proj01/#tipo-uj","text":"FORMATO DE UNA INSTRUCCI\u00d3N DE TIPO UJ UJ-TYPE imm[20] imm[10:1] imm[11] imm[19:12] rd opcode Bits 1 10 1 8 5 7 INTRUCCIONES TIPO UJ (OPCODE 0x6F) INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N jal rd , imm R [ rd ]<- PC + 4 PC <- PC + { imm , 1b'0} Al igual que la arquitectura RISC-V normal, el sistema RISC-V que est\u00e1n implementando es little-endian. Esto significa que cuando se le da un valor compuesto de m\u00faltiples bytes, el byte menos significativo se almacena en la direcci\u00f3n m\u00e1s baja. Consulten la p\u00e1gina B-43 de P&H (4\u00aa edici\u00f3n) para obtener informaci\u00f3n sobre endianness.","title":"Tipo UJ"},{"location":"projs/proj01/#estructura-del-codigo","text":"El c\u00f3digo base que les fue proporcionado funciona de la siguiente manera: Lee los programas en c\u00f3digo de m\u00e1quina que se encuentran en la memoria (Empezando en la direcci\u00f3n 0x01000 ). Para \"ejecutar\" el programa este es pasado como un par\u00e1metro en la l\u00ednea de comandos. Cada programa tiene 1 MiB de memoria y la unidad m\u00ednima de direccionamiento son los bytes. Todos los registros de RISC-V son inicializados en 0 y el program counter ( pc ) hacia la direcci\u00f3n 0x01000 . Las \u00fanicas excepciones a las inicializaciones antes mencionadas son el stack pointer ( sp ) que tiene un valor inicial de 0xEFFFF y el global pointer ( gp ) que tiene un valor inicial de 0x03000 . En el contexto de su emulador, el global pointer hace referencia a la secci\u00f3n est\u00e1tica de su memoria. Los registros y el program counter est\u00e1n definidos en el Processor struct definido en types.h . Se definieron banderas con las cuales puede manejar la interacci\u00f3n con el usuario. Dependiendo de la opci\u00f3n especificada en la l\u00ednea de comandos, el simulador mostrar\u00e1 un dissassembly dump ( -d ) o se ejecutar\u00e1 el programa. Habr\u00e1 m\u00e1s informaci\u00f3n sobre las opciones de l\u00ednea de comandos m\u00e1s adelante. Lo que prosigue es qu\u00e9 entra al flujo de simulaci\u00f3n principal, el cual ejecuta una \u00fanica instrucci\u00f3n repetitivamente hasta que la simulaci\u00f3n se completa. La ejecuci\u00f3n de una instrucci\u00f3n realiza las siguientes tareas: Trae una instrucci\u00f3n desde la memoria, usando el pc como direcci\u00f3n ( fetch ). Examina el opcode/funct3 para determinar que instrucci\u00f3n es ( decode ). Ejecuta la instrucci\u00f3n y actualiza el pc ( execute ).","title":"Estructura del C\u00f3digo"},{"location":"projs/proj01/#opciones-en-la-linea-de-comandos","text":"-i : Corre el simulador en modo interactivo ( interactive ), es decir que se ejecutar\u00e1 una instrucci\u00f3n a la vez al presionar enter . Cada instrucci\u00f3n es mostrada en su forma desensamblada. -t : Corre el simulador en modo rastreo ( trace ), en donde cada instrucci\u00f3n es ejecutada y es mostrada al usuario. -r : Indica al simulador que imprima el contenido de los 32 registros despu\u00e9s de que es ejecutada cada instrucci\u00f3n. Esta opci\u00f3n es m\u00e1s \u00fatil cuando se combina con la opci\u00f3n -i . -d : Indica al simulador que desensamble el programa completo y que termine sin ejecutarlo. En la parte 2, ustedes deber\u00e1n implementar los siguientes m\u00e9todos: El execute_instruction() . Los diferentes executes . El store() . El load() . Para cuando ustedes hayan terminado la implementaci\u00f3n de todos los m\u00e9todos, el simulador ser\u00e1 capaz de manejar todas las instrucciones de la tabla anterior.","title":"Opciones en la l\u00ednea de comandos"},{"location":"projs/proj01/#parte-1","text":"Su primera tarea es implementar un desensamblador al completar el m\u00e9todo decode_instruction() en el archivo part1.c junto a otras funciones. El objetivo de esta parte, es que, dada una instrucci\u00f3n en c\u00f3digo de m\u00e1quina, ustedes deber\u00e1n traducirla a su instrucci\u00f3n en lenguaje ensamblador RISC-V (e.g. add x1, x2, x3 ). Para esta parte, ustedes no har\u00e1n referencia a los registros por nombre sino por su n\u00famero (como est\u00e1 definido en RISC-V Green Card ). Cuando impriman las instrucciones revisen las constantes definidas en utils.h , ya que estas le pueden ser de ayuda. M\u00e1s detalles sobre los requisitos a continuaci\u00f3n.","title":"Parte 1"},{"location":"projs/proj01/#requisitos-parte-1","text":"Imprimir el nombre de la instrucci\u00f3n. Si la instrucci\u00f3n tiene argumentos, impriman un tab ( \\t ). Imprimir todos los argumentos, siguiendo el orden y formato dado en la columna de INSTRUCCI\u00d3N de las tablas mostradas anteriormente. Los argumentos son generalmente separados por coma ( lw / sw , usan tambi\u00e9n par\u00e9ntesis), pero no est\u00e1n separados por espacios. Ustedes encontrar\u00e1n de ayuda revisar el archivo utils.h . Los registros que son argumentos de la instrucci\u00f3n son impresos con una x seguido del n\u00famero de registro, en decimal. (e.g. x0 o x31 ) Todos los inmediatos deben mostrarse como un n\u00famero decimal con signo. Los corrimientos (e.g. para slli ) se imprimen como n\u00fameros decimales sin signo (e.g. 0 a 31). Imprimir un salto de l\u00ednea ( \\n ) al final de cada instrucci\u00f3n. Se estar\u00e1 utilizando un autograder para calificar esta tarea. Si su output difiere del nuestro debido a errores de formato, no obtendr\u00e1n nota. Nosotros les proveemos ciertas pruebas. Sin embargo, dado que estas pruebas s\u00f3lo cubren un subconjunto de todos los escenarios posibles, pasar estas pruebas no significa que su c\u00f3digo est\u00e9 libre de errores. Ustedes deber\u00e1n identificar todos los casos y probarlos. Para completar la funcionalidad de la parte 1, deben de completar lo siguiente: La funci\u00f3n decode_instrucction() en part1.c . Los diferentes writes en part1.c . Los diferentes prints en part1.c . Los diferentes gets en utils.c . La funci\u00f3n bitSigner en utils.c . Ustedes deben de correr el test brindado para su proyecto escribiendo el siguiente comando. Si ustedes pasan el test, ver\u00e1n en su consola el siguiente output. make part1 gcc -g -Wall -Werror -Wfatal-errors -O2 -o riscv utils.c part1.c part2.c riscv.c simple_disasm TEST PASSED! multiply_disasm TEST PASSED! random_disasm TEST PASSED! ---------Disassembly Tests Complete---------","title":"Requisitos Parte 1"},{"location":"projs/proj01/#probando-la-parte-1","text":"Los tests que se les dieron no eval\u00faan todas las posibilidades, por eso mismo ustedes pueden ( deben ) crear sus propios archivos de prueba para comprobar su funcionamiento. Si ustedes desean correr un test en espec\u00edfico, pueden usar el siguiente comando para ello: make [test_name]_disasm Para crear sus propios archivos de prueba, primero necesitar\u00e1n crear c\u00f3digo de m\u00e1quina. Para ello pueden ayudarse de V-Sim o hacerlo a mano. Si utilizan V-Sim tienen que crear un archivo .s y hacer un dump del c\u00f3digo de m\u00e1quina utilizando la bandera -code en la terminal: vsim <archivo>.s -code <test_name>.input Ustedes deben de poner las instrucciones en c\u00f3digo de m\u00e1quina en un archivo llamado [test_name].input y colocar el archivo dentro de la carpeta riscvcode/code . Despu\u00e9s, deben crear el archivo [test_name].solution el cual contendr\u00e1 las instrucciones que se espera obtener; y colocar el archivo en la carpeta riscvcode/ref . Vean las pruebas proporcionadas como ejemplos de este tipo de archivos. Para integrar sus pruebas en el comando make , ustedes deben de modificar el archivo Makefile . En la l\u00ednea 4 del archivo Makefile , donde dice ASM_TESTS , agregar [test_name] a la lista con espacios entre cada nombre de archivo: SOURCES := utils.c part1.c part2.c riscv.c HEADERS := types.h utils.h riscv.h ASM_TESTS := simple multiply random test_name Si su instrucci\u00f3n desensamblada no es igual a la esperada, ustedes obtendr\u00e1n la diferencia entre el output esperado y el output que devolvieron. Aseg\u00farense de al menos pasar esta prueba antes de enviar la parte 1 al autograder . # Output Esperado < 00001014 : lui x8, 1048575 --- # Output Devuelto > 00001014 : Invalid Instruction: 0xfffff437","title":"Probando la Parte 1"},{"location":"projs/proj01/#calificacion-parte-1","text":"Recuerden que para la primera parte, s\u00f3lo deben modificar los archivos part1.c y utils.c , esto representa el 50% de su nota as\u00ed que pueden enviar sus archivos al autograder para verificar su nota de esta parte haciendo: ./submit <TOKEN> Si est\u00e1n trabajando en pareja, AMBOS miembros del grupo tienen que hacer el submit con su respectivo TOKEN .","title":"Calificaci\u00f3n Parte 1"},{"location":"projs/proj01/#parte-2","text":"Su segunda tarea es completar el emulador implementando los m\u00e9todos execute_instruction() . execute() 's, store() y load() del archivo part2.c .","title":"Parte 2"},{"location":"projs/proj01/#requisitos","text":"Esta parte consistir\u00e1 en implementar la funcionalidad de cada instrucci\u00f3n. Por favor implementen las funciones descritas a continuaci\u00f3n (todas en part2.c ): execute_instruction() : Ejecuta la instrucci\u00f3n proporcionada como par\u00e1metro. Esta deber\u00eda modificar los registros apropiados, realizar las llamadas a memoria necesarias y actualizar el program counter para apuntar a la siguiente instrucci\u00f3n a ejecutar. execute() 's: Varias funciones de ayuda para ser llamadas en ciertas condiciones para ciertas instrucciones. Es su decisi\u00f3n usar estas funciones, pero estas les ayudar\u00e1n de gran manera a organizar el c\u00f3digo. store() : Toma una direcci\u00f3n, un tama\u00f1o, un valor y almacena los primeros (tama\u00f1o) bytes del valor dado en la direcci\u00f3n dada. Cuando el par\u00e1metro check_align sea 1 se validar\u00e1n las restricciones de alineaci\u00f3n. Se incluy\u00f3 este par\u00e1metro para obligar a las instrucciones a estar alineadas por palabras de memoria (word-aligned). Cuando implementen el store y load , este par\u00e1metro debe ser 0 dado que RISC-V no hace cumplir las restricciones de alineaci\u00f3n. load() : Toma una direcci\u00f3n y un tama\u00f1o, y retorna los siguientes (tama\u00f1o) bytes empezando en la direcci\u00f3n dada. El check_align funciona de la misma forma que en store() .","title":"Requisitos"},{"location":"projs/proj01/#probando-la-parte-2","text":"Les hemos adjuntado un self-checking assembly test que prueba varias de las instruciones, sin embargo este test no es exhaustivo y no prueba todas las instrucciones. A continuaci\u00f3n, se ejemplifica c\u00f3mo ejecutar los test (el output es de una soluci\u00f3n correcta). make part2 gcc -Wall -Werror -Wfatal-errors -O2 -o riscv utils.c part1.c part2.c riscv.c simple_execute TEST PASSED! multiply_execute TEST PASSED! random_execute TEST PASSED! -----------Execute Tests Complete----------- Lo m\u00e1s probable es que ustedes tenga errores al empezar a realizar la parte 2, entonces prueben el modo de rastreo ( trace ) descrito en Opciones en la l\u00ednea de Comandos . Les hemos dado unos cuantos tests m\u00e1s, adem\u00e1s de la posibilidad de escribir test propios. Como en la parte 1, ustedes tendr\u00e1n que crear archivos .input . Sin embargo, para la parte 2, ustedes deber\u00e1n nombrar su archivo soluci\u00f3n con una extensi\u00f3n .trace . Creen el nuevo archivo de ensamblador en el directorio riscvcode (utilicen riscvcode/simple.input como plantilla). Agreguen el nombre base del test a la lista de ASM_TESTS en el Makefile . Para realizar esto s\u00f3lo agreguen [test_name] al final de la l\u00ednea 4. Ahora compilen su test de ensamblador y ejec\u00fatenlo escribiendo el siguiente comando: make [ test_name ] _execute Ustedes pueden, y en efecto deben, escribir sus propios test para probar instrucciones espec\u00edficas y todos los posibles casos. Adem\u00e1s, ustedes deben compilar y probar su c\u00f3digo despu\u00e9s de cada grupo de instrucciones implementadas. De lo contrario ser\u00e1 muy dif\u00edcil probar su proyecto si esperan hasta el final.","title":"Probando la Parte 2"},{"location":"projs/proj01/#calificacion-parte-2","text":"Al completar esta parte ustedes s\u00f3lo deber\u00edan haber modificado los archivos part1.c , part2.c y utils.c , deben realizar commit de todos los cambios realizados y enviar el link de su repositorio por medio del GES. Para obtener su nota completa tienen que hacer: ./submit <TOKEN> Si est\u00e1n trabajando en pareja, AMBOS miembros del grupo tienen que hacer el submit con su respectivo TOKEN .","title":"Calificaci\u00f3n Parte 2"},{"location":"projs/proj01/#preguntas-frecuentes","text":"","title":"Preguntas Frecuentes"},{"location":"projs/proj01/#1-como-puedo-empezar","text":"Lo mejor es revisar types.h y analizar la estructura Instruction para empezar a trabajar en la parte1.c , por ejemplo como acceder a cada campo de cada diferente tipo de instrucci\u00f3n y al opcode tambi\u00e9n. Por ejemplo, para acceder al opcode pueden utilizar: instruction . opcode siendo instruction una variable que representa una \"instancia\" de la estructura Instruction . Luego de esto, pueden ver c\u00f3mo accediendo a estos campos pueden decodificar la instrucci\u00f3n y as\u00ed lograr imprimirla.","title":"1. \u00bfC\u00f3mo puedo empezar?"},{"location":"projs/proj01/#2-en-mi-maquina-local-saco-100-y-en-el-autograder-0-por-que","text":"Al trabajar con uniones y estructuras de C y al utilizar la bandera -O2 pueden pasar cosas muy raras, una de ellas es el strict aliasing , por eso les recomendamos probar su c\u00f3digo en la m\u00e1quina virtual que les proporcionamos, as\u00ed est\u00e1n totalmente seguros de que c\u00f3digo funciona correctamente.","title":"2. En mi m\u00e1quina local saco 100% y en el autograder 0, \u00bfpor qu\u00e9?"},{"location":"projs/proj01/#3-me-da-floating-point-exception-core-dumped-al-hacer-algunas-operaciones-aritmeticas-por-que","text":"Generalmente esto se da porque se divide por 0 o hay overflow utilizando variables enteras con signo. Por ejemplo: Division por 0 int x = 10 ; int y = 0 ; int z = x / y ; Overflow int32_t x = 0x80000000 ; int32_t y = 0xffffffff ; int32_t z = x / y ; La soluci\u00f3n para la divisi\u00f3n por 0 es simplemente tienen que devolver -1 como dice la especificaci\u00f3n de RISC-V y para el residuo devolver el primer argumento de la operaci\u00f3n, en el caso de overflow la soluci\u00f3n es castear las variables a un tipo con m\u00e1s bytes: int32_t z = ( int32_t )(( int64_t ) x / ( int64_t ) y );","title":"3. Me da Floating-point Exception (core dumped) al hacer algunas operaciones aritm\u00e9ticas, \u00bfpor qu\u00e9?"},{"location":"projs/proj01/#4-en-la-parte-1-el-formato-nunca-es-el-esperado-por-las-pruebas-por-que","text":"Seguramente no est\u00e1n utilizando el formato correcto, les recomendamos que utilicen las siguientes macros para imprimir las instrucciones que se encuentran en el archivo utils.h : #define RTYPE_FORMAT \"%s\\tx%d, x%d, x%d\\n\" #define ITYPE_FORMAT \"%s\\tx%d, x%d, %d\\n\" #define JALR_FORMAT \"jalr\\tx%d, x%d, %d\\n\" #define MEM_FORMAT \"%s\\tx%d, %d(x%d)\\n\" #define AUIPC_FORMAT \"auipc\\tx%d, %d\\n\" #define LUI_FORMAT \"lui\\tx%d, %d\\n\" #define JAL_FORMAT \"jal\\tx%d, %d\\n\" #define BRANCH_FORMAT \"%s\\tx%d, x%d, %d\\n\" #define ECALL_FORMAT \"ecall\\n\"","title":"4. En la parte 1 el formato nunca es el esperado por las pruebas, \u00bfpor qu\u00e9?"},{"location":"projs/proj01/#5-puedo-crear-mis-propias-funciones","text":"S\u00ed, siempre y cuando estas est\u00e9n declaradas, ya sea en part1.c , part2.c o utils.c , ya que son los \u00fanicos archivos que se env\u00edan al autograder. Sin embargo, NO est\u00e1 permitido renombrar o eliminar las siguientes funciones : /* archivo part1.c */ void decode_instruction ( Instruction i ); /* archivo part2.c */ void execute_instruction ( Instruction instruction , Processor * processor , Byte * memory ); void store ( Byte * memory , Address address , Alignment alignment , Word value , int ); Word load ( Byte * memory , Address address , Alignment alignment , int ); Ya que el simulador riscv.c espera que estas est\u00e9n definidas.","title":"5. \u00bfPuedo crear mis propias funciones?"}]}