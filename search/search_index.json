{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bienvenidos a Estructura de M\u00e1quinas \u00b6 Bienvenidos a CC3","title":"Inicio"},{"location":"#bienvenidos-a-estructura-de-maquinas","text":"Bienvenidos a CC3","title":"Bienvenidos a Estructura de M\u00e1quinas"},{"location":"labs/lab00/","text":"Lab 0 - Git y Representaci\u00f3n de N\u00fameros \u00b6 Objetivos \u00b6 Aprender a usar git y crear cuenta de GitHub. Comenzar a trabajar con n\u00fameros binarios. Lecturas \u00b6 Complemente lo visto en clase leyendo COD: 2.4 Ejercicio 1: Cuenta de GitHub \u00b6 Por favor lean las siguientes instrucciones cuidadosamente antes de seguir con el laboratorio. La mayor parte de los problemas que tienen los estudiantes durante este laboratorio se pueden prevenir siguiendo atentamente los pasos que se indican. Para este curso necesitaremos que utilicen git , un sistema de control de versiones distribuido . Los sistemas de control de versiones son las mejores herramientas para compartir y almacenar c\u00f3digo a comparaci\u00f3n de mandar correos con archivos adjuntos, utilizar memorias flash, o incluso compartir documentos mediante DropBox o Google Docs. Creando una cuenta en Github \u00b6 Si ya tiene una cuenta de Github creada con su correo de galileo.edu (por ejemplo, por CC1 y CC2) puede utilizar esa. Si a\u00fan no tiene, cree una aqu\u00ed . Configurando git \u00b6 Ahora que ya tenemos una cuenta, vamos a configurar git para que sepa qui\u00e9nes son. Abran una terminal ctrl alt t y ejecuten los siguientes comandos listados abajo, reemplazando NOMBRE con su nombre y apellido (entre comillas) y CORREO con la direcci\u00f3n de correo que utilizar\u00f3n para registrarse en GitHub. git config --global user.name \"NOMBRE\" git config --global user.email \"CORREO\" IMPORTANTE: Si cambia de m\u00e1quina, debe repetir estas configuraciones en la nueva. Por ejemplo, si usa distintas computadoras en el laboratorio debe configurar esto antes de comenzar a trabajar. Definiciones \u00fatiles \u00b6 A continuaci\u00f3n algunos conceptos importantes relacionados con el uso de git, es importante que los entienda para garantizar su \u00e9xito en el curso. Un remote es su c\u00f3digo almacenado de forma remota, en nuestro caso almacenado en Github. M\u00e1s adelante cuando lleguemos a proyectos, su remote ser\u00e1 compartido con su pareja. A lo largo de este curso, estar\u00e1n sincronizando el c\u00f3digo que tienen en su computadora personal, con su remote en Github. Uno de los principales prop\u00f3sitos del remote es funcionar como una copia de seguridad, de forma que si algo le sucede a nuestra m\u00e1quina podemos recuperar nuestro c\u00f3digo en vez de comenzar desde cero nuevamente. Solo podremos recuperar el c\u00f3digo al cu\u00e1l ya le hayamos hecho push . Cuando lleguemos a trabajar en pareja, a trav\u00e9s de push podremos subir cambios hacia el remote y luego nuestra pareja podr\u00e1 hacer pull para obtener estos cambios. Obteniendo los archivos \u00b6 Para obtener sus archivos base visite el siguiente link. https://classroom.github.com/a/u494VVLh All\u00ed debe aceptar la asignaci\u00f3n para que su repositorio sea creado. Al hacerlo, tendr\u00e1 un repositorio con un link como este. https://github.com/cc-3/lab00-2023-MI_USUARIO.git Abra una terminal y navegue en ella hacia el lugar donde quiera colocar su laboratorio. Como es la primera vez que traeremos informaci\u00f3n del remote hacia nuestra computadora, usaremos el comando clone . Recuerde cambiar MI_USUARIO por su usuario. git clone https://github.com/cc-3/lab00-2023-MI_USUARIO.git Al ejecutar el comando Github le pedir\u00e1 su \"contrase\u00f1a\", sin embargo desde hace un par de a\u00f1os ya no acepta contrase\u00f1as sino tokens, genere el suyo siguiendo los pasos que se indican en esta p\u00e1gina. https://docs.github.com/es/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token Tras haber realizado el clone exitosamente, tendr\u00e1 en su m\u00e1quina una carpeta con un par de archivos que usaremos en este lab. Haciendo push hacia Github \u00b6 Haremos un push de prueba antes de continuar. Asegurese de estar en la carpeta de su laboratorio (recuerde que en Linux usa el comando cd para moverse entre carpetas). Una vez se encuentre all\u00ed, cree un archivo que diga \"Hola Mundo\" ejecutando el siguiente comando. echo 'echo \"Hola Mundo\"' > hello.txt Ahora comprobamos el estado de nuestro repositorio. git status Lo que producir\u00e1 lo siguiente: On branch master No commits yet Untracked files: ( use \"git add <file>...\" to include in what will be committed ) hello.txt nothing added to commit but untracked files present ( use \"git add\" to track ) Git nos est\u00e1 diciendo que tenemos un archivo nuevo llamado hello.txt pero no lo hemos agregado. Lo agregaremos, realizaremos un commit y lo subiremos ejecutando los siguientes comandos (lo que aparece despu\u00e9s de # son solo comentarios). Un commit es equivalente a una versi\u00f3n de su c\u00f3digo. git add hello.txt # agrega el archivo hello.txt git commit -m \"mensaje del commit\" # ingrese un mensaje descriptivo sobre los cambios realizados git push origin master # aqu\u00ed hacemos el push Explicando un poco m\u00e1s los comandos de arriba. git add [archivo] le dir\u00e1 a git que han hecho cambios a ese archivo y que quieren que esos cambios se guarden en el siguiente commit (staging). git commit -m \"mensaje\" oficialmente guarda esos cambios que acaban de agregar, y crea un snapshot del contenido actual de todos los archivos en el repositorio. Si algo sale mal m\u00e1s adelante, ser\u00e1 posible revertir hacia esta versi\u00f3n. git push origin master manda todo el contenido del repositorio que est\u00e1 en el branch \"master\" al repositorio remoto \"origin\". Cuando estamos trabajando con git, si alguna vez no est\u00e1n seguros de algo, pero quieren asegurarse de que tienen una copia guardada del contenido actual de su c\u00f3digo, solo tienen que correr git add . y despu\u00e9s git commit en la terminal. Un \u00faltimo comando de git que pueden encontrar bastante util es git log . Pueden ejectuar este comando en la terminal y van a ver un historial o log de todos los commits que se han hecho (en el branch actual), incluyendo el tiempo y quien hizo el commit. Visite su repositorio en su navegador web, si ya puede ver su archivo hello.txt su push fue exitoso y ya puede continuar. Ejercicio 1: Dibujando con binario \u00b6 Vamos a utilizar n\u00fameros de 4 bits y usarlos para \"dibujar\". Si apilamos cinco n\u00fameros de 4 bits uno encima de otro en binario, podemos crear patrones e im\u00e1genes. Para ayudarlos a visualizar esto, pueden pensar que un bit en cero es blanco y un bit en uno es negro. Por ejemplo miren el siguiente patr\u00f3n de bits. Preguntas \u00b6 \u00bfCu\u00e1les son los cinco n\u00fameros en decimal (separados por una coma) que producen el patr\u00f3n de arriba? \u00bfCu\u00e1les son los cinco digitos en hexadecimal (separados por una coma) que producen el patr\u00f3n de arriba? \u00bfQu\u00e9 letra se dibuja con los siguientes n\u00fameros en decimal: 1,1,9,9,6? \u00bfQu\u00e9 letra se dibuja con el siguiente numero en hexadecimal: 0xF8F88? \u00bfCu\u00e1l es el numero en hexadecimal para dibujar la letra b (min\u00fascula)? En los archivos del laboratorio van a encontrar un archivo de texto ex3.txt con lo siguiente: 1: 2: 3: 4: 5: En este archivo tienen que colocar todas sus respuestas de las preguntas de arriba siguiendo ese formato por ejemplo un archivo valido ser\u00eda: 1:1,2,3,4,5 2:0x1,0x2,0x3,0x4,0x5 3:A 4:A 5:0xcafee Si ya contestaron todo y creen que est\u00e1 correcto pueden agregar los cambios, hacer commit y subirlo al repositorio remoto ejecutando los siguientes comandos en la terminal. git add ex1.txt git commit -m \"ex. 1 complete\" git push origin master Ejercicio 2: 1000 billetes de $1 \u00b6 Imaginen que tienen mil billetes de \\$1 y 10 sobres. Para este ejercicio tienen que encontrar una manera de poner una cantidad determinada de billetes de \\$1 en cada uno de los sobres de tal forma que, sin importar la cantidad de dinero que se les pida (entre \\$1 y \\$1000), simplemente entreguen una combinaci\u00f3n de los sobres y que siempre est\u00e9n seguros de que est\u00e1n dando la cantidad correcta. En los archivos del laboratorio hay un archivo de texto llamado ex4.txt en donde encontrar\u00e1n lo siguiente: a,b,c,d,e,f,g,h,i,j Cada una de las letras representa un sobre, tienen que reemplazar cada letra por la cantidad de billetes de \\$1 que crean correcta, esa cantidad tiene que ser positiva y mayor a cero. Recuerda que la suma de la cantidad de cada uno de los sobres tiene que ser igual a 1000 . Si ya contestaron todo y creen que est\u00e1 correcto pueden agregar los cambios, hacer commit y subirlo al repositorio remoto ejecutando los siguientes comandos en la terminal: git add ex2.txt git commit -m \"ex. 2 complete\" git push origin master Entrega y calificaci\u00f3n \u00b6 Revise en el navegador que sus push hayan sido exitosos, luego suba el link de su repositorio al GES. El link que subir\u00e1 debe verse similar a este https://github.com/cc-3/lab00-2023-MI_USUARIO.git . El GES tiene una opci\u00f3n para subir links, \u00fasela. No env\u00ede su link adentro de un txt, pdf, etc. de lo contrarion se le restar\u00e1n puntos.","title":"0: Git"},{"location":"labs/lab00/#lab-0-git-y-representacion-de-numeros","text":"","title":"Lab 0 - Git y Representaci\u00f3n de N\u00fameros"},{"location":"labs/lab00/#objetivos","text":"Aprender a usar git y crear cuenta de GitHub. Comenzar a trabajar con n\u00fameros binarios.","title":"Objetivos"},{"location":"labs/lab00/#lecturas","text":"Complemente lo visto en clase leyendo COD: 2.4","title":"Lecturas"},{"location":"labs/lab00/#ejercicio-1-cuenta-de-github","text":"Por favor lean las siguientes instrucciones cuidadosamente antes de seguir con el laboratorio. La mayor parte de los problemas que tienen los estudiantes durante este laboratorio se pueden prevenir siguiendo atentamente los pasos que se indican. Para este curso necesitaremos que utilicen git , un sistema de control de versiones distribuido . Los sistemas de control de versiones son las mejores herramientas para compartir y almacenar c\u00f3digo a comparaci\u00f3n de mandar correos con archivos adjuntos, utilizar memorias flash, o incluso compartir documentos mediante DropBox o Google Docs.","title":"Ejercicio 1: Cuenta de GitHub"},{"location":"labs/lab00/#creando-una-cuenta-en-github","text":"Si ya tiene una cuenta de Github creada con su correo de galileo.edu (por ejemplo, por CC1 y CC2) puede utilizar esa. Si a\u00fan no tiene, cree una aqu\u00ed .","title":"Creando una cuenta en Github"},{"location":"labs/lab00/#configurando-git","text":"Ahora que ya tenemos una cuenta, vamos a configurar git para que sepa qui\u00e9nes son. Abran una terminal ctrl alt t y ejecuten los siguientes comandos listados abajo, reemplazando NOMBRE con su nombre y apellido (entre comillas) y CORREO con la direcci\u00f3n de correo que utilizar\u00f3n para registrarse en GitHub. git config --global user.name \"NOMBRE\" git config --global user.email \"CORREO\" IMPORTANTE: Si cambia de m\u00e1quina, debe repetir estas configuraciones en la nueva. Por ejemplo, si usa distintas computadoras en el laboratorio debe configurar esto antes de comenzar a trabajar.","title":"Configurando git"},{"location":"labs/lab00/#definiciones-utiles","text":"A continuaci\u00f3n algunos conceptos importantes relacionados con el uso de git, es importante que los entienda para garantizar su \u00e9xito en el curso. Un remote es su c\u00f3digo almacenado de forma remota, en nuestro caso almacenado en Github. M\u00e1s adelante cuando lleguemos a proyectos, su remote ser\u00e1 compartido con su pareja. A lo largo de este curso, estar\u00e1n sincronizando el c\u00f3digo que tienen en su computadora personal, con su remote en Github. Uno de los principales prop\u00f3sitos del remote es funcionar como una copia de seguridad, de forma que si algo le sucede a nuestra m\u00e1quina podemos recuperar nuestro c\u00f3digo en vez de comenzar desde cero nuevamente. Solo podremos recuperar el c\u00f3digo al cu\u00e1l ya le hayamos hecho push . Cuando lleguemos a trabajar en pareja, a trav\u00e9s de push podremos subir cambios hacia el remote y luego nuestra pareja podr\u00e1 hacer pull para obtener estos cambios.","title":"Definiciones \u00fatiles"},{"location":"labs/lab00/#obteniendo-los-archivos","text":"Para obtener sus archivos base visite el siguiente link. https://classroom.github.com/a/u494VVLh All\u00ed debe aceptar la asignaci\u00f3n para que su repositorio sea creado. Al hacerlo, tendr\u00e1 un repositorio con un link como este. https://github.com/cc-3/lab00-2023-MI_USUARIO.git Abra una terminal y navegue en ella hacia el lugar donde quiera colocar su laboratorio. Como es la primera vez que traeremos informaci\u00f3n del remote hacia nuestra computadora, usaremos el comando clone . Recuerde cambiar MI_USUARIO por su usuario. git clone https://github.com/cc-3/lab00-2023-MI_USUARIO.git Al ejecutar el comando Github le pedir\u00e1 su \"contrase\u00f1a\", sin embargo desde hace un par de a\u00f1os ya no acepta contrase\u00f1as sino tokens, genere el suyo siguiendo los pasos que se indican en esta p\u00e1gina. https://docs.github.com/es/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token Tras haber realizado el clone exitosamente, tendr\u00e1 en su m\u00e1quina una carpeta con un par de archivos que usaremos en este lab.","title":"Obteniendo los archivos"},{"location":"labs/lab00/#haciendo-push-hacia-github","text":"Haremos un push de prueba antes de continuar. Asegurese de estar en la carpeta de su laboratorio (recuerde que en Linux usa el comando cd para moverse entre carpetas). Una vez se encuentre all\u00ed, cree un archivo que diga \"Hola Mundo\" ejecutando el siguiente comando. echo 'echo \"Hola Mundo\"' > hello.txt Ahora comprobamos el estado de nuestro repositorio. git status Lo que producir\u00e1 lo siguiente: On branch master No commits yet Untracked files: ( use \"git add <file>...\" to include in what will be committed ) hello.txt nothing added to commit but untracked files present ( use \"git add\" to track ) Git nos est\u00e1 diciendo que tenemos un archivo nuevo llamado hello.txt pero no lo hemos agregado. Lo agregaremos, realizaremos un commit y lo subiremos ejecutando los siguientes comandos (lo que aparece despu\u00e9s de # son solo comentarios). Un commit es equivalente a una versi\u00f3n de su c\u00f3digo. git add hello.txt # agrega el archivo hello.txt git commit -m \"mensaje del commit\" # ingrese un mensaje descriptivo sobre los cambios realizados git push origin master # aqu\u00ed hacemos el push Explicando un poco m\u00e1s los comandos de arriba. git add [archivo] le dir\u00e1 a git que han hecho cambios a ese archivo y que quieren que esos cambios se guarden en el siguiente commit (staging). git commit -m \"mensaje\" oficialmente guarda esos cambios que acaban de agregar, y crea un snapshot del contenido actual de todos los archivos en el repositorio. Si algo sale mal m\u00e1s adelante, ser\u00e1 posible revertir hacia esta versi\u00f3n. git push origin master manda todo el contenido del repositorio que est\u00e1 en el branch \"master\" al repositorio remoto \"origin\". Cuando estamos trabajando con git, si alguna vez no est\u00e1n seguros de algo, pero quieren asegurarse de que tienen una copia guardada del contenido actual de su c\u00f3digo, solo tienen que correr git add . y despu\u00e9s git commit en la terminal. Un \u00faltimo comando de git que pueden encontrar bastante util es git log . Pueden ejectuar este comando en la terminal y van a ver un historial o log de todos los commits que se han hecho (en el branch actual), incluyendo el tiempo y quien hizo el commit. Visite su repositorio en su navegador web, si ya puede ver su archivo hello.txt su push fue exitoso y ya puede continuar.","title":"Haciendo push hacia Github"},{"location":"labs/lab00/#ejercicio-1-dibujando-con-binario","text":"Vamos a utilizar n\u00fameros de 4 bits y usarlos para \"dibujar\". Si apilamos cinco n\u00fameros de 4 bits uno encima de otro en binario, podemos crear patrones e im\u00e1genes. Para ayudarlos a visualizar esto, pueden pensar que un bit en cero es blanco y un bit en uno es negro. Por ejemplo miren el siguiente patr\u00f3n de bits.","title":"Ejercicio 1: Dibujando con binario"},{"location":"labs/lab00/#preguntas","text":"\u00bfCu\u00e1les son los cinco n\u00fameros en decimal (separados por una coma) que producen el patr\u00f3n de arriba? \u00bfCu\u00e1les son los cinco digitos en hexadecimal (separados por una coma) que producen el patr\u00f3n de arriba? \u00bfQu\u00e9 letra se dibuja con los siguientes n\u00fameros en decimal: 1,1,9,9,6? \u00bfQu\u00e9 letra se dibuja con el siguiente numero en hexadecimal: 0xF8F88? \u00bfCu\u00e1l es el numero en hexadecimal para dibujar la letra b (min\u00fascula)? En los archivos del laboratorio van a encontrar un archivo de texto ex3.txt con lo siguiente: 1: 2: 3: 4: 5: En este archivo tienen que colocar todas sus respuestas de las preguntas de arriba siguiendo ese formato por ejemplo un archivo valido ser\u00eda: 1:1,2,3,4,5 2:0x1,0x2,0x3,0x4,0x5 3:A 4:A 5:0xcafee Si ya contestaron todo y creen que est\u00e1 correcto pueden agregar los cambios, hacer commit y subirlo al repositorio remoto ejecutando los siguientes comandos en la terminal. git add ex1.txt git commit -m \"ex. 1 complete\" git push origin master","title":"Preguntas"},{"location":"labs/lab00/#ejercicio-2-1000-billetes-de-1","text":"Imaginen que tienen mil billetes de \\$1 y 10 sobres. Para este ejercicio tienen que encontrar una manera de poner una cantidad determinada de billetes de \\$1 en cada uno de los sobres de tal forma que, sin importar la cantidad de dinero que se les pida (entre \\$1 y \\$1000), simplemente entreguen una combinaci\u00f3n de los sobres y que siempre est\u00e9n seguros de que est\u00e1n dando la cantidad correcta. En los archivos del laboratorio hay un archivo de texto llamado ex4.txt en donde encontrar\u00e1n lo siguiente: a,b,c,d,e,f,g,h,i,j Cada una de las letras representa un sobre, tienen que reemplazar cada letra por la cantidad de billetes de \\$1 que crean correcta, esa cantidad tiene que ser positiva y mayor a cero. Recuerda que la suma de la cantidad de cada uno de los sobres tiene que ser igual a 1000 . Si ya contestaron todo y creen que est\u00e1 correcto pueden agregar los cambios, hacer commit y subirlo al repositorio remoto ejecutando los siguientes comandos en la terminal: git add ex2.txt git commit -m \"ex. 2 complete\" git push origin master","title":"Ejercicio 2: 1000 billetes de $1"},{"location":"labs/lab00/#entrega-y-calificacion","text":"Revise en el navegador que sus push hayan sido exitosos, luego suba el link de su repositorio al GES. El link que subir\u00e1 debe verse similar a este https://github.com/cc-3/lab00-2023-MI_USUARIO.git . El GES tiene una opci\u00f3n para subir links, \u00fasela. No env\u00ede su link adentro de un txt, pdf, etc. de lo contrarion se le restar\u00e1n puntos.","title":"Entrega y calificaci\u00f3n"},{"location":"labs/lab01/","text":"Lab 1 - Introducci\u00f3n a C \u00b6 Objetivos \u00b6 Aprender c\u00f3mo compilar y ejecutar un programa en C. Examinar diferentes tipos de control de flujo en C. Ganar experiencia manipulando bits Preparaci\u00f3n \u00b6 Para obtener sus archivos base visite el siguiente link. https://classroom.github.com/a/Bh5XIp-g All\u00ed debe aceptar la asignaci\u00f3n para que su repositorio sea creado. Al hacerlo, tendr\u00e1 un repositorio con un link como este. https://github.com/cc-3/lab01-2023-MI_USUARIO.git Abra una terminal y navegue en ella hacia el lugar donde quiera colocar su laboratorio. Como es la primera vez que traeremos informaci\u00f3n del remote hacia nuestra computadora, usaremos el comando clone . Recuerde cambiar MI_USUARIO por su usuario. git clone https://github.com/cc-3/lab01-2023-MI_USUARIO.git Al ejecutar el comando Github le pedir\u00e1 su \"contrase\u00f1a\", sin embargo desde hace un par de a\u00f1os ya no acepta contrase\u00f1as sino tokens, genere el suyo siguiendo los pasos que se indican en esta p\u00e1gina. Puede usar el mismo token de la semana pasada (bueno... depende de la fecha de vencimiento que le haya colocado) https://docs.github.com/es/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token Tras haber realizado el clone exitosamente, tendr\u00e1 en su m\u00e1quina una carpeta con todos los archivos que usaremos en este lab. Recordatorio: compilar y ejecutar un programa de C \u00b6 En este laboratorio, estaremos usando el programa gcc para compilar programas en c. La manera m\u00e1s sencilla de ejecutar gcc es la siguiente: gcc program.c Esto compila el archivo program.c y crea un archivo ejecutable llamado a.out . Si tienen experiencia en Java, pueden m\u00e1s o menos considerar a gcc como el equivalente en C de javac . Este archivo se puede ejecutar con el siguiente comando: ./a.out El archivo ejecutable es a.out , as\u00ed que, \u00bfqu\u00e9 rayos es eso de punto y diagonal? La respuesta: cuando quieren ejecutar un ejecutable, es necesario preponer una ruta de archivo para distinguirlo de un comando como python (no se utiliza ./python ). El punto se refiere al \"directorio actual\". De paso, dos puntos (..) se referir\u00edan al directorio que est\u00e1 un nivel arriba. gcc tiene varias opciones (o argumentos) de l\u00ednea de comandos, los cuales les recomendamos explorar. En este laboratorio, vamos a estar usando solamente -o, que se usa para especificar el nombre del ejecutable que gcc genera. Usando -o, se utilizar\u00edan estos comandos para compilar program.c en un archivo llamado program , y ejecutarlo. Eso nos sirve si no queremos que todos nuestros archivos ejecutables se llamen a.out . gcc -o program program.c ./program Ejercicio 1: Programa simple de C \u00b6 En este ejercicio, veremos un ejemplo de definiciones macro del preprocesador. Las macros pueden ser un tema complicado, pero en general, la forma en que funcionan es que antes de que un archivo en C sea compilado, las constantes macro son reemplazadas exactamente por el valor al que se refieren. En este ejercicio, estaremos usando macros exclusivamente como constantes globales. Aqu\u00ed definimos CONSTANT_NAME como un literal_value (una literal entera). Noten que solo hay 1 espacio separando el nombre del valor. #define CONSTANT_NAME LITERAL_VALUE Ahora, vean el c\u00f3digo en eccentric.c (en el repo). Note que al inicio hay cuatro macros, v0 a v3 . Cambie sus valores y vea como esto cambia el output del programa. Su tarea: Modificando s\u00f3lo estos cuatro valores, hagan que el programa produzca el siguiente mensaje: gcc -o eccentric eccentric.c ./eccentric Welcome to C: ==================== Hola Hola Hola Luis El gato dice miau Hay m\u00faltiples combinaciones de valores en las macros que consiguen este resultado. El reto para ustedes en este ejercicio es: Consideren el m\u00ednimo n\u00famero de distintos valores que v0 a v3 puedan tener que den el resultado correcto. Como ejemplo, el m\u00e1ximo te\u00f3rico es cuatro (cuando todos son diferentes uno de otro). Cuando ya hayan logrado esto, pueden actualizar el archivo en su repositorio en Github, de esta manera: git add eccentric.c git commit -m \"Ejercicio 1 terminado\" git push -u origin master Ejercicio 2: Operando bits \u00b6 Para este inciso, su trabajo es completar los archivos ex2/get_bit.c , ex2/set_bit.c y ex2/flip_bit.c de manera que las funciones cumplan con la tarea que su nombre indica (obtener un bit, actualizar el valor de un bit, negar un bit). Para ello deber\u00e1n utilizar las operaciones de bits b\u00e1sicas: and (&), or (|), xor (^), not (~) y los corrimientos a la derecha (>>) y a la izquierda (<<). Lea la secci\u00f3n 2.9 de K&R si a\u00fan no ha llegado. Para este ejercicio no pueden utilizar condicionales ni ciclos . Es decir, no escriba ning\u00fan if, else, do, while, for, switch o case. No intente enga\u00f1arnos, revisaremos que no los use. El autograder analiza su c\u00f3digo de todas formas... NOTA IMPORTANTE: Considerar que n es un valor que inicia en la posici\u00f3n cero. Su bit menos significativo (es decir hasta la derecha) es el bit 0, y su bit m\u00e1s significativo (es decir hasta la izquierda) ser\u00eda su bit 31. // Return the nth bit of x. // Assume 0 <= n <= 31 unsigned get_bit ( unsigned x , unsigned n ); // Set the nth bit of the value of x to v. // Assume 0 <= n <= 31, and v is 0 or 1 void set_bit ( unsigned * x , unsigned n , unsigned v ); // Flip the nth bit of the value of x. // Assume 0 <= n <= 31 void flip_bit ( unsigned * x , unsigned n ); Idea para set_bit(): La parte complicada es no que no sabemos el valor del bit antes de cambiarlo. Recuerde las propiedades que vi\u00f3 en Info 1: x & 0 = 0 x & 1 = x x | 0 = x x | 1 = 1 \u00bfQu\u00e9 tal si usamos dos de estas propiedades para resolver el ejercicio? Idea para flip_bit(): \u00bfHabr\u00e1 otra operaci\u00f3n bitwise con propiedades similares al and y or que a\u00fan no haya usado? Quiz\u00e1s hay alguna que me haga la tarea... Una vez terminen de editar las funciones, pueden compilar y correr el c\u00f3digo con: make bit_ops ./bit_ops Ahora estamos usando un Makefile, el cu\u00e1l tiene dentro comandos que nos facilitan la compilaci\u00f3n. Al ejecutar ./bit_ops se imprimir\u00e1 el resultado de algunas pruebas. Si tienen curiosidad pueden revisar con libertad la carpeta tests que contiene las pruebas que se van a realizar en cada ejercicio de este laboratorio y que reflejan bastante lo que evaluar\u00e1 el autograder, por ejemplo el archivo que se utiliza para este ejercicio es tests/bit_ops_test.c . Al terminar su ejercicio recuerde hacer add + commit + push hacia Github. Ejercicio 3: Registro de Corrimiento con Retroalimentaci\u00f3n Lineal \u00b6 En este ejercicio deben de implementar una funci\u00f3n que compute la siguiente iteraci\u00f3n de un registro de corrimiento de retroalimentaci\u00f3n lineal (LFSR por sus siglas en ingl\u00e9s). Algunas aplicaciones que utilizan LFSRs son: televisi\u00f3n digital, tel\u00e9fonos con acceso m\u00faltiple por divisi\u00f3n de c\u00f3digo, Ethernet, USB 3.0 y mucho m\u00e1s. Esta funci\u00f3n deber\u00e1 generar n\u00fameros pseudo-aleatorios utilizando operadores binarios. Si quiere conocer un poco m\u00e1s, puede visitar el siguiente link de Wikipedia . En el archivo ex3/lfsr_calculate.c deben de completar la funci\u00f3n lfsr_calculate() de manera que realice lo siguiente: Diagrama del hardware \u00b6 Explicaci\u00f3n del diagrama \u00b6 En cada llamada de lfsr_calculate() deben de correr el contenido del registro un bit hacia la derecha. Este corrimiento no es el l\u00f3gico ni aritm\u00e9tico que ya conoce, sino que en el lado izquierdo deben de colocar un bit equivalente a un XOR de los bits que estaban, originalmente, en las posiciones 1, 3, 4 y 6. El objeto que parece un faro de autom\u00f3vil curvado es un XOR, el cual recibe dos entradas (a, b) y devuelve en su salida a^b. A diferencia del ejercicio 1, las posiciones de los bits inician con 1 . Despu\u00e9s que hayan implementado de manera correcta lfsr_calculate() , compilen y c\u00f3rranlo. Su respuesta debe ser similar a lo siguiente: make lfsr ./lfsr My number is: 1 My number is: 5185 My number is: 38801 My number is: 52819 My number is: 21116 My number is: 54726 My number is: 26552 My number is: 46916 My number is: 41728 My number is: 26004 My number is: 62850 My number is: 40625 My number is: 647 My number is: 12837 My number is: 7043 My number is: 26003 My number is: 35845 My number is: 61398 My number is: 42863 My number is: 57133 My number is: 59156 My number is: 13312 My number is: 16285 ... etc etc ... Got 65535 numbers before cycling! Congratulations! It works! Al finalizar, recuerde hacer add + commit + push. Entrega de laboratorio \u00b6 Antes de entregar, podemos revisar cu\u00e1ntos puntos obtendremos usando el autograder que se nos provee. Para comenzar, si est\u00e1 en su propio Linux instale lo siguiente. Si est\u00e1 en la m\u00e1quina virtual del curso, no es necesario, esto ya ven\u00eda instalado. pip3 install --upgrade pip pip3 install pycrypto boto3 paramiko tabulate psutil pycparser Ahora ya podemos usar el autograder. Vaya a la carpeta de su laboratorio, y ejecute: ./check Al hacerlo ver\u00e1 algo parecido a lo siguiente: ___ __ __ / _ |__ __/ /____ ___ _______ ____/ /__ ____ / __ / // / __/ _ \\/ _ \\/ __/ _ \\/ _ / -_) __/ /_/ |_\\_,_/\\__/\\___/\\_, /_/ \\_,_/\\_,_/\\__/_/ /___/ Machine Structures Great Ideas in Computer Architecture Intro to C Exercise Grade Message ------------ ------- -------------------------------------- 1. eccentric 20 passed 2. bit_ops 40 passed 3. lfsr 40 passed La nota que aparezca all\u00ed es la nota que obtendr\u00e1 en su laboratorio. En este lab, las series valen 20, 40 y 40 respectivamente. Cuando est\u00e9 conforme con su nota (\u00a1ap\u00fantele siempre al cien!), entregue su laboratorio a trav\u00e9s de Github (los add commit y push que se le pidieron arriba). Luego env\u00ede el link de su repositorio de Github en el GES . El GES tiene una opci\u00f3n para enviar links, \u00daSELA. No vaya a poner su link en un txt, pdf, etc. porque eso solo nos causa trabajo adicional.","title":"1: Intro a C"},{"location":"labs/lab01/#lab-1-introduccion-a-c","text":"","title":"Lab 1 - Introducci\u00f3n a C"},{"location":"labs/lab01/#objetivos","text":"Aprender c\u00f3mo compilar y ejecutar un programa en C. Examinar diferentes tipos de control de flujo en C. Ganar experiencia manipulando bits","title":"Objetivos"},{"location":"labs/lab01/#preparacion","text":"Para obtener sus archivos base visite el siguiente link. https://classroom.github.com/a/Bh5XIp-g All\u00ed debe aceptar la asignaci\u00f3n para que su repositorio sea creado. Al hacerlo, tendr\u00e1 un repositorio con un link como este. https://github.com/cc-3/lab01-2023-MI_USUARIO.git Abra una terminal y navegue en ella hacia el lugar donde quiera colocar su laboratorio. Como es la primera vez que traeremos informaci\u00f3n del remote hacia nuestra computadora, usaremos el comando clone . Recuerde cambiar MI_USUARIO por su usuario. git clone https://github.com/cc-3/lab01-2023-MI_USUARIO.git Al ejecutar el comando Github le pedir\u00e1 su \"contrase\u00f1a\", sin embargo desde hace un par de a\u00f1os ya no acepta contrase\u00f1as sino tokens, genere el suyo siguiendo los pasos que se indican en esta p\u00e1gina. Puede usar el mismo token de la semana pasada (bueno... depende de la fecha de vencimiento que le haya colocado) https://docs.github.com/es/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token Tras haber realizado el clone exitosamente, tendr\u00e1 en su m\u00e1quina una carpeta con todos los archivos que usaremos en este lab.","title":"Preparaci\u00f3n"},{"location":"labs/lab01/#recordatorio-compilar-y-ejecutar-un-programa-de-c","text":"En este laboratorio, estaremos usando el programa gcc para compilar programas en c. La manera m\u00e1s sencilla de ejecutar gcc es la siguiente: gcc program.c Esto compila el archivo program.c y crea un archivo ejecutable llamado a.out . Si tienen experiencia en Java, pueden m\u00e1s o menos considerar a gcc como el equivalente en C de javac . Este archivo se puede ejecutar con el siguiente comando: ./a.out El archivo ejecutable es a.out , as\u00ed que, \u00bfqu\u00e9 rayos es eso de punto y diagonal? La respuesta: cuando quieren ejecutar un ejecutable, es necesario preponer una ruta de archivo para distinguirlo de un comando como python (no se utiliza ./python ). El punto se refiere al \"directorio actual\". De paso, dos puntos (..) se referir\u00edan al directorio que est\u00e1 un nivel arriba. gcc tiene varias opciones (o argumentos) de l\u00ednea de comandos, los cuales les recomendamos explorar. En este laboratorio, vamos a estar usando solamente -o, que se usa para especificar el nombre del ejecutable que gcc genera. Usando -o, se utilizar\u00edan estos comandos para compilar program.c en un archivo llamado program , y ejecutarlo. Eso nos sirve si no queremos que todos nuestros archivos ejecutables se llamen a.out . gcc -o program program.c ./program","title":"Recordatorio: compilar y ejecutar un programa de C"},{"location":"labs/lab01/#ejercicio-1-programa-simple-de-c","text":"En este ejercicio, veremos un ejemplo de definiciones macro del preprocesador. Las macros pueden ser un tema complicado, pero en general, la forma en que funcionan es que antes de que un archivo en C sea compilado, las constantes macro son reemplazadas exactamente por el valor al que se refieren. En este ejercicio, estaremos usando macros exclusivamente como constantes globales. Aqu\u00ed definimos CONSTANT_NAME como un literal_value (una literal entera). Noten que solo hay 1 espacio separando el nombre del valor. #define CONSTANT_NAME LITERAL_VALUE Ahora, vean el c\u00f3digo en eccentric.c (en el repo). Note que al inicio hay cuatro macros, v0 a v3 . Cambie sus valores y vea como esto cambia el output del programa. Su tarea: Modificando s\u00f3lo estos cuatro valores, hagan que el programa produzca el siguiente mensaje: gcc -o eccentric eccentric.c ./eccentric Welcome to C: ==================== Hola Hola Hola Luis El gato dice miau Hay m\u00faltiples combinaciones de valores en las macros que consiguen este resultado. El reto para ustedes en este ejercicio es: Consideren el m\u00ednimo n\u00famero de distintos valores que v0 a v3 puedan tener que den el resultado correcto. Como ejemplo, el m\u00e1ximo te\u00f3rico es cuatro (cuando todos son diferentes uno de otro). Cuando ya hayan logrado esto, pueden actualizar el archivo en su repositorio en Github, de esta manera: git add eccentric.c git commit -m \"Ejercicio 1 terminado\" git push -u origin master","title":"Ejercicio 1: Programa simple de C"},{"location":"labs/lab01/#ejercicio-2-operando-bits","text":"Para este inciso, su trabajo es completar los archivos ex2/get_bit.c , ex2/set_bit.c y ex2/flip_bit.c de manera que las funciones cumplan con la tarea que su nombre indica (obtener un bit, actualizar el valor de un bit, negar un bit). Para ello deber\u00e1n utilizar las operaciones de bits b\u00e1sicas: and (&), or (|), xor (^), not (~) y los corrimientos a la derecha (>>) y a la izquierda (<<). Lea la secci\u00f3n 2.9 de K&R si a\u00fan no ha llegado. Para este ejercicio no pueden utilizar condicionales ni ciclos . Es decir, no escriba ning\u00fan if, else, do, while, for, switch o case. No intente enga\u00f1arnos, revisaremos que no los use. El autograder analiza su c\u00f3digo de todas formas... NOTA IMPORTANTE: Considerar que n es un valor que inicia en la posici\u00f3n cero. Su bit menos significativo (es decir hasta la derecha) es el bit 0, y su bit m\u00e1s significativo (es decir hasta la izquierda) ser\u00eda su bit 31. // Return the nth bit of x. // Assume 0 <= n <= 31 unsigned get_bit ( unsigned x , unsigned n ); // Set the nth bit of the value of x to v. // Assume 0 <= n <= 31, and v is 0 or 1 void set_bit ( unsigned * x , unsigned n , unsigned v ); // Flip the nth bit of the value of x. // Assume 0 <= n <= 31 void flip_bit ( unsigned * x , unsigned n ); Idea para set_bit(): La parte complicada es no que no sabemos el valor del bit antes de cambiarlo. Recuerde las propiedades que vi\u00f3 en Info 1: x & 0 = 0 x & 1 = x x | 0 = x x | 1 = 1 \u00bfQu\u00e9 tal si usamos dos de estas propiedades para resolver el ejercicio? Idea para flip_bit(): \u00bfHabr\u00e1 otra operaci\u00f3n bitwise con propiedades similares al and y or que a\u00fan no haya usado? Quiz\u00e1s hay alguna que me haga la tarea... Una vez terminen de editar las funciones, pueden compilar y correr el c\u00f3digo con: make bit_ops ./bit_ops Ahora estamos usando un Makefile, el cu\u00e1l tiene dentro comandos que nos facilitan la compilaci\u00f3n. Al ejecutar ./bit_ops se imprimir\u00e1 el resultado de algunas pruebas. Si tienen curiosidad pueden revisar con libertad la carpeta tests que contiene las pruebas que se van a realizar en cada ejercicio de este laboratorio y que reflejan bastante lo que evaluar\u00e1 el autograder, por ejemplo el archivo que se utiliza para este ejercicio es tests/bit_ops_test.c . Al terminar su ejercicio recuerde hacer add + commit + push hacia Github.","title":"Ejercicio 2: Operando bits"},{"location":"labs/lab01/#ejercicio-3-registro-de-corrimiento-con-retroalimentacion-lineal","text":"En este ejercicio deben de implementar una funci\u00f3n que compute la siguiente iteraci\u00f3n de un registro de corrimiento de retroalimentaci\u00f3n lineal (LFSR por sus siglas en ingl\u00e9s). Algunas aplicaciones que utilizan LFSRs son: televisi\u00f3n digital, tel\u00e9fonos con acceso m\u00faltiple por divisi\u00f3n de c\u00f3digo, Ethernet, USB 3.0 y mucho m\u00e1s. Esta funci\u00f3n deber\u00e1 generar n\u00fameros pseudo-aleatorios utilizando operadores binarios. Si quiere conocer un poco m\u00e1s, puede visitar el siguiente link de Wikipedia . En el archivo ex3/lfsr_calculate.c deben de completar la funci\u00f3n lfsr_calculate() de manera que realice lo siguiente:","title":"Ejercicio 3: Registro de Corrimiento con Retroalimentaci\u00f3n Lineal"},{"location":"labs/lab01/#diagrama-del-hardware","text":"","title":"Diagrama del hardware"},{"location":"labs/lab01/#explicacion-del-diagrama","text":"En cada llamada de lfsr_calculate() deben de correr el contenido del registro un bit hacia la derecha. Este corrimiento no es el l\u00f3gico ni aritm\u00e9tico que ya conoce, sino que en el lado izquierdo deben de colocar un bit equivalente a un XOR de los bits que estaban, originalmente, en las posiciones 1, 3, 4 y 6. El objeto que parece un faro de autom\u00f3vil curvado es un XOR, el cual recibe dos entradas (a, b) y devuelve en su salida a^b. A diferencia del ejercicio 1, las posiciones de los bits inician con 1 . Despu\u00e9s que hayan implementado de manera correcta lfsr_calculate() , compilen y c\u00f3rranlo. Su respuesta debe ser similar a lo siguiente: make lfsr ./lfsr My number is: 1 My number is: 5185 My number is: 38801 My number is: 52819 My number is: 21116 My number is: 54726 My number is: 26552 My number is: 46916 My number is: 41728 My number is: 26004 My number is: 62850 My number is: 40625 My number is: 647 My number is: 12837 My number is: 7043 My number is: 26003 My number is: 35845 My number is: 61398 My number is: 42863 My number is: 57133 My number is: 59156 My number is: 13312 My number is: 16285 ... etc etc ... Got 65535 numbers before cycling! Congratulations! It works! Al finalizar, recuerde hacer add + commit + push.","title":"Explicaci\u00f3n del diagrama"},{"location":"labs/lab01/#entrega-de-laboratorio","text":"Antes de entregar, podemos revisar cu\u00e1ntos puntos obtendremos usando el autograder que se nos provee. Para comenzar, si est\u00e1 en su propio Linux instale lo siguiente. Si est\u00e1 en la m\u00e1quina virtual del curso, no es necesario, esto ya ven\u00eda instalado. pip3 install --upgrade pip pip3 install pycrypto boto3 paramiko tabulate psutil pycparser Ahora ya podemos usar el autograder. Vaya a la carpeta de su laboratorio, y ejecute: ./check Al hacerlo ver\u00e1 algo parecido a lo siguiente: ___ __ __ / _ |__ __/ /____ ___ _______ ____/ /__ ____ / __ / // / __/ _ \\/ _ \\/ __/ _ \\/ _ / -_) __/ /_/ |_\\_,_/\\__/\\___/\\_, /_/ \\_,_/\\_,_/\\__/_/ /___/ Machine Structures Great Ideas in Computer Architecture Intro to C Exercise Grade Message ------------ ------- -------------------------------------- 1. eccentric 20 passed 2. bit_ops 40 passed 3. lfsr 40 passed La nota que aparezca all\u00ed es la nota que obtendr\u00e1 en su laboratorio. En este lab, las series valen 20, 40 y 40 respectivamente. Cuando est\u00e9 conforme con su nota (\u00a1ap\u00fantele siempre al cien!), entregue su laboratorio a trav\u00e9s de Github (los add commit y push que se le pidieron arriba). Luego env\u00ede el link de su repositorio de Github en el GES . El GES tiene una opci\u00f3n para enviar links, \u00daSELA. No vaya a poner su link en un txt, pdf, etc. porque eso solo nos causa trabajo adicional.","title":"Entrega de laboratorio"},{"location":"labs/lab02/","text":"Lab 2 - CGDB y punteros \u00b6 Objetivos \u00b6 Aprender a usar el debugger (depurador) de C Encontrar errores en programas usando cgdb Practicar el uso de punteros Preparaci\u00f3n \u00b6 Para obtener sus archivos base visite el siguiente link, luego clone su repositorio. https://classroom.github.com/a/2G1sUtI3 git clone https://github.com/cc-3/lab02-2023-MI_USUARIO.git Un par de recordatorios, si necesita ayuda con esto revise los labs anteriores para m\u00e1s detalle: Si est\u00e1 trabajando en las computadoras del lab o en alguna m\u00e1quina nueva, debe volver a hacer las configuraciones de Github. En Github usamos token en lugar de contrase\u00f1a. Ejercicio 1: Debugger (depurador) \u00b6 \u00bfQu\u00e9 es un debugger? \u00b6 Un debugger , como sugiere el nombre, es un programa espec\u00edficamente dise\u00f1ado para ayudarlos a encontrar bugs , es decir errores en el c\u00f3digo (nota: si quieren saber por qu\u00e9 se les llama bugs a los errores, vean aqu\u00ed ). Distintos debuggers tienen distintas caracter\u00edsticas, pero es normal que todos los debuggers sean capaces de hacer las siguientes cosas: Poner un breakpoint en el programa. Un breakpoint es una l\u00ednea espec\u00edfica en su c\u00f3digo en donde quisieran que se detenga la ejecuci\u00f3n del programa, para que puedan ver lo que est\u00e1 pasando alrededor. Ejecuci\u00f3n por steps (l\u00ednea a l\u00ednea) por el programa. El c\u00f3digo siempre se ejecuta l\u00ednea a l\u00ednea, pero pasa muy r\u00e1pido como para que sepamos qu\u00e9 l\u00ednea produce alg\u00fan error. Ser capaces de ejecutar l\u00ednea a l\u00ednea el programa les permite observar exactamente qu\u00e9 esta causando un bug en el programa. Para este ejercicio, necesitar\u00e1n la GDB reference card . Para poder usarlo compilaremos con la bandera -g . gcc -g -o hello hello.c Esto har\u00e1 que gcc guarde informaci\u00f3n en el archivo ejecutable para que cgdb lo interprete. Ahora ejecuten el debugger: cgdb hello Vean lo que hace este comando. Est\u00e1n ejecutando el programa cgdb en el ejecutable hello generado por gcc . No intenten ejecutar cgdb en el archivo fuente en hello.c ! Eso no va a funcionar. Su tarea: Ejecute el programa en cgdb varias veces, pruebe distintos comandos en cada ejecuci\u00f3n 1. Ponga un breakpoint en el main. 2. Use el comando run de cgdb. 3. Use el comando para single-step de cgdb. Escriban help adentro de cgdb para averiguar c\u00f3mo hacer estas cosas, o usen la reference card. Si encuentran un mensaje de error que dice printf.c: No such file or directory : Probablemente entraron a una funci\u00f3n printf . Si siguen ejecutando paso a paso, pareciera que nunca avanzaran en el c\u00f3digo. cgdb est\u00e1 dando el error porque no tienen el archivo en el que se define la funci\u00f3n printf . Esto es algo molesto, entonces para librarse de esto usen el comando finish para ejecutar el programa hasta que termine la funci\u00f3n printf. La pr\u00f3xima vez que prueba, utilice el comando next para saltar sobre la linea que usa printf . En cgdb, pueden presionar ESC para ir a la ventana del c\u00f3digo (arriba), y usar i para regresar a la ventana de comandos (abajo). La ventana de comandos es donde se introducen los comandos de cgdb. Para este ejercicio, encontrar\u00e1n un archivo de texto llamado ex1.txt , con el siguiente formato: 1 : 2 : 3 : 4 : 5 : 6 : 7 : 8 : 9 : Aqu\u00ed tendr\u00e1n que responder las siguientes preguntas de opci\u00f3n m\u00faltiple con el siguiente formato. Los siguiente son solo ejemplos, usted debe colocar la letra de la respuesta que considere correcta. 1 :e 2 :f 3 :g 4 :h 5 :i 6 :j 7 :k 8 :l 9 :m No responda al azar. Lea la documentaci\u00f3n y/o pruebe los comandos para saber que hace cada uno. Preguntas 1. \u00bfC\u00f3mo se le dan argumentos desde la l\u00ednea de comandos a un programa al utilizar gdb? a. args arglist b. run arglist c. gdb args d. Ninguna de las anteriores 2. \u00bfC\u00f3mo se a\u00f1ade un breakpoint que s\u00f3lo ocurre cuando se cumplen ciertas condiciones (por ejemplo, ciertas variables alcanzan cierto valor)? a. expr cond b. cond break expr c. break ... if expr d. Ninguna de las anteriores 3. \u00bfCon qu\u00e9 comando se ejecuta la siguiente l\u00ednea del c\u00f3digo en C despu\u00e9s de parar en un breakpoint? (si la l\u00ednea a ejecutar es una llamada a funci\u00f3n, debe ejecutarse toda la funci\u00f3n) a. run b. s c. c d. n 4. \u00bfC\u00f3mo se le indica a cgdb, que quieren debuggear el c\u00f3digo adentro de la funci\u00f3n ? (esta respuesta es distinta a la pregunta 3, ahora ya no pasamos por encima sino que entramos a debuggear la funci\u00f3n) a. run b. s c. c d. n 5. \u00bfC\u00f3mo se reanuda la ejecuci\u00f3n del programa despu\u00e9s de parar en un breakpoint? a. run b. s c. c d. n 6. \u00bfC\u00f3mo podemos ver el valor de una variable (o expresi\u00f3n) en cgdb? a. display expr b. signal expr c. print expr d. next expr 7. \u00bfQu\u00e9 comando de cgdb se usa para desplegar el valor de una variable despu\u00e9s de cada paso ? a. display expr b. signal expr c. print expr d. next expr 8. \u00bfC\u00f3mo se imprime una lista de todas las variables y su valor en la funci\u00f3n actual? a. info locals b. display locals c. info all d. display all 9. \u00bfC\u00f3mo salimos de cgdb? a. end b. quit c. exit d. finish Despu\u00e9s de responder estas preguntas, no olviden hacer el add, commit y push de este archivo hacia Github: git add ex1.txt git commit -m \"Ejercicio 1 terminado\" git push origin master Ejercicio 2: Depurando un problema con fallas usando cgdb \u00b6 Ahora usar\u00e1n lo aprendido en el ejercicio 1 para buscar errores en un programa, usando cgdb. Vean el programa ll_equal.c . Lean el programa y analicen un poco lo que hace, luego compilen y ejecuten. As\u00ed como est\u00e1, producir\u00e1 un resultado como el siguiente: gcc -g -o ll_equal ll_equal.c ./ll_equal equal test 1 result = 1 Segmentation fault Su tarea: Averig\u00fcen qu\u00e9 produce el segmentation fault (falla de segmentaci\u00f3n) . Ejecuten cgdb en el programa, siguiendo las instrucciones aprendidas en los ejercicios anteriores. Les recomendamos a\u00f1adir un breakpoint en la funci\u00f3n ll_equal() . Cuando el debugger pare en el breakpoint, ejecuten paso a paso el programa para que puedan descifrar qu\u00e9 es lo que provoca el error. Pista 1: Analicen el valor de los punteros a y b en la funci\u00f3n (\u00a1despli\u00e9guenlos!). \u00bfEst\u00e1n siempre apuntando a la direcci\u00f3n correcta? Pista 2: Vean el c\u00f3digo fuente en main para ver la estructura de los nodos y ver exactamente qu\u00e9 se est\u00e1 enviando como argumento a ll_equal . Cuando haya encontrado el problema, arr\u00e9glelo, compile nuevamente y ejecute el c\u00f3digo. \u00bfNota la diferencia? Al finalizar, no olvide subir el archivo modificado a su repositorio. git add ll_equal.c git commit -m \"Ejercicio 2 terminado\" git push origin master Aprendiendo algo extra: Debuggeando un programa en C que requiere interacci\u00f3n del usuario \u00b6 Esta parte es opcional y no vale puntos, ni siquiera extras. Veamos qu\u00e9 pasa cuando, a un programa que requiere interacci\u00f3n del usuario, lo ejecutamos con cgdb. Primero, ejecuten el programa en interactive_hello.c para hablar con un programa muy amigable. gcc -g -o int_hello interactive_hello.c ./int_hello Ahora, traten de depurarlo paso a paso en cgdb. cgdb int_hello \u00bfQu\u00e9 pasa cuando intentar ejecutar el programa hasta el final? \u00bfLogr\u00f3 terminar o se qued\u00f3 trabado? Vamos a aprender un poco acerca de las redirecciones. Para comenzar, puede ir a leer un poco en los siguientes links: Standard Input Discusion en Stack Overflow Ahora uniremos algunas piezas de conocimiento... \u00bfQu\u00e9 se le ocurre hacer con el run que vi\u00f3 en el ejercicio 2 y el < que acaba de conocer? (Hint: Si est\u00e1 pensando en crear un archivo de texto, va en buen camino) \u00bfYa lo pens\u00f3 un poco por su cuenta? Muy bien, hora de ver la soluci\u00f3n sobre c\u00f3mo enviar datos que nuestro programa de C espera leer. Cree un archivo nombre.txt y escriba adentro su nombre, en una sola l\u00ednea. Guarde el archivo en la carpeta de su lab. Compile su programa con banderas de debugging gcc -g -o int_hello interactive_hello.c Inicie el debugger cgdb int_hello En lugar de solo hacer run como antes, haga run < nombre.txt \u00bfApareci\u00f3 su nombre autom\u00e1gicamente all\u00ed escrito? Ese es el poder de las redirecciones, el < nos permite enviar el contenido del archivo de texto, hacia el programa que se est\u00e1 debuggeando. El debugger no es una herramienta muy atractiva visualmente, pero es increiblemente poderosa al momento de buscar errores. \u00dasela siempre que tenga problemas, aunque las instrucciones no se lo indiquen. Ejercicio 3: Punteros y estructuras en C \u00b6 En ll_cycle.c completen la funci\u00f3n ll_has_cycle() de modo que implemente el siguiente algoritmo para comprobar si una linked list simple tiene un ciclo: 1. Comiencen con dos punteros apuntando al principio de la lista. Llamaremos al primero tortoise (tortuga) y al segundo hare (liebre). 2. Avancen el puntero hare dos nodos hacia adelante. Si no se puede debido a punteros nulos, hemos llegado al final de la lista. Por lo tanto, la lista no tiene un ciclo. 3. Ahora, avancen tortoise un nodo. (Revisar si llega a ser un puntero nulo es innecesario. \u00bfPor qu\u00e9?) 4. Si la tortuga y la liebre apuntan al mismo nodo, la lista es c\u00edclica. Si no, regresen al paso 2. Despu\u00e9s de implementar correctamente la funci\u00f3n ll_has_cycle() , el programa que se obtiene despu\u00e9s de compilar ll_cycle.c mostrar\u00e1 si el resultado de su funci\u00f3n est\u00e1 correcto, conforme a lo que esperaba como salida. Pista: Para este ejercicio debe haber entendido que es un puntero nulo. Recuerda cu\u00e1ndo avanzaba en una linked list en Java? Recuerda las precauciones que deb\u00eda tomar para no seguir avanzando de m\u00e1s? Si necesita m\u00e1s explicaci\u00f3n del algoritmo aqu\u00ed hay un art\u00edculo sobre su funcionamiento. A prop\u00f3sito, los punteros se llaman tortoise y hare porque el puntero tortoise (tortuga) se incrementa lentamente (como una tortuga, que se mueve muy lento) y el puntero hare (liebre) se incrementa r\u00e1pidamente (m\u00e1s r\u00e1pido que una tortuga, como una liebre, o conejo, que se mueve muy r\u00e1pido). Al finalizar, compilen y ejecuten el archivo, y verifiquen que el resultado de su c\u00f3digo, el cual deber\u00eda ser m\u00e1s o menos igual a este: gcc -g -o ll_cycle ll_cycle.c ./ll_cycle Checking first list for cycles. There should be none, ll_has_cycle says it has no cycle Checking second list for cycles. There should be a cycle, ll_has_cycle says it has a cycle Checking third list for cycles. There should be a cycle, ll_has_cycle says it has a cycle Checking fourth list for cycles. There should be a cycle, ll_has_cycle says it has a cycle Checking fifth list for cycles. There should be none, ll_has_cycle says it has no cycle Checking length-zero list for cycles. There should be none, ll_has_cycle says it has no cycle Si su c\u00f3digo tiene errores, use lo aprendido sobre cgdb para encontrarlos y corregirlos. Al terminar, agregue su c\u00f3digo a su repositorio. git add ll_cycle.c git commit -m \"Lab 2 terminado\" git push origin master Para finalizar, la f\u00e1bula de la tortuga y la liebre es relevante siempre, especialmente en este curso. Escribir sus programas en C a paso lento pero seguro (ayud\u00e1ndose de programas como cgdb) es lo que les har\u00e1 ganar la carrera. Entrega de laboratorio \u00b6 Recuerde probar su laboratorio usando el autograder. ./check Las series valen 30, 30 y 40 puntos respectivamente. Luego env\u00ede el link de su repositorio de Github en el GES . El GES tiene una opci\u00f3n para enviar links, \u00daSELA. Si env\u00eda alg\u00fan txt, pdf, zip, etc. su laboratorio no se calificar\u00e1, es decir tendr\u00e1 cero.","title":"2: CGDB y punteros"},{"location":"labs/lab02/#lab-2-cgdb-y-punteros","text":"","title":"Lab 2 - CGDB y punteros"},{"location":"labs/lab02/#objetivos","text":"Aprender a usar el debugger (depurador) de C Encontrar errores en programas usando cgdb Practicar el uso de punteros","title":"Objetivos"},{"location":"labs/lab02/#preparacion","text":"Para obtener sus archivos base visite el siguiente link, luego clone su repositorio. https://classroom.github.com/a/2G1sUtI3 git clone https://github.com/cc-3/lab02-2023-MI_USUARIO.git Un par de recordatorios, si necesita ayuda con esto revise los labs anteriores para m\u00e1s detalle: Si est\u00e1 trabajando en las computadoras del lab o en alguna m\u00e1quina nueva, debe volver a hacer las configuraciones de Github. En Github usamos token en lugar de contrase\u00f1a.","title":"Preparaci\u00f3n"},{"location":"labs/lab02/#ejercicio-1-debugger-depurador","text":"","title":"Ejercicio 1: Debugger (depurador)"},{"location":"labs/lab02/#que-es-un-debugger","text":"Un debugger , como sugiere el nombre, es un programa espec\u00edficamente dise\u00f1ado para ayudarlos a encontrar bugs , es decir errores en el c\u00f3digo (nota: si quieren saber por qu\u00e9 se les llama bugs a los errores, vean aqu\u00ed ). Distintos debuggers tienen distintas caracter\u00edsticas, pero es normal que todos los debuggers sean capaces de hacer las siguientes cosas: Poner un breakpoint en el programa. Un breakpoint es una l\u00ednea espec\u00edfica en su c\u00f3digo en donde quisieran que se detenga la ejecuci\u00f3n del programa, para que puedan ver lo que est\u00e1 pasando alrededor. Ejecuci\u00f3n por steps (l\u00ednea a l\u00ednea) por el programa. El c\u00f3digo siempre se ejecuta l\u00ednea a l\u00ednea, pero pasa muy r\u00e1pido como para que sepamos qu\u00e9 l\u00ednea produce alg\u00fan error. Ser capaces de ejecutar l\u00ednea a l\u00ednea el programa les permite observar exactamente qu\u00e9 esta causando un bug en el programa. Para este ejercicio, necesitar\u00e1n la GDB reference card . Para poder usarlo compilaremos con la bandera -g . gcc -g -o hello hello.c Esto har\u00e1 que gcc guarde informaci\u00f3n en el archivo ejecutable para que cgdb lo interprete. Ahora ejecuten el debugger: cgdb hello Vean lo que hace este comando. Est\u00e1n ejecutando el programa cgdb en el ejecutable hello generado por gcc . No intenten ejecutar cgdb en el archivo fuente en hello.c ! Eso no va a funcionar. Su tarea: Ejecute el programa en cgdb varias veces, pruebe distintos comandos en cada ejecuci\u00f3n 1. Ponga un breakpoint en el main. 2. Use el comando run de cgdb. 3. Use el comando para single-step de cgdb. Escriban help adentro de cgdb para averiguar c\u00f3mo hacer estas cosas, o usen la reference card. Si encuentran un mensaje de error que dice printf.c: No such file or directory : Probablemente entraron a una funci\u00f3n printf . Si siguen ejecutando paso a paso, pareciera que nunca avanzaran en el c\u00f3digo. cgdb est\u00e1 dando el error porque no tienen el archivo en el que se define la funci\u00f3n printf . Esto es algo molesto, entonces para librarse de esto usen el comando finish para ejecutar el programa hasta que termine la funci\u00f3n printf. La pr\u00f3xima vez que prueba, utilice el comando next para saltar sobre la linea que usa printf . En cgdb, pueden presionar ESC para ir a la ventana del c\u00f3digo (arriba), y usar i para regresar a la ventana de comandos (abajo). La ventana de comandos es donde se introducen los comandos de cgdb. Para este ejercicio, encontrar\u00e1n un archivo de texto llamado ex1.txt , con el siguiente formato: 1 : 2 : 3 : 4 : 5 : 6 : 7 : 8 : 9 : Aqu\u00ed tendr\u00e1n que responder las siguientes preguntas de opci\u00f3n m\u00faltiple con el siguiente formato. Los siguiente son solo ejemplos, usted debe colocar la letra de la respuesta que considere correcta. 1 :e 2 :f 3 :g 4 :h 5 :i 6 :j 7 :k 8 :l 9 :m No responda al azar. Lea la documentaci\u00f3n y/o pruebe los comandos para saber que hace cada uno. Preguntas 1. \u00bfC\u00f3mo se le dan argumentos desde la l\u00ednea de comandos a un programa al utilizar gdb? a. args arglist b. run arglist c. gdb args d. Ninguna de las anteriores 2. \u00bfC\u00f3mo se a\u00f1ade un breakpoint que s\u00f3lo ocurre cuando se cumplen ciertas condiciones (por ejemplo, ciertas variables alcanzan cierto valor)? a. expr cond b. cond break expr c. break ... if expr d. Ninguna de las anteriores 3. \u00bfCon qu\u00e9 comando se ejecuta la siguiente l\u00ednea del c\u00f3digo en C despu\u00e9s de parar en un breakpoint? (si la l\u00ednea a ejecutar es una llamada a funci\u00f3n, debe ejecutarse toda la funci\u00f3n) a. run b. s c. c d. n 4. \u00bfC\u00f3mo se le indica a cgdb, que quieren debuggear el c\u00f3digo adentro de la funci\u00f3n ? (esta respuesta es distinta a la pregunta 3, ahora ya no pasamos por encima sino que entramos a debuggear la funci\u00f3n) a. run b. s c. c d. n 5. \u00bfC\u00f3mo se reanuda la ejecuci\u00f3n del programa despu\u00e9s de parar en un breakpoint? a. run b. s c. c d. n 6. \u00bfC\u00f3mo podemos ver el valor de una variable (o expresi\u00f3n) en cgdb? a. display expr b. signal expr c. print expr d. next expr 7. \u00bfQu\u00e9 comando de cgdb se usa para desplegar el valor de una variable despu\u00e9s de cada paso ? a. display expr b. signal expr c. print expr d. next expr 8. \u00bfC\u00f3mo se imprime una lista de todas las variables y su valor en la funci\u00f3n actual? a. info locals b. display locals c. info all d. display all 9. \u00bfC\u00f3mo salimos de cgdb? a. end b. quit c. exit d. finish Despu\u00e9s de responder estas preguntas, no olviden hacer el add, commit y push de este archivo hacia Github: git add ex1.txt git commit -m \"Ejercicio 1 terminado\" git push origin master","title":"\u00bfQu\u00e9 es un debugger?"},{"location":"labs/lab02/#ejercicio-2-depurando-un-problema-con-fallas-usando-cgdb","text":"Ahora usar\u00e1n lo aprendido en el ejercicio 1 para buscar errores en un programa, usando cgdb. Vean el programa ll_equal.c . Lean el programa y analicen un poco lo que hace, luego compilen y ejecuten. As\u00ed como est\u00e1, producir\u00e1 un resultado como el siguiente: gcc -g -o ll_equal ll_equal.c ./ll_equal equal test 1 result = 1 Segmentation fault Su tarea: Averig\u00fcen qu\u00e9 produce el segmentation fault (falla de segmentaci\u00f3n) . Ejecuten cgdb en el programa, siguiendo las instrucciones aprendidas en los ejercicios anteriores. Les recomendamos a\u00f1adir un breakpoint en la funci\u00f3n ll_equal() . Cuando el debugger pare en el breakpoint, ejecuten paso a paso el programa para que puedan descifrar qu\u00e9 es lo que provoca el error. Pista 1: Analicen el valor de los punteros a y b en la funci\u00f3n (\u00a1despli\u00e9guenlos!). \u00bfEst\u00e1n siempre apuntando a la direcci\u00f3n correcta? Pista 2: Vean el c\u00f3digo fuente en main para ver la estructura de los nodos y ver exactamente qu\u00e9 se est\u00e1 enviando como argumento a ll_equal . Cuando haya encontrado el problema, arr\u00e9glelo, compile nuevamente y ejecute el c\u00f3digo. \u00bfNota la diferencia? Al finalizar, no olvide subir el archivo modificado a su repositorio. git add ll_equal.c git commit -m \"Ejercicio 2 terminado\" git push origin master","title":"Ejercicio 2: Depurando un problema con fallas usando cgdb"},{"location":"labs/lab02/#aprendiendo-algo-extra-debuggeando-un-programa-en-c-que-requiere-interaccion-del-usuario","text":"Esta parte es opcional y no vale puntos, ni siquiera extras. Veamos qu\u00e9 pasa cuando, a un programa que requiere interacci\u00f3n del usuario, lo ejecutamos con cgdb. Primero, ejecuten el programa en interactive_hello.c para hablar con un programa muy amigable. gcc -g -o int_hello interactive_hello.c ./int_hello Ahora, traten de depurarlo paso a paso en cgdb. cgdb int_hello \u00bfQu\u00e9 pasa cuando intentar ejecutar el programa hasta el final? \u00bfLogr\u00f3 terminar o se qued\u00f3 trabado? Vamos a aprender un poco acerca de las redirecciones. Para comenzar, puede ir a leer un poco en los siguientes links: Standard Input Discusion en Stack Overflow Ahora uniremos algunas piezas de conocimiento... \u00bfQu\u00e9 se le ocurre hacer con el run que vi\u00f3 en el ejercicio 2 y el < que acaba de conocer? (Hint: Si est\u00e1 pensando en crear un archivo de texto, va en buen camino) \u00bfYa lo pens\u00f3 un poco por su cuenta? Muy bien, hora de ver la soluci\u00f3n sobre c\u00f3mo enviar datos que nuestro programa de C espera leer. Cree un archivo nombre.txt y escriba adentro su nombre, en una sola l\u00ednea. Guarde el archivo en la carpeta de su lab. Compile su programa con banderas de debugging gcc -g -o int_hello interactive_hello.c Inicie el debugger cgdb int_hello En lugar de solo hacer run como antes, haga run < nombre.txt \u00bfApareci\u00f3 su nombre autom\u00e1gicamente all\u00ed escrito? Ese es el poder de las redirecciones, el < nos permite enviar el contenido del archivo de texto, hacia el programa que se est\u00e1 debuggeando. El debugger no es una herramienta muy atractiva visualmente, pero es increiblemente poderosa al momento de buscar errores. \u00dasela siempre que tenga problemas, aunque las instrucciones no se lo indiquen.","title":"Aprendiendo algo extra: Debuggeando un programa en C que requiere interacci\u00f3n del usuario"},{"location":"labs/lab02/#ejercicio-3-punteros-y-estructuras-en-c","text":"En ll_cycle.c completen la funci\u00f3n ll_has_cycle() de modo que implemente el siguiente algoritmo para comprobar si una linked list simple tiene un ciclo: 1. Comiencen con dos punteros apuntando al principio de la lista. Llamaremos al primero tortoise (tortuga) y al segundo hare (liebre). 2. Avancen el puntero hare dos nodos hacia adelante. Si no se puede debido a punteros nulos, hemos llegado al final de la lista. Por lo tanto, la lista no tiene un ciclo. 3. Ahora, avancen tortoise un nodo. (Revisar si llega a ser un puntero nulo es innecesario. \u00bfPor qu\u00e9?) 4. Si la tortuga y la liebre apuntan al mismo nodo, la lista es c\u00edclica. Si no, regresen al paso 2. Despu\u00e9s de implementar correctamente la funci\u00f3n ll_has_cycle() , el programa que se obtiene despu\u00e9s de compilar ll_cycle.c mostrar\u00e1 si el resultado de su funci\u00f3n est\u00e1 correcto, conforme a lo que esperaba como salida. Pista: Para este ejercicio debe haber entendido que es un puntero nulo. Recuerda cu\u00e1ndo avanzaba en una linked list en Java? Recuerda las precauciones que deb\u00eda tomar para no seguir avanzando de m\u00e1s? Si necesita m\u00e1s explicaci\u00f3n del algoritmo aqu\u00ed hay un art\u00edculo sobre su funcionamiento. A prop\u00f3sito, los punteros se llaman tortoise y hare porque el puntero tortoise (tortuga) se incrementa lentamente (como una tortuga, que se mueve muy lento) y el puntero hare (liebre) se incrementa r\u00e1pidamente (m\u00e1s r\u00e1pido que una tortuga, como una liebre, o conejo, que se mueve muy r\u00e1pido). Al finalizar, compilen y ejecuten el archivo, y verifiquen que el resultado de su c\u00f3digo, el cual deber\u00eda ser m\u00e1s o menos igual a este: gcc -g -o ll_cycle ll_cycle.c ./ll_cycle Checking first list for cycles. There should be none, ll_has_cycle says it has no cycle Checking second list for cycles. There should be a cycle, ll_has_cycle says it has a cycle Checking third list for cycles. There should be a cycle, ll_has_cycle says it has a cycle Checking fourth list for cycles. There should be a cycle, ll_has_cycle says it has a cycle Checking fifth list for cycles. There should be none, ll_has_cycle says it has no cycle Checking length-zero list for cycles. There should be none, ll_has_cycle says it has no cycle Si su c\u00f3digo tiene errores, use lo aprendido sobre cgdb para encontrarlos y corregirlos. Al terminar, agregue su c\u00f3digo a su repositorio. git add ll_cycle.c git commit -m \"Lab 2 terminado\" git push origin master Para finalizar, la f\u00e1bula de la tortuga y la liebre es relevante siempre, especialmente en este curso. Escribir sus programas en C a paso lento pero seguro (ayud\u00e1ndose de programas como cgdb) es lo que les har\u00e1 ganar la carrera.","title":"Ejercicio 3: Punteros y estructuras en C"},{"location":"labs/lab02/#entrega-de-laboratorio","text":"Recuerde probar su laboratorio usando el autograder. ./check Las series valen 30, 30 y 40 puntos respectivamente. Luego env\u00ede el link de su repositorio de Github en el GES . El GES tiene una opci\u00f3n para enviar links, \u00daSELA. Si env\u00eda alg\u00fan txt, pdf, zip, etc. su laboratorio no se calificar\u00e1, es decir tendr\u00e1 cero.","title":"Entrega de laboratorio"},{"location":"labs/lab03/","text":"Lab 3 - Estructuras y manejo de memoria \u00b6 Objetivos \u00b6 Utilizar los struct de C. Practicar el uso de malloc para la asignaci\u00f3n de memoria din\u00e1mica. Comprender la importancia del free. Preparaci\u00f3n \u00b6 Para obtener sus archivos base visite el siguiente link, luego clone su repositorio. https://classroom.github.com/a/MXKSAlQ0 git clone https://github.com/cc-3/lab03-2023-MI_USUARIO.git Un par de recordatorios, si necesita ayuda con esto revise los labs anteriores para m\u00e1s detalle: Si est\u00e1 trabajando en las computadoras del lab o en alguna m\u00e1quina nueva, debe volver a hacer las configuraciones de Github. En Github usamos token en lugar de contrase\u00f1a. Ejercicio 1: Manejo de Memoria \u00b6 Para este ejercicio lea los archivos tests/include/vector.h , tests/vector_test.c y luego complete el archivo ex1/vector.c , en donde les proveemos con la base para la implementaci\u00f3n de un arreglo de longitud variable. El objetivo del lab es acostumbrarse al uso de los structs de C, as\u00ed como el manejo de memoria en este lenguaje. Su tarea: Completar las funciones vector_new() , vector_get() , vector_delete() y vector_set() en ex1/vector.c de manera que tests/vector-test.c corra sin errores de manejo de memoria. \u00bfC\u00f3mo funciona un vector_t ? \u00b6 Posee un int size que indica cu\u00e1ntos elementos tiene actualmente. Un vector con size = 5 , por ejemplo, tendr\u00e1 cinco casillas con \u00edndices entre 0 y 4. Por defecto la longitud de su vector ser\u00e1 de 1. El vector debe aumentar de tama\u00f1o autom\u00e1ticamente si el vector_set() lo require. Por ejemplo, si su vector tiene size = 5 pero le piden que haga un set en la casilla con \u00edndice 200, usted debe hacer que su vector aumente de tama\u00f1o para tener 201 casillas. Revisemos esos n\u00fameros... como los \u00edndices comienzan en 0, cuando me pidan el \u00edndice 200 yo debo entender que hay 201 casillas. Tiene un int *data , el cu\u00e1l es un espacio pedido a trav\u00e9s de un malloc() que utilizaremos para guardar los valores de las casillas del vector. Los valores guardados por defecto al hacer un vector_new() deben ser cero. El valor de cualquier casilla que no ha sido expl\u00edcitamente editado es 0. El vector no debe dar error, incluso si se consulta alguna casilla que todav\u00eda no existe. Por ejemplo, su vector tiene size = 5 pero le hacen un vector_get() de la posici\u00f3n 10, esto no da error; cuando le consulten una casilla que no existe usted devuelve como respuesta un 0. Es momento de revisar el c\u00f3digo de ex1/vector.c si a\u00fan lo ha hecho. Aqu\u00ed hay comentarios complementarios que describen c\u00f3mo deber\u00edan de correr las funciones. Recuerden que los usuarios de su estructura de datos vector_t asumiran que todas las entradas al vector son 0, a menos que hayan sido definidas de otra manera por ellos. Tengan esto en mente, porque malloc no hace esto por ustedes. \u00bfQu\u00e9 deben hacer? \u00b6 Complete vector_new (). Hay seis comentarios que nos gu\u00edan paso a paso en qu\u00e9 realizar; en la mayor\u00eda solo necesita una instrucci\u00f3n, pero en un par quiz\u00e1s necesite un poquito m\u00e1s. Termine vector_get() . Piense en lo que se dijo arriba: aunque me consulten una casilla que a\u00fan no existe, debo entregar un resultado v\u00e1lido. Complementen vector_delete() . Es muy probable que le salga con solo dos l\u00edneas de c\u00f3digo, pero el orden de estas es importante. Complete vector_set() . Esta es la m\u00e1s complicada, bienvenidos a las ligas mayores. Para resolver esta parte piense en las siguientes preguntas \u00bfqu\u00e9 pasa si la posici\u00f3n donde me piden escribir a\u00fan no existe? \u00bfc\u00f3mo pido espacio adicional para que ahora ya exista esta nueva posici\u00f3n? \u00bfque valor debo colocar en las dem\u00e1s posiciones cuando expanda mi vector? Adicionalmente, ya no piense solo en malloc() sino en las otras dos funciones _alloc() . Hay algunos comentarios por all\u00ed para ayudarle. Saber c\u00f3mo reorganizar y liberar memoria es importante para la programaci\u00f3n en C. Piensen que el manejo de memoria es como un parqueo, si hay carros parqueados y los due\u00f1os nunca se van, entonces no tienen espacio para nuevos carros. Finalmente, tenga en cuenta que deber\u00eda tener un heap vac\u00edo al terminar su programa . Si no lo tenemos, hay que buscar en cu\u00e1l funci\u00f3n debemos colocar free() . Al finalizar, pruebe su programa con: make vector ./vector Entrega de laboratorio \u00b6 Recuerde probar su laboratorio usando el autograder. ./check Este laboratorio tiene una \u00fanica serie que vale 100 puntos. Luego env\u00ede el link de su repositorio de Github en el GES . El GES tiene una opci\u00f3n para enviar links, \u00daSELA. Si env\u00eda alg\u00fan txt, pdf, zip, etc. su laboratorio no se calificar\u00e1, es decir tendr\u00e1 cero.","title":"3: Estructuras y manejo de memoria"},{"location":"labs/lab03/#lab-3-estructuras-y-manejo-de-memoria","text":"","title":"Lab 3 - Estructuras y manejo de memoria"},{"location":"labs/lab03/#objetivos","text":"Utilizar los struct de C. Practicar el uso de malloc para la asignaci\u00f3n de memoria din\u00e1mica. Comprender la importancia del free.","title":"Objetivos"},{"location":"labs/lab03/#preparacion","text":"Para obtener sus archivos base visite el siguiente link, luego clone su repositorio. https://classroom.github.com/a/MXKSAlQ0 git clone https://github.com/cc-3/lab03-2023-MI_USUARIO.git Un par de recordatorios, si necesita ayuda con esto revise los labs anteriores para m\u00e1s detalle: Si est\u00e1 trabajando en las computadoras del lab o en alguna m\u00e1quina nueva, debe volver a hacer las configuraciones de Github. En Github usamos token en lugar de contrase\u00f1a.","title":"Preparaci\u00f3n"},{"location":"labs/lab03/#ejercicio-1-manejo-de-memoria","text":"Para este ejercicio lea los archivos tests/include/vector.h , tests/vector_test.c y luego complete el archivo ex1/vector.c , en donde les proveemos con la base para la implementaci\u00f3n de un arreglo de longitud variable. El objetivo del lab es acostumbrarse al uso de los structs de C, as\u00ed como el manejo de memoria en este lenguaje. Su tarea: Completar las funciones vector_new() , vector_get() , vector_delete() y vector_set() en ex1/vector.c de manera que tests/vector-test.c corra sin errores de manejo de memoria.","title":"Ejercicio 1: Manejo de Memoria"},{"location":"labs/lab03/#como-funciona-un-vector_t","text":"Posee un int size que indica cu\u00e1ntos elementos tiene actualmente. Un vector con size = 5 , por ejemplo, tendr\u00e1 cinco casillas con \u00edndices entre 0 y 4. Por defecto la longitud de su vector ser\u00e1 de 1. El vector debe aumentar de tama\u00f1o autom\u00e1ticamente si el vector_set() lo require. Por ejemplo, si su vector tiene size = 5 pero le piden que haga un set en la casilla con \u00edndice 200, usted debe hacer que su vector aumente de tama\u00f1o para tener 201 casillas. Revisemos esos n\u00fameros... como los \u00edndices comienzan en 0, cuando me pidan el \u00edndice 200 yo debo entender que hay 201 casillas. Tiene un int *data , el cu\u00e1l es un espacio pedido a trav\u00e9s de un malloc() que utilizaremos para guardar los valores de las casillas del vector. Los valores guardados por defecto al hacer un vector_new() deben ser cero. El valor de cualquier casilla que no ha sido expl\u00edcitamente editado es 0. El vector no debe dar error, incluso si se consulta alguna casilla que todav\u00eda no existe. Por ejemplo, su vector tiene size = 5 pero le hacen un vector_get() de la posici\u00f3n 10, esto no da error; cuando le consulten una casilla que no existe usted devuelve como respuesta un 0. Es momento de revisar el c\u00f3digo de ex1/vector.c si a\u00fan lo ha hecho. Aqu\u00ed hay comentarios complementarios que describen c\u00f3mo deber\u00edan de correr las funciones. Recuerden que los usuarios de su estructura de datos vector_t asumiran que todas las entradas al vector son 0, a menos que hayan sido definidas de otra manera por ellos. Tengan esto en mente, porque malloc no hace esto por ustedes.","title":"\u00bfC\u00f3mo funciona un vector_t?"},{"location":"labs/lab03/#que-deben-hacer","text":"Complete vector_new (). Hay seis comentarios que nos gu\u00edan paso a paso en qu\u00e9 realizar; en la mayor\u00eda solo necesita una instrucci\u00f3n, pero en un par quiz\u00e1s necesite un poquito m\u00e1s. Termine vector_get() . Piense en lo que se dijo arriba: aunque me consulten una casilla que a\u00fan no existe, debo entregar un resultado v\u00e1lido. Complementen vector_delete() . Es muy probable que le salga con solo dos l\u00edneas de c\u00f3digo, pero el orden de estas es importante. Complete vector_set() . Esta es la m\u00e1s complicada, bienvenidos a las ligas mayores. Para resolver esta parte piense en las siguientes preguntas \u00bfqu\u00e9 pasa si la posici\u00f3n donde me piden escribir a\u00fan no existe? \u00bfc\u00f3mo pido espacio adicional para que ahora ya exista esta nueva posici\u00f3n? \u00bfque valor debo colocar en las dem\u00e1s posiciones cuando expanda mi vector? Adicionalmente, ya no piense solo en malloc() sino en las otras dos funciones _alloc() . Hay algunos comentarios por all\u00ed para ayudarle. Saber c\u00f3mo reorganizar y liberar memoria es importante para la programaci\u00f3n en C. Piensen que el manejo de memoria es como un parqueo, si hay carros parqueados y los due\u00f1os nunca se van, entonces no tienen espacio para nuevos carros. Finalmente, tenga en cuenta que deber\u00eda tener un heap vac\u00edo al terminar su programa . Si no lo tenemos, hay que buscar en cu\u00e1l funci\u00f3n debemos colocar free() . Al finalizar, pruebe su programa con: make vector ./vector","title":"\u00bfQu\u00e9 deben hacer?"},{"location":"labs/lab03/#entrega-de-laboratorio","text":"Recuerde probar su laboratorio usando el autograder. ./check Este laboratorio tiene una \u00fanica serie que vale 100 puntos. Luego env\u00ede el link de su repositorio de Github en el GES . El GES tiene una opci\u00f3n para enviar links, \u00daSELA. Si env\u00eda alg\u00fan txt, pdf, zip, etc. su laboratorio no se calificar\u00e1, es decir tendr\u00e1 cero.","title":"Entrega de laboratorio"},{"location":"labs/lab04/","text":"Lab 4 - RISC-V \u00b6 Objetivos \u00b6 Traducir c\u00f3digo de C a RISC-V. Escribir funciones en RISC-V con el procedimiento correcto de llamadas a funciones. Aprender a depurar nuestros programas en Jupiter. Lecturas \u00b6 P&H: 2.12 Preparaci\u00f3n \u00b6 Para comenzar con el laboratorio primero tienen que tener todos los archivos base, estos se encuentran aqu\u00ed . Recuerden que deben aceptar la asignaci\u00f3n de Github Classroom y se les crear\u00e1 autom\u00e1ticamente un repositorio con una extensi\u00f3n que termina con su usuario de GitHub. Cuando ya se haya creado el repositorio, pueden ejecutar los siguientes comandos abriendo una terminal ( CTRL + T ): git clone https://github.com/cc-3/lab04-2023-SU-USUARIO-DE-GITHUB Introducci\u00f3n a ensamblador RISC-V \u00b6 Los siguientes ejercicios utilizan un ensamblador y simulador de RISC-V, desarrollado por el catedr\u00e1tico de la secci\u00f3n nocturna Andr\u00e9s Castellanos . El simulador se llama Jupiter (la versi\u00f3n anterior se llamaba V-Sim, por si mira ese nombre en alg\u00fan lado) y es un proyecto open source inspirado, inicialmente, en el lengendario SPIM y, posteriormente, en MARS y VENUS para la versi\u00f3n gr\u00e1fica. Para instalarlo en su computadora, siga estas instrucciones: M\u00e1quina virtual del curso Felicidades! No necesita instalar nada, puede ejecutar Jupiter usando el siguiente comando jupiter Ubuntu 20 Descargue este archivo , luego en su terminal vaya a la carpeta donde lo descarg\u00f3 y ejecute estos comandos unzip Jupiter-3.1-linux.zip sudo mv image /opt/jupiter echo 'export PATH=/opt/jupiter/bin:$PATH' >> ~/.bashrc source ~/.bashrc Despu\u00e9s de esto, ya deber\u00eda poder usar jupiter . Si aun no funciona, la vieja y confiable, reinicie su m\u00e1quina. Cosas b\u00e1sicas en Jupiter: \u00b6 A continuaci\u00f3n, les vamos a dar una peque\u00f1a gu\u00eda de Jupiter, para m\u00e1s informaci\u00f3n visiten la documentaci\u00f3n completa . Pueden crear archivos, editarlos y borrarlos desde la pesta\u00f1a \"Editor\". Los programas empiezan en la etiqueta global __start , es decir que tienen que definir una etiqueta llamada __start y declararla como global. .globl __start __start: li a0 10 ecall # exit S\u00ed, all\u00ed dice .globl , no .global . Las etiquetas terminan con dos puntos como ven en el ejemplo anterior. Los comentarios comienzan con el simbolo \"#\" o \";\". Solo pueden poner una instrucci\u00f3n por l\u00ednea. Cuando hayan terminado de escribir su c\u00f3digo, guarden y presionen F3 para ensamblar y poder ejecutar. Los programas siempre tienen que terminar con un ecall de exit y esto se logra poniendo un 10 en a0 (exactamente como el ejemplo anterior). Esto le indica al programa que tiene que terminar. Las instrucciones ecall son an\u00e1logas a los \"System Calls\" (llamadas al sistema) y nos permiten hacer cosas como imprimir a consola o reservar memoria din\u00e1mica. Ejercicio 1: Familiariz\u00e1ndote con Jupiter \u00b6 Para este ejercicio ustedes van a familiarizarse con Jupiter corriendo un programa sencillo de RISC-V y, luego, contestar\u00e1n unas preguntas. Abran la interfaz gr\u00e1fica de Jupiter, escribiendo jupiter en su terminal. Desde el editor abran el archivo llamado ex1.s que esta en la carpeta ex1 . En la barra de herramientas de Jupiter, vayan a settings y aseg\u00farense de que Assemble Only Selected Tab est\u00e9 seleccionado con un cheque verde. Guarden su programa, luego presionen F3 . Esto va a preparar el c\u00f3digo para que pueda ser ejecutado y simulado. Si hacen click a la pesta\u00f1a \"Editor\", su simulaci\u00f3n se va a reiniciar. En el simulador, para ejecutar la siguiente instrucci\u00f3n, presionen el bot\u00f3n que dice \"step\". Para regresar un paso atr\u00e1s, presionen el bot\u00f3n que dice \"backstep\". Para correr todo el programa hasta que termine, presionen el bot\u00f3n que dice \"go\". Para volver a empezar el programa nuevamente, presionen el bot\u00f3n que dice \"reset\". Para ver el contenido de los 32 registros en la parte derecha del simulador, hay una pesta\u00f1a que dice RVI . La consola est\u00e1 en la parte de abajo del simulador. Para ver el contenido de la memoria, en el mismo lugar que los registros hay una pesta\u00f1a que dice Memory , pueden navegar a diferentes secciones de la memoria haciendo click derecho encima de la tabla que muestra el estado de la memoria. Preguntas \u00b6 Ahora que ya han ejecutado su primer programa de RISC-V y que ganaron experiencia con Jupiter pueden contestar las siguientes preguntas en el archivo ex1.txt que se encuentra en la carpeta ex1 . \u00bfQu\u00e9 significan las directivas .data , .word , .text ? Escriban s\u00f3lo una de las siguientes letras para responder. Pista: Piensen acerca de las cuatro secciones de memoria. A) Son como etiquetas sirven para hacer referencia a cosas que est\u00e1n en memoria, con .data apuntamos hacia los datos con .word hacia palabras de 32 bits y con .text hacia texto. B) .data le indica al ensamblador que guarde los siguientes elementos en la secci\u00f3n est\u00e1tica de la memoria, .word que guarde una palabra de 32 bits en memoria en la secci\u00f3n est\u00e1tica de datos y .text que estamos en la secci\u00f3n de texto y entonces deber\u00edamos escribir instrucciones de ensamblador. C) .data es para guardar datos en la secci\u00f3n de datos de la memoria, .word es para guardar palabras de 32 bits en la secci\u00f3n de palabras de la memoria, .text es para guardar texto ascii en la secci\u00f3n de texto de la memoria. D) .data y .word no son directivas de ensamblador, y .text siempre est\u00e1 por defecto y ni se tendr\u00eda que poner. Corran por completo el programa. \u00bfQu\u00e9 n\u00famero da como output? \u00bfQu\u00e9 representa el n\u00famero que da como output el programa? Escriban s\u00f3lo una de las siguientes letras para responder: A) N\u00famero \u00e1ureo B) Factorial de 9 C) Fibonnaci de 9 D) Factorial de 10 \u00bfEn qu\u00e9 direcci\u00f3n de memoria (en hexadecimal) est\u00e1 almacenado n ? Pista: Miren el contenido de los registros. Sin utilizar la pesta\u00f1a \"Editor\", hagan que el programa calcule el 13\u00ba n\u00famero (tomando en cuenta que el \u00edndice empieza en 0) de la sucesi\u00f3n de Fibonacci, modificando manualmente el valor de un registro. Encontrar\u00e1n \u00fatil de primero correr l\u00ednea por l\u00ednea el c\u00f3digo. Si prefieren ver los valores en decimal, cambien esto haciendo click derecho sobre la tabla de registros y presionando \"Decimal Display Mode\". \u00bfQu\u00e9 registro modificaron? Ejercicio 2: Traduciendo de C a RISC-V \u00b6 Desde Jupiter abran el archivo ex2.s que est\u00e1 en la carpeta ex2 , desde alg\u00fan editor de texto de su preferencia abran ex2.c que est\u00e1 en la misma carpeta. El c\u00f3digo ensamblador que se provee (archivo ex2.s) es una traducci\u00f3n del programa escrito en C (archivo ex2.c) pero en RISC-V. Su tarea es encontrar/explicar los siguientes componentes de este archivo escrito en lenguaje ensamblador en el archivo de texto llamado ex2.txt . Preguntas \u00b6 \u00bfCu\u00e1l es el registro que representa la variable k ? \u00bfCu\u00e1les son los registros que act\u00faan como punteros a los arreglos source y dest (separados por coma)? \u00bfDe qu\u00e9 n\u00famero de l\u00ednea a que n\u00famero l\u00ednea se encuentra el loop (separado por coma)? \u00bfEn qu\u00e9 n\u00famero de l\u00ednea se copia el contenido de source a dest ?, es decir \u00bfd\u00f3nde se puede observar dest[k] = source[k] ?. \u00bfC\u00f3mo son manipulados los punteros en el c\u00f3digo? Escriban s\u00f3lo una de las siguientes letras para responder: A) En cada iteraci\u00f3n se le suma k a cada puntero, que es el equivalente en C a arreglo[k] . B) En cada iteraci\u00f3n se le suma k * 4 a cada puntero, que es equivalente en C a arreglo[k] . C) En cada iteraci\u00f3n se le hace corrimiento l\u00f3gico a la derecha a cada puntero, que es equivalente en C a arreglo[k] . D) En cada iteraci\u00f3n se le suma +1 a cada puntero, que es equivalente en C a arreglo[k] . Ejercicio 3: Factorial \u00b6 En este ejercicio, tienen que implementar la funci\u00f3n de factorial en RISC-V que toma un s\u00f3lo par\u00e1metro entero $n$ y retorna $n!$. Pueden encontrar un esqueleto de esta funci\u00f3n en el archivo factorial.s , que se encuentra en la carpeta ex3 del repositorio que clonaron. Ustedes s\u00f3lo necesitan agregar las instrucciones bajo la etiqueta factorial , y el argumento que se pasa a la funci\u00f3n va en el registro a0 . Pueden resolver este problema ya sea de forma recursiva o iterativa. Aseg\u00farense de que su funci\u00f3n retorne de forma apropidada lo siguiente $3! = 6$, $7! = 5040$ y $8! = 40320$. Ejercicio 4: List Map (extra) \u00b6 Para este ejercicio van a utilizar el archivo list_map.s que se encuentra en la carpeta ex4 . En este ejercicio, van a completar una funci\u00f3n de map con listas encadenadas en RISC-V. La funci\u00f3n se simplificar\u00e1 en mutar la lista en cuesti\u00f3n, es decir que tomar\u00e1 una lista encadenada como entrada y va a retornar la lista con los valores modificados. Nuestro procedimiento de \"map\" toma dos par\u00e1metros, el primero ser\u00e1 la direcci\u00f3n del nodo \"head\" de una lista encadenada, cuyos valores son enteros de 32 bits. Entonces, en C, la estructura se define como: struct node { int value ; struct node * next ; }; El segundo par\u00e1metro ser\u00e1 la direcci\u00f3n de una funci\u00f3n que toma un entero como argumento y devuelve un entero. Usaremos la instrucci\u00f3n jalr de RISC-V para llamar a esta funci\u00f3n con los valores de cada nodo de la lista. Nuestra funci\u00f3n map ir\u00e1 recorriendo la lista recursivamente, aplicando la funci\u00f3n a cada valor de la lista y almacenando el valor devuelto al nodo correspondiente. En C, la funci\u00f3n se ver\u00eda algo como esta: void map ( struct node * head , int ( * f )( int )) { if ( ! head ) { return ; } head -> value = f ( head -> value ); map ( head -> next , f ); } Si no hab\u00edan algo como int (*f)(int) antes, no se preocupen demasiado. Significa b\u00e1sicamente que f es un puntero a una funci\u00f3n de C, y esta funci\u00f3n recibe un int como argumento. f entonces puede ser utilizado exactamente como cualquier otra funci\u00f3n. Les ser\u00e1 \u00fatil acudir al green card de RISC-V que pueden encontrar aqu\u00ed para completar este ejercicio. Hay exactamente 9 espacios (8 en map y 1 en main ) en el c\u00f3digo que se provee, donde dice YOUR_INSTRUCTION_HERE . Reemplacen esos espacios con las instrucciones de su implementaci\u00f3n de map, y escriban una simple llamada a map con square como argumento de la funci\u00f3n. Hay comentarios en el c\u00f3digo que explican qu\u00e9 deber\u00eda hacer, o cumplir, cada instrucci\u00f3n. Cuando hayan rellenado los espacios con las instrucciones correctas, pueden correr el c\u00f3digo pulsando en F3 y luego el bot\u00f3n go , al hacer esto, deber\u00eda de darles como output lo siguiente: 9 8 7 6 5 4 3 2 1 0 81 64 49 36 25 16 9 4 1 0 La primera l\u00ednea es la lista original, y la segunda es la lista modificada despu\u00e9s de que se aplic\u00f3 la funci\u00f3n map . Calificaci\u00f3n \u00b6 Si est\u00e1 usando nuestra m\u00e1quina virtual (es decir, ya ten\u00eda Jupiter pre-instalado), para conocer su nota use el comando: ./check Si est\u00e1 usando su propio Linux y le toc\u00f3 instalar Jupiter a usted mismo, use el comando: ./check -x Cuando est\u00e9 satisfecho con su nota haga add, commit y push. Luego suba el link de su repositorio al GES.","title":"4: Intro a RISC-V"},{"location":"labs/lab04/#lab-4-risc-v","text":"","title":"Lab 4 - RISC-V"},{"location":"labs/lab04/#objetivos","text":"Traducir c\u00f3digo de C a RISC-V. Escribir funciones en RISC-V con el procedimiento correcto de llamadas a funciones. Aprender a depurar nuestros programas en Jupiter.","title":"Objetivos"},{"location":"labs/lab04/#lecturas","text":"P&H: 2.12","title":"Lecturas"},{"location":"labs/lab04/#preparacion","text":"Para comenzar con el laboratorio primero tienen que tener todos los archivos base, estos se encuentran aqu\u00ed . Recuerden que deben aceptar la asignaci\u00f3n de Github Classroom y se les crear\u00e1 autom\u00e1ticamente un repositorio con una extensi\u00f3n que termina con su usuario de GitHub. Cuando ya se haya creado el repositorio, pueden ejecutar los siguientes comandos abriendo una terminal ( CTRL + T ): git clone https://github.com/cc-3/lab04-2023-SU-USUARIO-DE-GITHUB","title":"Preparaci\u00f3n"},{"location":"labs/lab04/#introduccion-a-ensamblador-risc-v","text":"Los siguientes ejercicios utilizan un ensamblador y simulador de RISC-V, desarrollado por el catedr\u00e1tico de la secci\u00f3n nocturna Andr\u00e9s Castellanos . El simulador se llama Jupiter (la versi\u00f3n anterior se llamaba V-Sim, por si mira ese nombre en alg\u00fan lado) y es un proyecto open source inspirado, inicialmente, en el lengendario SPIM y, posteriormente, en MARS y VENUS para la versi\u00f3n gr\u00e1fica. Para instalarlo en su computadora, siga estas instrucciones: M\u00e1quina virtual del curso Felicidades! No necesita instalar nada, puede ejecutar Jupiter usando el siguiente comando jupiter Ubuntu 20 Descargue este archivo , luego en su terminal vaya a la carpeta donde lo descarg\u00f3 y ejecute estos comandos unzip Jupiter-3.1-linux.zip sudo mv image /opt/jupiter echo 'export PATH=/opt/jupiter/bin:$PATH' >> ~/.bashrc source ~/.bashrc Despu\u00e9s de esto, ya deber\u00eda poder usar jupiter . Si aun no funciona, la vieja y confiable, reinicie su m\u00e1quina.","title":"Introducci\u00f3n a ensamblador RISC-V"},{"location":"labs/lab04/#cosas-basicas-en-jupiter","text":"A continuaci\u00f3n, les vamos a dar una peque\u00f1a gu\u00eda de Jupiter, para m\u00e1s informaci\u00f3n visiten la documentaci\u00f3n completa . Pueden crear archivos, editarlos y borrarlos desde la pesta\u00f1a \"Editor\". Los programas empiezan en la etiqueta global __start , es decir que tienen que definir una etiqueta llamada __start y declararla como global. .globl __start __start: li a0 10 ecall # exit S\u00ed, all\u00ed dice .globl , no .global . Las etiquetas terminan con dos puntos como ven en el ejemplo anterior. Los comentarios comienzan con el simbolo \"#\" o \";\". Solo pueden poner una instrucci\u00f3n por l\u00ednea. Cuando hayan terminado de escribir su c\u00f3digo, guarden y presionen F3 para ensamblar y poder ejecutar. Los programas siempre tienen que terminar con un ecall de exit y esto se logra poniendo un 10 en a0 (exactamente como el ejemplo anterior). Esto le indica al programa que tiene que terminar. Las instrucciones ecall son an\u00e1logas a los \"System Calls\" (llamadas al sistema) y nos permiten hacer cosas como imprimir a consola o reservar memoria din\u00e1mica.","title":"Cosas b\u00e1sicas en Jupiter:"},{"location":"labs/lab04/#ejercicio-1-familiarizandote-con-jupiter","text":"Para este ejercicio ustedes van a familiarizarse con Jupiter corriendo un programa sencillo de RISC-V y, luego, contestar\u00e1n unas preguntas. Abran la interfaz gr\u00e1fica de Jupiter, escribiendo jupiter en su terminal. Desde el editor abran el archivo llamado ex1.s que esta en la carpeta ex1 . En la barra de herramientas de Jupiter, vayan a settings y aseg\u00farense de que Assemble Only Selected Tab est\u00e9 seleccionado con un cheque verde. Guarden su programa, luego presionen F3 . Esto va a preparar el c\u00f3digo para que pueda ser ejecutado y simulado. Si hacen click a la pesta\u00f1a \"Editor\", su simulaci\u00f3n se va a reiniciar. En el simulador, para ejecutar la siguiente instrucci\u00f3n, presionen el bot\u00f3n que dice \"step\". Para regresar un paso atr\u00e1s, presionen el bot\u00f3n que dice \"backstep\". Para correr todo el programa hasta que termine, presionen el bot\u00f3n que dice \"go\". Para volver a empezar el programa nuevamente, presionen el bot\u00f3n que dice \"reset\". Para ver el contenido de los 32 registros en la parte derecha del simulador, hay una pesta\u00f1a que dice RVI . La consola est\u00e1 en la parte de abajo del simulador. Para ver el contenido de la memoria, en el mismo lugar que los registros hay una pesta\u00f1a que dice Memory , pueden navegar a diferentes secciones de la memoria haciendo click derecho encima de la tabla que muestra el estado de la memoria.","title":"Ejercicio 1: Familiariz\u00e1ndote con Jupiter"},{"location":"labs/lab04/#preguntas","text":"Ahora que ya han ejecutado su primer programa de RISC-V y que ganaron experiencia con Jupiter pueden contestar las siguientes preguntas en el archivo ex1.txt que se encuentra en la carpeta ex1 . \u00bfQu\u00e9 significan las directivas .data , .word , .text ? Escriban s\u00f3lo una de las siguientes letras para responder. Pista: Piensen acerca de las cuatro secciones de memoria. A) Son como etiquetas sirven para hacer referencia a cosas que est\u00e1n en memoria, con .data apuntamos hacia los datos con .word hacia palabras de 32 bits y con .text hacia texto. B) .data le indica al ensamblador que guarde los siguientes elementos en la secci\u00f3n est\u00e1tica de la memoria, .word que guarde una palabra de 32 bits en memoria en la secci\u00f3n est\u00e1tica de datos y .text que estamos en la secci\u00f3n de texto y entonces deber\u00edamos escribir instrucciones de ensamblador. C) .data es para guardar datos en la secci\u00f3n de datos de la memoria, .word es para guardar palabras de 32 bits en la secci\u00f3n de palabras de la memoria, .text es para guardar texto ascii en la secci\u00f3n de texto de la memoria. D) .data y .word no son directivas de ensamblador, y .text siempre est\u00e1 por defecto y ni se tendr\u00eda que poner. Corran por completo el programa. \u00bfQu\u00e9 n\u00famero da como output? \u00bfQu\u00e9 representa el n\u00famero que da como output el programa? Escriban s\u00f3lo una de las siguientes letras para responder: A) N\u00famero \u00e1ureo B) Factorial de 9 C) Fibonnaci de 9 D) Factorial de 10 \u00bfEn qu\u00e9 direcci\u00f3n de memoria (en hexadecimal) est\u00e1 almacenado n ? Pista: Miren el contenido de los registros. Sin utilizar la pesta\u00f1a \"Editor\", hagan que el programa calcule el 13\u00ba n\u00famero (tomando en cuenta que el \u00edndice empieza en 0) de la sucesi\u00f3n de Fibonacci, modificando manualmente el valor de un registro. Encontrar\u00e1n \u00fatil de primero correr l\u00ednea por l\u00ednea el c\u00f3digo. Si prefieren ver los valores en decimal, cambien esto haciendo click derecho sobre la tabla de registros y presionando \"Decimal Display Mode\". \u00bfQu\u00e9 registro modificaron?","title":"Preguntas"},{"location":"labs/lab04/#ejercicio-2-traduciendo-de-c-a-risc-v","text":"Desde Jupiter abran el archivo ex2.s que est\u00e1 en la carpeta ex2 , desde alg\u00fan editor de texto de su preferencia abran ex2.c que est\u00e1 en la misma carpeta. El c\u00f3digo ensamblador que se provee (archivo ex2.s) es una traducci\u00f3n del programa escrito en C (archivo ex2.c) pero en RISC-V. Su tarea es encontrar/explicar los siguientes componentes de este archivo escrito en lenguaje ensamblador en el archivo de texto llamado ex2.txt .","title":"Ejercicio 2: Traduciendo de C a RISC-V"},{"location":"labs/lab04/#preguntas_1","text":"\u00bfCu\u00e1l es el registro que representa la variable k ? \u00bfCu\u00e1les son los registros que act\u00faan como punteros a los arreglos source y dest (separados por coma)? \u00bfDe qu\u00e9 n\u00famero de l\u00ednea a que n\u00famero l\u00ednea se encuentra el loop (separado por coma)? \u00bfEn qu\u00e9 n\u00famero de l\u00ednea se copia el contenido de source a dest ?, es decir \u00bfd\u00f3nde se puede observar dest[k] = source[k] ?. \u00bfC\u00f3mo son manipulados los punteros en el c\u00f3digo? Escriban s\u00f3lo una de las siguientes letras para responder: A) En cada iteraci\u00f3n se le suma k a cada puntero, que es el equivalente en C a arreglo[k] . B) En cada iteraci\u00f3n se le suma k * 4 a cada puntero, que es equivalente en C a arreglo[k] . C) En cada iteraci\u00f3n se le hace corrimiento l\u00f3gico a la derecha a cada puntero, que es equivalente en C a arreglo[k] . D) En cada iteraci\u00f3n se le suma +1 a cada puntero, que es equivalente en C a arreglo[k] .","title":"Preguntas"},{"location":"labs/lab04/#ejercicio-3-factorial","text":"En este ejercicio, tienen que implementar la funci\u00f3n de factorial en RISC-V que toma un s\u00f3lo par\u00e1metro entero $n$ y retorna $n!$. Pueden encontrar un esqueleto de esta funci\u00f3n en el archivo factorial.s , que se encuentra en la carpeta ex3 del repositorio que clonaron. Ustedes s\u00f3lo necesitan agregar las instrucciones bajo la etiqueta factorial , y el argumento que se pasa a la funci\u00f3n va en el registro a0 . Pueden resolver este problema ya sea de forma recursiva o iterativa. Aseg\u00farense de que su funci\u00f3n retorne de forma apropidada lo siguiente $3! = 6$, $7! = 5040$ y $8! = 40320$.","title":"Ejercicio 3: Factorial"},{"location":"labs/lab04/#ejercicio-4-list-map-extra","text":"Para este ejercicio van a utilizar el archivo list_map.s que se encuentra en la carpeta ex4 . En este ejercicio, van a completar una funci\u00f3n de map con listas encadenadas en RISC-V. La funci\u00f3n se simplificar\u00e1 en mutar la lista en cuesti\u00f3n, es decir que tomar\u00e1 una lista encadenada como entrada y va a retornar la lista con los valores modificados. Nuestro procedimiento de \"map\" toma dos par\u00e1metros, el primero ser\u00e1 la direcci\u00f3n del nodo \"head\" de una lista encadenada, cuyos valores son enteros de 32 bits. Entonces, en C, la estructura se define como: struct node { int value ; struct node * next ; }; El segundo par\u00e1metro ser\u00e1 la direcci\u00f3n de una funci\u00f3n que toma un entero como argumento y devuelve un entero. Usaremos la instrucci\u00f3n jalr de RISC-V para llamar a esta funci\u00f3n con los valores de cada nodo de la lista. Nuestra funci\u00f3n map ir\u00e1 recorriendo la lista recursivamente, aplicando la funci\u00f3n a cada valor de la lista y almacenando el valor devuelto al nodo correspondiente. En C, la funci\u00f3n se ver\u00eda algo como esta: void map ( struct node * head , int ( * f )( int )) { if ( ! head ) { return ; } head -> value = f ( head -> value ); map ( head -> next , f ); } Si no hab\u00edan algo como int (*f)(int) antes, no se preocupen demasiado. Significa b\u00e1sicamente que f es un puntero a una funci\u00f3n de C, y esta funci\u00f3n recibe un int como argumento. f entonces puede ser utilizado exactamente como cualquier otra funci\u00f3n. Les ser\u00e1 \u00fatil acudir al green card de RISC-V que pueden encontrar aqu\u00ed para completar este ejercicio. Hay exactamente 9 espacios (8 en map y 1 en main ) en el c\u00f3digo que se provee, donde dice YOUR_INSTRUCTION_HERE . Reemplacen esos espacios con las instrucciones de su implementaci\u00f3n de map, y escriban una simple llamada a map con square como argumento de la funci\u00f3n. Hay comentarios en el c\u00f3digo que explican qu\u00e9 deber\u00eda hacer, o cumplir, cada instrucci\u00f3n. Cuando hayan rellenado los espacios con las instrucciones correctas, pueden correr el c\u00f3digo pulsando en F3 y luego el bot\u00f3n go , al hacer esto, deber\u00eda de darles como output lo siguiente: 9 8 7 6 5 4 3 2 1 0 81 64 49 36 25 16 9 4 1 0 La primera l\u00ednea es la lista original, y la segunda es la lista modificada despu\u00e9s de que se aplic\u00f3 la funci\u00f3n map .","title":"Ejercicio 4:  List Map (extra)"},{"location":"labs/lab04/#calificacion","text":"Si est\u00e1 usando nuestra m\u00e1quina virtual (es decir, ya ten\u00eda Jupiter pre-instalado), para conocer su nota use el comando: ./check Si est\u00e1 usando su propio Linux y le toc\u00f3 instalar Jupiter a usted mismo, use el comando: ./check -x Cuando est\u00e9 satisfecho con su nota haga add, commit y push. Luego suba el link de su repositorio al GES.","title":"Calificaci\u00f3n"},{"location":"labs/lab05/","text":"Lab 4 - RISC-V \u00b6 Objetivos \u00b6 Divertirse con RISC-V Encontrar los errores de Ali Hacer algo imposible Pensar en la idea de hacer lo imposible Lecturas \u00b6 P&H: 2.12 Preparaci\u00f3n \u00b6 Para comenzar con el laboratorio primero tienen que tener todos los archivos base, estos se encuentran aqu\u00ed . Recuerden que deben aceptar la asignaci\u00f3n de GitHub Classroom y se les crear\u00e1 autom\u00e1ticamente un repositorio con una extensi\u00f3n que termina con su usuario de GitHub. Cuando ya se haya creado el repositorio, pueden ejecutar los siguientes comandos abriendo una terminal ( CTRL + T ): git clone <link del repositorio> NOTA : Tienen que reemplazar <link del repositorio> con el link del repositorio que se cre\u00f3. Ejercicio 1: Depurando megalistmanips.s \u00b6 Hace mucho tiempo, su catedr\u00e1tico Ali era un principiante en RISC-V, y escribi\u00f3 su soluci\u00f3n a un lab en este archivo: megalistmanips.s . Ustedes, ahora que ya son expertos en RISC-V, deben arreglar los bugs que cometi\u00f3 Ali. El objetivo principal de este ejercicio es que encuentren los errores en la funci\u00f3n map en megalistmanips.s . Antes de hacer eso, familiar\u00edcense con lo que la funci\u00f3n trata de hacer. En el lab anterior, ten\u00edamos una lista encadenada de enteros, ahora nuestra estructura de datos es una lista encadena cuyo valor en cada nodo es un arreglo de enteros. Recuerden que cuando se trabaja con arreglos en structs, necesitamos almacenar expl\u00edcitamente el tama\u00f1o del array. En c\u00f3digo de C, el struct se ver\u00eda as\u00ed: struct node { int * arr ; int size ; struct node * next ; }; Aqu\u00ed tambi\u00e9n est\u00e1 lo que la nueva funci\u00f3n map hace: atraviesa la lista encadenada y para cada elemento del arreglo de cada nodo, aplica la funci\u00f3n y vuelve a guardarlo en el array. En C, esto se mirar\u00eda de la siguiente manera: void map ( struct node * head , int ( * f )( int )) { if ( ! head ) { return ; } for ( int i = 0 ; i < head -> size ; i ++ ) { head -> arr [ i ] = f ( head -> arr [ i ]); } map ( head -> next , f ); } Lean todos los comentarios en la funci\u00f3n map en megalistmanips.s (antes de que retorne con jr ra ), y aseg\u00farense de que las l\u00edneas hagan lo que el comentario dice. Algunas pistas: \u00bfPor qu\u00e9 necesitamos guardar cosas en el stack antes de llamar a jal ? \u00bfCu\u00e1l es la diferencia entre add t0, s0, x0 y lw t0, 0(s0) ? Presten atenci\u00f3n a los tipos de los atributos en el struct . \u00a1Gracias por hacer el ejercicio! Estamos seguros de que Ali se estar\u00e1 preguntando d\u00f3nde estaban para ayudarlo cuando no entend\u00eda RISC-V hace un tiempo atr\u00e1s. Ejercicio 2: Escriban una funci\u00f3n sin utilizar branches \u00b6 Consideren la funci\u00f3n $f$ de valor discreto definida en el set de enteros ${-3, -2, -1, 0, 1, 2, 3}$. Esta es la definici\u00f3n de la funci\u00f3n: $\\begin{align} &f(-3) = 6\\\\ &f(-2) = 61\\\\ &f(-1) = 17\\\\ &f(0) = -38\\\\ &f(1) = 19\\\\ &f(2) = 42\\\\ &f(3) = 5 \\end{align}$ No les vamos a mentir, es una funci\u00f3n muy tonta. Sin embargo, su tarea es implementarla en RISC-V, con la condici\u00f3n de que NO pueden utilizar las instrucciones de branch por ning\u00fan motivo. Por suerte alguna persona ha dejado por accidente un array de enteros en la secci\u00f3n .data de discrete_fn.s . \u00bfC\u00f3mo pueden utilizarlo para tener ventaja sobre eso y completar esta tarea que aparenta ser imposible? Calificaci\u00f3n \u00b6 Cuando hayan terminado su laboratorio, o crean que est\u00e1n listos para obtener su nota, pueden subir su laboratorio al autograder utilizando: ./submit <TOKEN> NOTA : Tienen que reemplazar <TOKEN> por el token que les da la siguiente p\u00e1gina Luego, cuando haya sido calificado, pueden ver su resultado en https://dashboard.cc-3.site/ .","title":"5: RISC-V"},{"location":"labs/lab05/#lab-4-risc-v","text":"","title":"Lab 4 - RISC-V"},{"location":"labs/lab05/#objetivos","text":"Divertirse con RISC-V Encontrar los errores de Ali Hacer algo imposible Pensar en la idea de hacer lo imposible","title":"Objetivos"},{"location":"labs/lab05/#lecturas","text":"P&H: 2.12","title":"Lecturas"},{"location":"labs/lab05/#preparacion","text":"Para comenzar con el laboratorio primero tienen que tener todos los archivos base, estos se encuentran aqu\u00ed . Recuerden que deben aceptar la asignaci\u00f3n de GitHub Classroom y se les crear\u00e1 autom\u00e1ticamente un repositorio con una extensi\u00f3n que termina con su usuario de GitHub. Cuando ya se haya creado el repositorio, pueden ejecutar los siguientes comandos abriendo una terminal ( CTRL + T ): git clone <link del repositorio> NOTA : Tienen que reemplazar <link del repositorio> con el link del repositorio que se cre\u00f3.","title":"Preparaci\u00f3n"},{"location":"labs/lab05/#ejercicio-1-depurando-megalistmanipss","text":"Hace mucho tiempo, su catedr\u00e1tico Ali era un principiante en RISC-V, y escribi\u00f3 su soluci\u00f3n a un lab en este archivo: megalistmanips.s . Ustedes, ahora que ya son expertos en RISC-V, deben arreglar los bugs que cometi\u00f3 Ali. El objetivo principal de este ejercicio es que encuentren los errores en la funci\u00f3n map en megalistmanips.s . Antes de hacer eso, familiar\u00edcense con lo que la funci\u00f3n trata de hacer. En el lab anterior, ten\u00edamos una lista encadenada de enteros, ahora nuestra estructura de datos es una lista encadena cuyo valor en cada nodo es un arreglo de enteros. Recuerden que cuando se trabaja con arreglos en structs, necesitamos almacenar expl\u00edcitamente el tama\u00f1o del array. En c\u00f3digo de C, el struct se ver\u00eda as\u00ed: struct node { int * arr ; int size ; struct node * next ; }; Aqu\u00ed tambi\u00e9n est\u00e1 lo que la nueva funci\u00f3n map hace: atraviesa la lista encadenada y para cada elemento del arreglo de cada nodo, aplica la funci\u00f3n y vuelve a guardarlo en el array. En C, esto se mirar\u00eda de la siguiente manera: void map ( struct node * head , int ( * f )( int )) { if ( ! head ) { return ; } for ( int i = 0 ; i < head -> size ; i ++ ) { head -> arr [ i ] = f ( head -> arr [ i ]); } map ( head -> next , f ); } Lean todos los comentarios en la funci\u00f3n map en megalistmanips.s (antes de que retorne con jr ra ), y aseg\u00farense de que las l\u00edneas hagan lo que el comentario dice. Algunas pistas: \u00bfPor qu\u00e9 necesitamos guardar cosas en el stack antes de llamar a jal ? \u00bfCu\u00e1l es la diferencia entre add t0, s0, x0 y lw t0, 0(s0) ? Presten atenci\u00f3n a los tipos de los atributos en el struct . \u00a1Gracias por hacer el ejercicio! Estamos seguros de que Ali se estar\u00e1 preguntando d\u00f3nde estaban para ayudarlo cuando no entend\u00eda RISC-V hace un tiempo atr\u00e1s.","title":"Ejercicio 1: Depurando megalistmanips.s"},{"location":"labs/lab05/#ejercicio-2-escriban-una-funcion-sin-utilizar-branches","text":"Consideren la funci\u00f3n $f$ de valor discreto definida en el set de enteros ${-3, -2, -1, 0, 1, 2, 3}$. Esta es la definici\u00f3n de la funci\u00f3n: $\\begin{align} &f(-3) = 6\\\\ &f(-2) = 61\\\\ &f(-1) = 17\\\\ &f(0) = -38\\\\ &f(1) = 19\\\\ &f(2) = 42\\\\ &f(3) = 5 \\end{align}$ No les vamos a mentir, es una funci\u00f3n muy tonta. Sin embargo, su tarea es implementarla en RISC-V, con la condici\u00f3n de que NO pueden utilizar las instrucciones de branch por ning\u00fan motivo. Por suerte alguna persona ha dejado por accidente un array de enteros en la secci\u00f3n .data de discrete_fn.s . \u00bfC\u00f3mo pueden utilizarlo para tener ventaja sobre eso y completar esta tarea que aparenta ser imposible?","title":"Ejercicio 2: Escriban una funci\u00f3n sin utilizar branches"},{"location":"labs/lab05/#calificacion","text":"Cuando hayan terminado su laboratorio, o crean que est\u00e1n listos para obtener su nota, pueden subir su laboratorio al autograder utilizando: ./submit <TOKEN> NOTA : Tienen que reemplazar <TOKEN> por el token que les da la siguiente p\u00e1gina Luego, cuando haya sido calificado, pueden ver su resultado en https://dashboard.cc-3.site/ .","title":"Calificaci\u00f3n"},{"location":"labs/lab06/","text":"Lab 5 - Logisim \u00b6 Objetivos \u00b6 Aprender a usar Logisim y simular circuitos en dicho programa. Aprender las herramientas b\u00e1sicas y el funcionamiento de Logisim. Preparaci\u00f3n \u00b6 Para este laboratorio, es necesaria la aplicaci\u00f3n Logisim. La cual se puede descargar en este link . Tambi\u00e9n tienen que tener todos los archivos base, estos se encuentran aqu\u00ed . Recuerden que deben aceptar la asignaci\u00f3n de GitHub Classroom y se les crear\u00e1 autom\u00e1ticamente un repositorio con una extensi\u00f3n que termina con su usuario de GitHub. Cuando ya se haya creado el repositorio, pueden ejecutar los siguientes comandos abriendo una terminal ( CTRL + T ): git clone <link del repositorio> Vista General \u00b6 Logisim es una aplicaci\u00f3n que permite simular el comportamiento de circuitos l\u00f3gicos. Al abrir la aplicaci\u00f3n de Logisim, la interfaz gr\u00e1fica est\u00e1 dividida en tres partes fundamentales: \u00c1rea de Trabajo. Secci\u00f3n de Componentes. Secci\u00f3n de Herramientas de acceso directo. La secci\u00f3n de \u00e1rea de trabajo est\u00e1 compuesta por todo el espacio en blanco con puntos negros. Aqu\u00ed se pueden colocar componentes, conectarlos entre s\u00ed utilizando cables. La secci\u00f3n de componentes est\u00e1 ubicada en el lado izquierdo de la interfaz. Es una ventanilla que contiene numerosas carpetas que contienen los componentes. La secci\u00f3n de herramientas de acceso directo est\u00e1 ubicada en el lado superior izquierdo. Este posee \u00edconos para la realizaci\u00f3n de distintas tareas. Entre dichos \u00edconos se encuentran: Permite interactuar con el circuito, cambiando valores. Es llamado \u201cPoke\u201d en ingl\u00e9s. Permite editar un componente al seleccionarlo y permite crear o editar cables. Es llamado \u201cSelect Tool\u201d en ingl\u00e9s. Permite crear texto en el \u00e1rea de trabajo. Este es un acceso directo al componente llamado \u201cInput Pin\u201d. Permite crear entradas al circuito. Este es un acceso directo al componente llamado \u201cOutput Pin\u201d. Permite crear salidas de los circuitos. Este es un acceso directo a la compuerta l\u00f3gica \u201cNot\u201d. Permite crear compuertas l\u00f3gicas de tipo \u201cAnd\u201d. Generacompuertas l\u00f3gicas de tipo \u201cOr\u201d. Por el momento, estas son las herramientas que se van a necesitar para este laboratorio. Ejercicio 0: Las Bases \u00b6 Este ejercicio consiste en crear su primer circuito (\u00a1yay! :D). Empecemos con un circuito simple. En el \u00e1rea de herramientas o acceso directo, hacer click en el \u00edcono de la compuerta \u201cAnd\u201d. Esto crear\u00e1 una sombra de dicha compuerta que seguir\u00e1 el cursor en el \u00e1rea de trabajo. Colocar la compuerta en el \u00e1rea de trabajo. Basta con hacer click otra vez para colocar dicho componente. Tambi\u00e9n, se pueden rotar los componentes presionando las teclas de flechas del teclado. Se pueden colocar en la orientaci\u00f3n deseada, pero para este laboratorio, colocar la compuerta en orientaci\u00f3n \u201cEste\u201d. La orientaci\u00f3n de un componente puede ser alterado al seleccionarlo y buscar la opci\u00f3n \u201cOrientaci\u00f3n\u201d u \u201cOrientation\u201d.(Asegur\u00e1ndose de que el \u00edcono de est\u00e9 activo). Los pines de entrada y salida ya han sido colocados, ustedes no tienen que modificar/reemplazar/alterar/cambiar estos pines sino el autograder no les va a funcionar y tendr\u00e1n que volver a descargar los archivos base nuevamente para que les funcione, en otras palabras empezar de nuevo de lo contrario tendr\u00e1n una nota de 0 . Hasta este punto su circuito debe verse as\u00ed: Luego, hacer click en \u201cSelect Tool\u201d, y conectar los Input Pins y el Output Pin con la compuerta And creando cables entre ellos (Al mantener presionado el bot\u00f3n izquierdo del mouse, se puede crear un cable del largo deseado y, al soltarlo, dicho bot\u00f3n el cable se crear\u00e1. \u00a1Ojo! S\u00f3lo se pueden crear cables horizontales y verticales.) El circuito debe lucir algo parecido a esto: Y por \u00faltimo, hacer click en \u201cPoke\u201d y presionar los Input Pins para interactuar con ellos. Observar que el Output Pin cambia en funci\u00f3n de los valores de los Input Pins . \u00a1Y listo! El primer circuito est\u00e1 listo. Ejercicio 1: NAND, NOR, XOR y Multiplexores \u00b6 Ahora es momento para crear circuitos m\u00e1s complejos, van a trabajar en el archivo ex1.circ . Se dar\u00e1n cuenta que en la parte izquierda aparecen 5 subcircuitos que tienen que completar ( NAND, NOR, XOR, 2-1 MUX, 4-1 MUX ). En los proyectos de Logisim se pueden crear subcircuitos para mantener organizados los circuitos, ayudando a la est\u00e9tica del proyecto. Para crear un nuevo subcircuito tienen que ir a (Proyecto -> A\u00f1adir Circuito) y escribir el nombre del subcircuito, pero esto lo tendr\u00e1n que hacer m\u00e1s adelante en el proyecto 2, por ahora ya est\u00e1n creados por ustedes. Si quieren tener m\u00e1s informaci\u00f3n o est\u00e1n interesados lean la siguiente documentaci\u00f3n de logisim link . Su tarea es implementar las compuertas NAND, NOR, XOR y multiplexores 2 a 1 y 4 a 1 utilizando \u00fanicamente compuertas AND, NOT y OR . Todos los circuitos tienen ya colocados los pines de entrada y salida, nuevamente no los pueden cambiar o no funcionar\u00e1 el autograder. Cuando hayan completado un subcircuito pueden re-utilizarlo en los dem\u00e1s subcircuitos si creen que es necesario o simplifica el circuito. Para esto tienen que estar en otro subcircuito y hacer click en el subcircuito que ya han terminado y lo pueden utilizar como cualquier otro componente. Por ejemplo en la imagen que se muestra a continuaci\u00f3n se utiliza en el subcircuito NOR, el subcircuito NAND. Nota : Para los circuitos que simulan los respectivos multiplexores. Se deben seguir las siguientes normas: Para el Multiplexor 2 a 1 de 1 bit: Para el Multiplexor 4 a 1 de 1 bit: Recordar no usar las compuertas l\u00f3gicas NOR, XOR ni los multiplexores que vienen por defecto. Ejercicio 2: Contador \u00b6 Ya sabiendo sobre circuitos y subcircuitos, ahora se har\u00e1 un circuito m\u00e1s complejo aplicando todo lo aprendido en el lab hasta el momento. Sino, cuando llegue el momento de realizar un proyecto al respecto, este no tendr\u00e1 piedad de ustedes. Para este ejercicio van a estar trabajando en el archivo ex2.circ . El ejercicio consiste en realizar un contador utilizando un registro y un sumador. Lo especial de este circuito es que se empezar\u00e1 a utilizar un reloj y a utilizar m\u00e1s bits. El circuito a dise\u00f1ar es el siguiente: Los componentes a emplear se encuentran en: Los componentes utilizados son los siguientes: Sumador: Ubicado en la librer\u00eda \u201cAritm\u00e9tica\u201d. Registro: Ubicado en la librer\u00eda \u201cMemoria\u201d. Constante Num\u00e9rica: Ubicado en la librer\u00eda \u201cWiring\u201d. Reloj: Ubicado en la librer\u00eda \u201cWiring\u201d. Cabe mencionar que ahora se utilizan Output Pins de m\u00e1s de un bit, se puede aumentar el n\u00famero de bits en la configuraci\u00f3n de los componentes. Seleccionar un componente y, en el lado izquierdo, se puede encontrar el mismo men\u00fa que se usa para darle orientaci\u00f3n a los componentes y asignarles una etiqueta, en donde se est\u00e1 la opci\u00f3n de \u201cBits De Datos\u201d. Para este ejercicio ya est\u00e1 hecho esto para los Output pins , pero si tienen que hacerlo para el registro, para la constante num\u00e9rica y el sumador. Una vez se termine de construir el circuito\u2026 \u00a1es hora de simularlo! Seleccionar la opci\u00f3n \u201cSimular\u201d (ubicado en la parte superior de la pantalla) y presionar la opci\u00f3n de \u201cactivar reloj\u201d. Se podr\u00e1 notar que el circuito funciona por s\u00ed solo y que, efectivamente, cumple con su objetivo: \u00a1contar! (si se hizo correctamente). Es posible alterar la frecuencia del reloj seleccionando otra vez \u201cSimular\u201d y, luego, \u201cSeleccionar frecuencia del reloj\u201d. Con esto se puede controlar qu\u00e9 tan r\u00e1pido se contar\u00e1. Otra funci\u00f3n \u00fatil es la de \u201cResetear Simulaci\u00f3n\u201d ubicado, tambi\u00e9n, en \u201cSimular\u201d. NOTA : En lo que se simula el circuito, es posible revisar los estados de los subcircuitos. Para ello, se debe seleccionar la herramienta \u201cPoke\u201d, hacer click sobre un subcircuito en el \u00e1rea de trabajo y presionar en la lupa que aparece sobre el subcircuito. Para regresar al circuito principal, hay que hacer click en el m\u00f3dulo del circuito principal, ubicado en la secci\u00f3n de componentes. Esto no lo van a necesitar en este ejercicio, pero ser\u00e1 muy \u00fatil para el proyecto nuevamente. Ejercicio 3: AFD a L\u00f3gica Digital \u00b6 Es momento de hacer algo mucho m\u00e1s interesante: \u00a1traducir un Aut\u00f3mata Finito Determin\u00edstico a un circuito digital! En el curso de Inform\u00e1tica 3 se aprende qu\u00e9 es un AFD (o F inite S tate M achine en ingl\u00e9s). Un AFD posee estados finitos y transici\u00f3n entre estados. El AFD de este laboratorio es una variaci\u00f3n del AFD que se ha visto en clase. Este AFD posee estados y transici\u00f3n de estados, pero, adem\u00e1s de eso, necesita inputs para cambiar de estado y al cambiar de estado regresa un output. El AFD es el siguiente: La tabla de verdad de dicho aut\u00f3mata puede ser \u00fatil para visualizar lo que est\u00e1 pasando: \u00bfC\u00f3mo se lee? La primera fila de la tabla se entiende de esta manera: \u201cDado el estado 00, si el input es 0, entonces se hace una transici\u00f3n al estado 01 y devuelve un output de 1\u201d. Para este ejercicio se les provee el circuito ex3.circ . El trabajo a realizar es completar el circuito y lograr que se comporte como el AFD mostrado anteriormente. Para esto ustedes solo van a modificar 2 subcircuitos: StateBitOne y StateBitZero . Se tienen dos opciones para completar el circuito: 1) fuerza bruta o 2) imaginaci\u00f3n. Con la imaginaci\u00f3n es posible completar el circuito utilizando un total de 3 componentes, pero, si se resuelve con la fuerza bruta, el n\u00famero ser\u00e1 mucho mayor. Se tiene todas las herramientas y las pistas necesarias para terminar el ejercicio con 3 componentes. \u00a1\u00c9xitos! :D Calificaci\u00f3n \u00b6 Cuando crean que tiene ejercicios completos pueden hacer la prueba localmente escribiendo en la terminal: ./check Si todo esta correcto les saldr\u00e1 algo como esto: ___ __ __ / _ | __ __/ /____ ___ _______ ____/ /__ ____ / __ / // / __/ _ \\/ _ \\/ __/ _ \\/ _ / -_ ) __/ /_/ | _ \\_ ,_/ \\_ _/ \\_ __/ \\_ , /_/ \\_ ,_/ \\_ ,_/ \\_ _/_/ /___/ Machine Structures Great Ideas in Computer Architecture Logisim Intro Exercise Grade Message ------------------------ ------- --------- 0 . The basics ( Warm-Up ) 25 passed 1 . Sub-Circuits 25 passed 2 . Storing State 25 passed 3 . FSMs to Digital Logic 25 passed = > Score: 100 /100 Cuando hayan terminado su laboratorio, o crean que est\u00e1n listos para obtener su nota, pueden subir su laboratorio al autograder utilizando: ./submit <TOKEN> NOTA : Tienen que reemplazar <TOKEN> por el token que les da la siguiente p\u00e1gina Luego, cuando haya sido calificado, pueden ver su resultado en https://dashboard.cc-3.site/ .","title":"6: Logisim"},{"location":"labs/lab06/#lab-5-logisim","text":"","title":"Lab 5 - Logisim"},{"location":"labs/lab06/#objetivos","text":"Aprender a usar Logisim y simular circuitos en dicho programa. Aprender las herramientas b\u00e1sicas y el funcionamiento de Logisim.","title":"Objetivos"},{"location":"labs/lab06/#preparacion","text":"Para este laboratorio, es necesaria la aplicaci\u00f3n Logisim. La cual se puede descargar en este link . Tambi\u00e9n tienen que tener todos los archivos base, estos se encuentran aqu\u00ed . Recuerden que deben aceptar la asignaci\u00f3n de GitHub Classroom y se les crear\u00e1 autom\u00e1ticamente un repositorio con una extensi\u00f3n que termina con su usuario de GitHub. Cuando ya se haya creado el repositorio, pueden ejecutar los siguientes comandos abriendo una terminal ( CTRL + T ): git clone <link del repositorio>","title":"Preparaci\u00f3n"},{"location":"labs/lab06/#vista-general","text":"Logisim es una aplicaci\u00f3n que permite simular el comportamiento de circuitos l\u00f3gicos. Al abrir la aplicaci\u00f3n de Logisim, la interfaz gr\u00e1fica est\u00e1 dividida en tres partes fundamentales: \u00c1rea de Trabajo. Secci\u00f3n de Componentes. Secci\u00f3n de Herramientas de acceso directo. La secci\u00f3n de \u00e1rea de trabajo est\u00e1 compuesta por todo el espacio en blanco con puntos negros. Aqu\u00ed se pueden colocar componentes, conectarlos entre s\u00ed utilizando cables. La secci\u00f3n de componentes est\u00e1 ubicada en el lado izquierdo de la interfaz. Es una ventanilla que contiene numerosas carpetas que contienen los componentes. La secci\u00f3n de herramientas de acceso directo est\u00e1 ubicada en el lado superior izquierdo. Este posee \u00edconos para la realizaci\u00f3n de distintas tareas. Entre dichos \u00edconos se encuentran: Permite interactuar con el circuito, cambiando valores. Es llamado \u201cPoke\u201d en ingl\u00e9s. Permite editar un componente al seleccionarlo y permite crear o editar cables. Es llamado \u201cSelect Tool\u201d en ingl\u00e9s. Permite crear texto en el \u00e1rea de trabajo. Este es un acceso directo al componente llamado \u201cInput Pin\u201d. Permite crear entradas al circuito. Este es un acceso directo al componente llamado \u201cOutput Pin\u201d. Permite crear salidas de los circuitos. Este es un acceso directo a la compuerta l\u00f3gica \u201cNot\u201d. Permite crear compuertas l\u00f3gicas de tipo \u201cAnd\u201d. Generacompuertas l\u00f3gicas de tipo \u201cOr\u201d. Por el momento, estas son las herramientas que se van a necesitar para este laboratorio.","title":"Vista General"},{"location":"labs/lab06/#ejercicio-0-las-bases","text":"Este ejercicio consiste en crear su primer circuito (\u00a1yay! :D). Empecemos con un circuito simple. En el \u00e1rea de herramientas o acceso directo, hacer click en el \u00edcono de la compuerta \u201cAnd\u201d. Esto crear\u00e1 una sombra de dicha compuerta que seguir\u00e1 el cursor en el \u00e1rea de trabajo. Colocar la compuerta en el \u00e1rea de trabajo. Basta con hacer click otra vez para colocar dicho componente. Tambi\u00e9n, se pueden rotar los componentes presionando las teclas de flechas del teclado. Se pueden colocar en la orientaci\u00f3n deseada, pero para este laboratorio, colocar la compuerta en orientaci\u00f3n \u201cEste\u201d. La orientaci\u00f3n de un componente puede ser alterado al seleccionarlo y buscar la opci\u00f3n \u201cOrientaci\u00f3n\u201d u \u201cOrientation\u201d.(Asegur\u00e1ndose de que el \u00edcono de est\u00e9 activo). Los pines de entrada y salida ya han sido colocados, ustedes no tienen que modificar/reemplazar/alterar/cambiar estos pines sino el autograder no les va a funcionar y tendr\u00e1n que volver a descargar los archivos base nuevamente para que les funcione, en otras palabras empezar de nuevo de lo contrario tendr\u00e1n una nota de 0 . Hasta este punto su circuito debe verse as\u00ed: Luego, hacer click en \u201cSelect Tool\u201d, y conectar los Input Pins y el Output Pin con la compuerta And creando cables entre ellos (Al mantener presionado el bot\u00f3n izquierdo del mouse, se puede crear un cable del largo deseado y, al soltarlo, dicho bot\u00f3n el cable se crear\u00e1. \u00a1Ojo! S\u00f3lo se pueden crear cables horizontales y verticales.) El circuito debe lucir algo parecido a esto: Y por \u00faltimo, hacer click en \u201cPoke\u201d y presionar los Input Pins para interactuar con ellos. Observar que el Output Pin cambia en funci\u00f3n de los valores de los Input Pins . \u00a1Y listo! El primer circuito est\u00e1 listo.","title":"Ejercicio 0: Las Bases"},{"location":"labs/lab06/#ejercicio-1-nand-nor-xor-y-multiplexores","text":"Ahora es momento para crear circuitos m\u00e1s complejos, van a trabajar en el archivo ex1.circ . Se dar\u00e1n cuenta que en la parte izquierda aparecen 5 subcircuitos que tienen que completar ( NAND, NOR, XOR, 2-1 MUX, 4-1 MUX ). En los proyectos de Logisim se pueden crear subcircuitos para mantener organizados los circuitos, ayudando a la est\u00e9tica del proyecto. Para crear un nuevo subcircuito tienen que ir a (Proyecto -> A\u00f1adir Circuito) y escribir el nombre del subcircuito, pero esto lo tendr\u00e1n que hacer m\u00e1s adelante en el proyecto 2, por ahora ya est\u00e1n creados por ustedes. Si quieren tener m\u00e1s informaci\u00f3n o est\u00e1n interesados lean la siguiente documentaci\u00f3n de logisim link . Su tarea es implementar las compuertas NAND, NOR, XOR y multiplexores 2 a 1 y 4 a 1 utilizando \u00fanicamente compuertas AND, NOT y OR . Todos los circuitos tienen ya colocados los pines de entrada y salida, nuevamente no los pueden cambiar o no funcionar\u00e1 el autograder. Cuando hayan completado un subcircuito pueden re-utilizarlo en los dem\u00e1s subcircuitos si creen que es necesario o simplifica el circuito. Para esto tienen que estar en otro subcircuito y hacer click en el subcircuito que ya han terminado y lo pueden utilizar como cualquier otro componente. Por ejemplo en la imagen que se muestra a continuaci\u00f3n se utiliza en el subcircuito NOR, el subcircuito NAND. Nota : Para los circuitos que simulan los respectivos multiplexores. Se deben seguir las siguientes normas: Para el Multiplexor 2 a 1 de 1 bit: Para el Multiplexor 4 a 1 de 1 bit: Recordar no usar las compuertas l\u00f3gicas NOR, XOR ni los multiplexores que vienen por defecto.","title":"Ejercicio 1: NAND, NOR, XOR y Multiplexores"},{"location":"labs/lab06/#ejercicio-2-contador","text":"Ya sabiendo sobre circuitos y subcircuitos, ahora se har\u00e1 un circuito m\u00e1s complejo aplicando todo lo aprendido en el lab hasta el momento. Sino, cuando llegue el momento de realizar un proyecto al respecto, este no tendr\u00e1 piedad de ustedes. Para este ejercicio van a estar trabajando en el archivo ex2.circ . El ejercicio consiste en realizar un contador utilizando un registro y un sumador. Lo especial de este circuito es que se empezar\u00e1 a utilizar un reloj y a utilizar m\u00e1s bits. El circuito a dise\u00f1ar es el siguiente: Los componentes a emplear se encuentran en: Los componentes utilizados son los siguientes: Sumador: Ubicado en la librer\u00eda \u201cAritm\u00e9tica\u201d. Registro: Ubicado en la librer\u00eda \u201cMemoria\u201d. Constante Num\u00e9rica: Ubicado en la librer\u00eda \u201cWiring\u201d. Reloj: Ubicado en la librer\u00eda \u201cWiring\u201d. Cabe mencionar que ahora se utilizan Output Pins de m\u00e1s de un bit, se puede aumentar el n\u00famero de bits en la configuraci\u00f3n de los componentes. Seleccionar un componente y, en el lado izquierdo, se puede encontrar el mismo men\u00fa que se usa para darle orientaci\u00f3n a los componentes y asignarles una etiqueta, en donde se est\u00e1 la opci\u00f3n de \u201cBits De Datos\u201d. Para este ejercicio ya est\u00e1 hecho esto para los Output pins , pero si tienen que hacerlo para el registro, para la constante num\u00e9rica y el sumador. Una vez se termine de construir el circuito\u2026 \u00a1es hora de simularlo! Seleccionar la opci\u00f3n \u201cSimular\u201d (ubicado en la parte superior de la pantalla) y presionar la opci\u00f3n de \u201cactivar reloj\u201d. Se podr\u00e1 notar que el circuito funciona por s\u00ed solo y que, efectivamente, cumple con su objetivo: \u00a1contar! (si se hizo correctamente). Es posible alterar la frecuencia del reloj seleccionando otra vez \u201cSimular\u201d y, luego, \u201cSeleccionar frecuencia del reloj\u201d. Con esto se puede controlar qu\u00e9 tan r\u00e1pido se contar\u00e1. Otra funci\u00f3n \u00fatil es la de \u201cResetear Simulaci\u00f3n\u201d ubicado, tambi\u00e9n, en \u201cSimular\u201d. NOTA : En lo que se simula el circuito, es posible revisar los estados de los subcircuitos. Para ello, se debe seleccionar la herramienta \u201cPoke\u201d, hacer click sobre un subcircuito en el \u00e1rea de trabajo y presionar en la lupa que aparece sobre el subcircuito. Para regresar al circuito principal, hay que hacer click en el m\u00f3dulo del circuito principal, ubicado en la secci\u00f3n de componentes. Esto no lo van a necesitar en este ejercicio, pero ser\u00e1 muy \u00fatil para el proyecto nuevamente.","title":"Ejercicio 2: Contador"},{"location":"labs/lab06/#ejercicio-3-afd-a-logica-digital","text":"Es momento de hacer algo mucho m\u00e1s interesante: \u00a1traducir un Aut\u00f3mata Finito Determin\u00edstico a un circuito digital! En el curso de Inform\u00e1tica 3 se aprende qu\u00e9 es un AFD (o F inite S tate M achine en ingl\u00e9s). Un AFD posee estados finitos y transici\u00f3n entre estados. El AFD de este laboratorio es una variaci\u00f3n del AFD que se ha visto en clase. Este AFD posee estados y transici\u00f3n de estados, pero, adem\u00e1s de eso, necesita inputs para cambiar de estado y al cambiar de estado regresa un output. El AFD es el siguiente: La tabla de verdad de dicho aut\u00f3mata puede ser \u00fatil para visualizar lo que est\u00e1 pasando: \u00bfC\u00f3mo se lee? La primera fila de la tabla se entiende de esta manera: \u201cDado el estado 00, si el input es 0, entonces se hace una transici\u00f3n al estado 01 y devuelve un output de 1\u201d. Para este ejercicio se les provee el circuito ex3.circ . El trabajo a realizar es completar el circuito y lograr que se comporte como el AFD mostrado anteriormente. Para esto ustedes solo van a modificar 2 subcircuitos: StateBitOne y StateBitZero . Se tienen dos opciones para completar el circuito: 1) fuerza bruta o 2) imaginaci\u00f3n. Con la imaginaci\u00f3n es posible completar el circuito utilizando un total de 3 componentes, pero, si se resuelve con la fuerza bruta, el n\u00famero ser\u00e1 mucho mayor. Se tiene todas las herramientas y las pistas necesarias para terminar el ejercicio con 3 componentes. \u00a1\u00c9xitos! :D","title":"Ejercicio 3: AFD a L\u00f3gica Digital"},{"location":"labs/lab06/#calificacion","text":"Cuando crean que tiene ejercicios completos pueden hacer la prueba localmente escribiendo en la terminal: ./check Si todo esta correcto les saldr\u00e1 algo como esto: ___ __ __ / _ | __ __/ /____ ___ _______ ____/ /__ ____ / __ / // / __/ _ \\/ _ \\/ __/ _ \\/ _ / -_ ) __/ /_/ | _ \\_ ,_/ \\_ _/ \\_ __/ \\_ , /_/ \\_ ,_/ \\_ ,_/ \\_ _/_/ /___/ Machine Structures Great Ideas in Computer Architecture Logisim Intro Exercise Grade Message ------------------------ ------- --------- 0 . The basics ( Warm-Up ) 25 passed 1 . Sub-Circuits 25 passed 2 . Storing State 25 passed 3 . FSMs to Digital Logic 25 passed = > Score: 100 /100 Cuando hayan terminado su laboratorio, o crean que est\u00e1n listos para obtener su nota, pueden subir su laboratorio al autograder utilizando: ./submit <TOKEN> NOTA : Tienen que reemplazar <TOKEN> por el token que les da la siguiente p\u00e1gina Luego, cuando haya sido calificado, pueden ver su resultado en https://dashboard.cc-3.site/ .","title":"Calificaci\u00f3n"},{"location":"labs/lab07/","text":"Lab 6 - Logisim Avanzado \u00b6 Objetivo \u00b6 En este laboratorio ustedes van a aprender sobre otros componentes esenciales de Logisim, en particular, los splitters que nos permiten hacer cosas como, descomponer un cable en subsets de bits para luego manipularlos individualmente. Preparaci\u00f3n \u00b6 Para este laboratorio, nuevamente, es necesario que tengan la aplicaci\u00f3n de Logisim . Adicionalmente pueden utilizar la documentaci\u00f3n de Logisim para refrescar el conocimiento que adquirieron en el laboratorio pasado o leer el lab tambi\u00e9n aqu\u00ed . Tambi\u00e9n tienen que tener todos los archivos base, estos se encuentran aqu\u00ed . Recuerden que deben aceptar la asignaci\u00f3n de GitHub Classroom y se les crear\u00e1 autom\u00e1ticamente un repositorio con una extensi\u00f3n que termina con su usuario de GitHub. Cuando ya se haya creado el repositorio, pueden ejecutar los siguientes comandos abriendo una terminal ( CTRL + T ): git clone <link del repositorio> Caracter\u00edsticas Avanzadas de Logisim \u00b6 Aqu\u00ed pueden encontrar tres caracter\u00edsticas m\u00e1s de logisim que ustedes van a encontrar bastante utiles, principalmente en el proyecto 2. T\u00faneles (Tunnels) \u00b6 Un t\u00fanel les permite dibujar un cable invisible para unir dos puntos. Los t\u00faneles son agrupados por etiquetas (case-sensitive) que se les ponen a los cables para identificarlos. Generalmente son utilizados para conectar cables de la siguiente manera: Que se traduce (o tiene un efecto similar) a esto: Hay que tener ciertas precauciones al utilizar los t\u00faneles y siempre mantener un registro de cuales cables est\u00e1n conectados con t\u00faneles hacia otros cables, para evitar situaciones como esta: Que se traduce (o tiene un efecto similar) a esto: Nosotros les recomendamos ( bastante ) utilizar t\u00faneles en Logisim, porque hacen los circuitos m\u00e1s limpios, claros y f\u00e1ciles de depurar. Divisores (Splitters) \u00b6 Los divisores crean una correspondencia entre un valor de multiples bits y subsets de esos bits. A pesar de su nombre, puede dividir un valor de multiples bits en varias partes o subsets de bits (lo que se espera por el nombre), as\u00ed como tambi\u00e9n puede combinar partes o subsets de bits en un valor de multiples bits. Por ejemplo para el primer caso, un valor float (IEEE 754) de precisi\u00f3n simple (32 bits) dividido en signo (1 bit), exponente (8 bits) y fracci\u00f3n (23 bits): Para el segundo caso se unen dos entradas de diferentes anchos de bits (3 y 2 bits) que se unen para formar un valor de 5 bits: Extensores (Extenders) \u00b6 Cuando est\u00e9n cambiando el ancho de un cable, siempre deber\u00edan de utilizar un extensor para mayor claridad en su circuito. Por ejemplo, consideren la siguiente implementaci\u00f3n en donde se extiende un cable de ancho 8 bits a un cable de ancho de 16 bits: A pesar de que hace lo que tiene que hacer, no es una buena pr\u00e1ctica y alguien que est\u00e9 revisando su proyecto posiblemente no pueda comprender la intenci\u00f3n del circuito anterior. Algo mejor, m\u00e1s simple, f\u00e1cil de leer y menos propenso a errores ser\u00eda algo como lo siguiente: Esto tamb\u00eden aplica cuando se quiere pasar de un ancho de bits mayor a un ancho de bits menor. En el siguiente ejemplo, un cable de ancho 8 bits es convertido a un cable de ancho de 4 bits, tirando/ignorando los bits sobrantes: A pesar de las implicaciones de su nombre, un extensor se puede utilizar tambi\u00e9n para realizar la misma operaci\u00f3n y as\u00ed evitar el uso de splitters para esta tarea: Ejercicio 1: Divisores (Splitters) \u00b6 Para este ejercicio van a utilizar los splitters para crear un par de circuitos simples manipulando un numero de 8 bits. Van a estar trabajando en el archivo splitters.circ . Vayan al folder llamado \"Wiring\" y seleccionen un splitter. Este circuito va a tomar un cable y lo va a dividir en un set de cables con un ancho de bits menor. Antes de colocar el circuito en el esquem\u00e1tico, cambien el ancho a 8 bits en las propiedades del circuito y \"Fan Out\" al tamano que considere conveniente, 3 es una buena idea para comenzar. Si ustedes mueven el cursor sobre el esquem\u00e1tico, su cursor deber\u00eda de verse algo as\u00ed: . Tareas a realizar: Out1: Realice un AND entre el bit m\u00e1s significativo y el menos significativo del input Arriba le sugerimos que pusiera un fan out de 3. En el panel de la izquierda configure para que solo el bit 0 vaya a la salida 0 (Top), y que solo el bit 7 vaya a la salida 2 (Bottom), todos los dem\u00e1s bits puede mandarlos hacia la salida 1. Listo! Gracias al splitter, logr\u00f3 separar el bit m\u00e1s significativo y el menos significativo del resto. Out2: Trabajando en signo-magnitud, obtenga el inverso aditivo del input Recordatorio: inverso aditivo significa cambiarle de signo de positivo a negativo, y viceversa. Recordatorio: Signo Magnitud es una otra forma de representar n\u00fameros con signo, la vimos la primera semana de clases. Usted ya parti\u00f3 al input en pedacitos para resolver Out1, puede usar algunos de esos pedacitos y alguna compuerta para obtener el inverso aditivo. Luego puede utilizar otro splitter, ahora colocado al rev\u00e9s para reconstruir su n\u00famero: de varios pedacitos, pasar\u00e1 a tener un valor de 8 bits. Ejercicio 2: Rotate Right \u00b6 Con el conocimiento que tienen acerca de los splitters y multiplexores, est\u00e1n listos para implementar un bloque de l\u00f3gica combinacional no trivial: rotr , que significa Rotate Right . La idea es que rotr A,B va a rotar el patr\u00f3n de bits de la entrada A a la derecha por B bits. Por ejemplo, si A fuera $0\\text{b}10110101011\\color{blue}1\\color{blue}0\\color{blue}0\\color{blue}1\\color{blue}1$ y B fuera $0\\text{b}0101$ (5 en decimal), el output del bloque ser\u00eda $0\\text{b}\\color{red}1\\color{red}0\\color{red}0\\color{red}1\\color{red}110110101011$. Noten que los 5 bits de m\u00e1s a la derecha de A (azul) fueron rotados a la derecha y puestos de vuelta a la izquierda (rojo). En RTL, la operaci\u00f3n ser\u00eda algo como: R = A >> B | A << ( 16 - B ) Ustedes tienen que implementar el subcircuito llamado rotr en el archivo rotr.circ que tiene las siguientes entradas y salida: A , 16 bits, la entrada a ser rotada. B , 4 bits, la cantidad de rotaci\u00f3n (Resp\u00f3ndase a usted mismo, \u00bfpor qu\u00e9 4 bits? ) C , 16 bits, salida con el resultado de la rotaci\u00f3n. La salida en el output deber\u00eda de ser A rotado por B bits, como se indic\u00f3 anteriormente. Ustedes NO pueden utilizar los shifters que trae Logisim en su soluci\u00f3n, pero todos los dem\u00e1s bloques combinacionales (multiplexores, splitters, t\u00faneles, constantes, compuertas, sumadores, etc) son permitidos. HINT 1 : Antes de empezar a cablear, deber\u00edan de pensar muuuuuuuy bien acerca de como pueden descomponer este problema en peque\u00f1as partes y unirlas. Deber\u00edan de sentirse libres de implementar subcircuitos para implementar este ejercicio. Si no los utilizan, se van a arrepentir. HINT 2 : Solo porque les dimos una representaci\u00f3n en RTL no significa que esta sea la mejor opci\u00f3n para abordar el problema. Piense en los bits de entrada de B y en como pueden utilizar efectivamente los splitters. Piense en c\u00f3mo resolvio el multiplexor de 4 a 1 la semana pasada, usando su multiplexor de 2 a 1. Si su cableado de un splitter grande se est\u00e1 volviendo desordenado, a veces cambiar los splitters pueden mantener las cosas m\u00e1s limpias y localizables. Por ejemplo, en lugar de utilizar un splitter de 1 a 16, puede primero dividir en 4, y luego volver a dividir en 4. \u00a1Este ejercicio lo har\u00e1 pensar bastante! Ejercicio 3: ALU \u00b6 En este ejercicio ustedes van a implementar un ALU de 32 bits. Van estar trabajando en el archivo llamado ALU.circ . Como un recordatorio, ALU significa Arithmetic Logic Unit (Unidad Arim\u00e9tica L\u00f3gica). Un ALU es una pieza fundamental de un CPU y realiza operaciones aritm\u00e9ticas y l\u00f3gicas (bitwise). La funci\u00f3n que el ALU realiza (ejemplo add, xor) es determinada por el control de nuestro datapath, que esta determinado por la instrucci\u00f3n que nuestro procesador est\u00e1 ejecutando. El ALU est\u00e1 resaltado en el siguiente diagrama de un datapath simplificado: Este ejercicio es una versi\u00f3n simplificada de lo que le tocar\u00e1 hacer en el proyecto 2. Esperamos que al realizar este ejercicio, el proyecto 2 se les haga un poco m\u00e1s f\u00e1cil y suave de llevar. Las 8 funciones que tienen que implementar son: shift left logical , shift right logical , shift right arithmetic , rotate left , rotate right , and , or y xor . El ALU va a realizar la funci\u00f3n deseada sobre 2 entradas de 32 bits y tendr\u00e1 una salida de 32 bits como resultado. Noten que Logisim tiene compuertas que hacen todas estas funciones, NO tienen que implementar ninguna por su cuenta, por favor no lo hagan . HINT 1 : Busquen el folder en Logisim etiquetado como Arithmetic para poder encontrar shifter, que ser\u00e1 \u00fatil para varias de las operaciones. HINT 2 : Utilizen t\u00faneles para mover todas las salidas del cuadro etiquetado \"Compute All Possible Operations\" al cuadro etiquetado como \"Select the Requested Result\". La funci\u00f3n seleccionada va a ser determinada por el valor de la se\u00f1al de control, la siguiente tabla resume todo: Control Operation 000 Shift Left Logical 001 Shift Right Logical 010 Shift Right Arithmetic 011 Rotate Left 100 Rotate Right 101 And 110 Or 111 Xor Calificaci\u00f3n \u00b6 Cuando crean que tengan ejercicios completos, pueden utilizar el autograder escribiendo en la terminal: ./check Si todo esta correcto les saldr\u00e1 algo como esto: ___ __ __ / _ | __ __/ /____ ___ _______ ____/ /__ ____ / __ / // / __/ _ \\/ _ \\/ __/ _ \\/ _ / -_ ) __/ /_/ | _ \\_ ,_/ \\_ _/ \\_ __/ \\_ , /_/ \\_ ,_/ \\_ ,_/ \\_ _/_/ /___/ Machine Structures Great Ideas in Computer Architecture Advanced Logisim Exercise Grade Message ---------------- ------- --------- 1 . Splitters 33 .333 passed 2 . Rotate Right 33 .333 passed 3 . ALU 33 .333 passed = > Score: 100 /100 Al finalizar, recuerde hacer add , commit y push hacia Github. Luego env\u00ede el link de su repositorio en el GES. Si no env\u00eda el link, no podremos ponerle nota!","title":"7: Logisim Avanzado"},{"location":"labs/lab07/#lab-6-logisim-avanzado","text":"","title":"Lab 6 - Logisim Avanzado"},{"location":"labs/lab07/#objetivo","text":"En este laboratorio ustedes van a aprender sobre otros componentes esenciales de Logisim, en particular, los splitters que nos permiten hacer cosas como, descomponer un cable en subsets de bits para luego manipularlos individualmente.","title":"Objetivo"},{"location":"labs/lab07/#preparacion","text":"Para este laboratorio, nuevamente, es necesario que tengan la aplicaci\u00f3n de Logisim . Adicionalmente pueden utilizar la documentaci\u00f3n de Logisim para refrescar el conocimiento que adquirieron en el laboratorio pasado o leer el lab tambi\u00e9n aqu\u00ed . Tambi\u00e9n tienen que tener todos los archivos base, estos se encuentran aqu\u00ed . Recuerden que deben aceptar la asignaci\u00f3n de GitHub Classroom y se les crear\u00e1 autom\u00e1ticamente un repositorio con una extensi\u00f3n que termina con su usuario de GitHub. Cuando ya se haya creado el repositorio, pueden ejecutar los siguientes comandos abriendo una terminal ( CTRL + T ): git clone <link del repositorio>","title":"Preparaci\u00f3n"},{"location":"labs/lab07/#caracteristicas-avanzadas-de-logisim","text":"Aqu\u00ed pueden encontrar tres caracter\u00edsticas m\u00e1s de logisim que ustedes van a encontrar bastante utiles, principalmente en el proyecto 2.","title":"Caracter\u00edsticas Avanzadas de Logisim"},{"location":"labs/lab07/#tuneles-tunnels","text":"Un t\u00fanel les permite dibujar un cable invisible para unir dos puntos. Los t\u00faneles son agrupados por etiquetas (case-sensitive) que se les ponen a los cables para identificarlos. Generalmente son utilizados para conectar cables de la siguiente manera: Que se traduce (o tiene un efecto similar) a esto: Hay que tener ciertas precauciones al utilizar los t\u00faneles y siempre mantener un registro de cuales cables est\u00e1n conectados con t\u00faneles hacia otros cables, para evitar situaciones como esta: Que se traduce (o tiene un efecto similar) a esto: Nosotros les recomendamos ( bastante ) utilizar t\u00faneles en Logisim, porque hacen los circuitos m\u00e1s limpios, claros y f\u00e1ciles de depurar.","title":"T\u00faneles (Tunnels)"},{"location":"labs/lab07/#divisores-splitters","text":"Los divisores crean una correspondencia entre un valor de multiples bits y subsets de esos bits. A pesar de su nombre, puede dividir un valor de multiples bits en varias partes o subsets de bits (lo que se espera por el nombre), as\u00ed como tambi\u00e9n puede combinar partes o subsets de bits en un valor de multiples bits. Por ejemplo para el primer caso, un valor float (IEEE 754) de precisi\u00f3n simple (32 bits) dividido en signo (1 bit), exponente (8 bits) y fracci\u00f3n (23 bits): Para el segundo caso se unen dos entradas de diferentes anchos de bits (3 y 2 bits) que se unen para formar un valor de 5 bits:","title":"Divisores (Splitters)"},{"location":"labs/lab07/#extensores-extenders","text":"Cuando est\u00e9n cambiando el ancho de un cable, siempre deber\u00edan de utilizar un extensor para mayor claridad en su circuito. Por ejemplo, consideren la siguiente implementaci\u00f3n en donde se extiende un cable de ancho 8 bits a un cable de ancho de 16 bits: A pesar de que hace lo que tiene que hacer, no es una buena pr\u00e1ctica y alguien que est\u00e9 revisando su proyecto posiblemente no pueda comprender la intenci\u00f3n del circuito anterior. Algo mejor, m\u00e1s simple, f\u00e1cil de leer y menos propenso a errores ser\u00eda algo como lo siguiente: Esto tamb\u00eden aplica cuando se quiere pasar de un ancho de bits mayor a un ancho de bits menor. En el siguiente ejemplo, un cable de ancho 8 bits es convertido a un cable de ancho de 4 bits, tirando/ignorando los bits sobrantes: A pesar de las implicaciones de su nombre, un extensor se puede utilizar tambi\u00e9n para realizar la misma operaci\u00f3n y as\u00ed evitar el uso de splitters para esta tarea:","title":"Extensores (Extenders)"},{"location":"labs/lab07/#ejercicio-1-divisores-splitters","text":"Para este ejercicio van a utilizar los splitters para crear un par de circuitos simples manipulando un numero de 8 bits. Van a estar trabajando en el archivo splitters.circ . Vayan al folder llamado \"Wiring\" y seleccionen un splitter. Este circuito va a tomar un cable y lo va a dividir en un set de cables con un ancho de bits menor. Antes de colocar el circuito en el esquem\u00e1tico, cambien el ancho a 8 bits en las propiedades del circuito y \"Fan Out\" al tamano que considere conveniente, 3 es una buena idea para comenzar. Si ustedes mueven el cursor sobre el esquem\u00e1tico, su cursor deber\u00eda de verse algo as\u00ed: . Tareas a realizar: Out1: Realice un AND entre el bit m\u00e1s significativo y el menos significativo del input Arriba le sugerimos que pusiera un fan out de 3. En el panel de la izquierda configure para que solo el bit 0 vaya a la salida 0 (Top), y que solo el bit 7 vaya a la salida 2 (Bottom), todos los dem\u00e1s bits puede mandarlos hacia la salida 1. Listo! Gracias al splitter, logr\u00f3 separar el bit m\u00e1s significativo y el menos significativo del resto. Out2: Trabajando en signo-magnitud, obtenga el inverso aditivo del input Recordatorio: inverso aditivo significa cambiarle de signo de positivo a negativo, y viceversa. Recordatorio: Signo Magnitud es una otra forma de representar n\u00fameros con signo, la vimos la primera semana de clases. Usted ya parti\u00f3 al input en pedacitos para resolver Out1, puede usar algunos de esos pedacitos y alguna compuerta para obtener el inverso aditivo. Luego puede utilizar otro splitter, ahora colocado al rev\u00e9s para reconstruir su n\u00famero: de varios pedacitos, pasar\u00e1 a tener un valor de 8 bits.","title":"Ejercicio 1: Divisores (Splitters)"},{"location":"labs/lab07/#ejercicio-2-rotate-right","text":"Con el conocimiento que tienen acerca de los splitters y multiplexores, est\u00e1n listos para implementar un bloque de l\u00f3gica combinacional no trivial: rotr , que significa Rotate Right . La idea es que rotr A,B va a rotar el patr\u00f3n de bits de la entrada A a la derecha por B bits. Por ejemplo, si A fuera $0\\text{b}10110101011\\color{blue}1\\color{blue}0\\color{blue}0\\color{blue}1\\color{blue}1$ y B fuera $0\\text{b}0101$ (5 en decimal), el output del bloque ser\u00eda $0\\text{b}\\color{red}1\\color{red}0\\color{red}0\\color{red}1\\color{red}110110101011$. Noten que los 5 bits de m\u00e1s a la derecha de A (azul) fueron rotados a la derecha y puestos de vuelta a la izquierda (rojo). En RTL, la operaci\u00f3n ser\u00eda algo como: R = A >> B | A << ( 16 - B ) Ustedes tienen que implementar el subcircuito llamado rotr en el archivo rotr.circ que tiene las siguientes entradas y salida: A , 16 bits, la entrada a ser rotada. B , 4 bits, la cantidad de rotaci\u00f3n (Resp\u00f3ndase a usted mismo, \u00bfpor qu\u00e9 4 bits? ) C , 16 bits, salida con el resultado de la rotaci\u00f3n. La salida en el output deber\u00eda de ser A rotado por B bits, como se indic\u00f3 anteriormente. Ustedes NO pueden utilizar los shifters que trae Logisim en su soluci\u00f3n, pero todos los dem\u00e1s bloques combinacionales (multiplexores, splitters, t\u00faneles, constantes, compuertas, sumadores, etc) son permitidos. HINT 1 : Antes de empezar a cablear, deber\u00edan de pensar muuuuuuuy bien acerca de como pueden descomponer este problema en peque\u00f1as partes y unirlas. Deber\u00edan de sentirse libres de implementar subcircuitos para implementar este ejercicio. Si no los utilizan, se van a arrepentir. HINT 2 : Solo porque les dimos una representaci\u00f3n en RTL no significa que esta sea la mejor opci\u00f3n para abordar el problema. Piense en los bits de entrada de B y en como pueden utilizar efectivamente los splitters. Piense en c\u00f3mo resolvio el multiplexor de 4 a 1 la semana pasada, usando su multiplexor de 2 a 1. Si su cableado de un splitter grande se est\u00e1 volviendo desordenado, a veces cambiar los splitters pueden mantener las cosas m\u00e1s limpias y localizables. Por ejemplo, en lugar de utilizar un splitter de 1 a 16, puede primero dividir en 4, y luego volver a dividir en 4. \u00a1Este ejercicio lo har\u00e1 pensar bastante!","title":"Ejercicio 2: Rotate Right"},{"location":"labs/lab07/#ejercicio-3-alu","text":"En este ejercicio ustedes van a implementar un ALU de 32 bits. Van estar trabajando en el archivo llamado ALU.circ . Como un recordatorio, ALU significa Arithmetic Logic Unit (Unidad Arim\u00e9tica L\u00f3gica). Un ALU es una pieza fundamental de un CPU y realiza operaciones aritm\u00e9ticas y l\u00f3gicas (bitwise). La funci\u00f3n que el ALU realiza (ejemplo add, xor) es determinada por el control de nuestro datapath, que esta determinado por la instrucci\u00f3n que nuestro procesador est\u00e1 ejecutando. El ALU est\u00e1 resaltado en el siguiente diagrama de un datapath simplificado: Este ejercicio es una versi\u00f3n simplificada de lo que le tocar\u00e1 hacer en el proyecto 2. Esperamos que al realizar este ejercicio, el proyecto 2 se les haga un poco m\u00e1s f\u00e1cil y suave de llevar. Las 8 funciones que tienen que implementar son: shift left logical , shift right logical , shift right arithmetic , rotate left , rotate right , and , or y xor . El ALU va a realizar la funci\u00f3n deseada sobre 2 entradas de 32 bits y tendr\u00e1 una salida de 32 bits como resultado. Noten que Logisim tiene compuertas que hacen todas estas funciones, NO tienen que implementar ninguna por su cuenta, por favor no lo hagan . HINT 1 : Busquen el folder en Logisim etiquetado como Arithmetic para poder encontrar shifter, que ser\u00e1 \u00fatil para varias de las operaciones. HINT 2 : Utilizen t\u00faneles para mover todas las salidas del cuadro etiquetado \"Compute All Possible Operations\" al cuadro etiquetado como \"Select the Requested Result\". La funci\u00f3n seleccionada va a ser determinada por el valor de la se\u00f1al de control, la siguiente tabla resume todo: Control Operation 000 Shift Left Logical 001 Shift Right Logical 010 Shift Right Arithmetic 011 Rotate Left 100 Rotate Right 101 And 110 Or 111 Xor","title":"Ejercicio 3: ALU"},{"location":"labs/lab07/#calificacion","text":"Cuando crean que tengan ejercicios completos, pueden utilizar el autograder escribiendo en la terminal: ./check Si todo esta correcto les saldr\u00e1 algo como esto: ___ __ __ / _ | __ __/ /____ ___ _______ ____/ /__ ____ / __ / // / __/ _ \\/ _ \\/ __/ _ \\/ _ / -_ ) __/ /_/ | _ \\_ ,_/ \\_ _/ \\_ __/ \\_ , /_/ \\_ ,_/ \\_ ,_/ \\_ _/_/ /___/ Machine Structures Great Ideas in Computer Architecture Advanced Logisim Exercise Grade Message ---------------- ------- --------- 1 . Splitters 33 .333 passed 2 . Rotate Right 33 .333 passed 3 . ALU 33 .333 passed = > Score: 100 /100 Al finalizar, recuerde hacer add , commit y push hacia Github. Luego env\u00ede el link de su repositorio en el GES. Si no env\u00eda el link, no podremos ponerle nota!","title":"Calificaci\u00f3n"},{"location":"labs/lab08/","text":"Lab 7 - ALU Proyecto 2 \u00b6 Objetivo \u00b6 Este laboratorio es bastante corto y representa los primeros 25 puntos de su proyecto 2 (procesador de RISC-V en Logisim). El motivo principal es que tengan m\u00e1s tiempo para invertir en otras partes del proyecto. Si logran sacar 100 en el laboratorio tendr\u00e1n una de tres partes terminadas... \u00e9xitos. Preparaci\u00f3n \u00b6 Para este laboratorio, nuevamente, es necesario que tengan la aplicaci\u00f3n de Logisim . Adicionalmente pueden utilizar la documentaci\u00f3n de Logisim para refrescar el conocimiento que adquirieron en los laboratorios anteriores. Tambi\u00e9n tienen que tener todos los archivos base, estos se encuentran aqu\u00ed . Cuando ya se haya creado el repositorio, pueden ejecutar los siguientes comandos abriendo una terminal ( CTRL + T ): git clone <link del repositorio> Ejercicio 1: Arithmetic Logic Unit (ALU) \u00b6 Las instrucciones de este ejercicio son una copia literal de las instrucciones del proyecto 2, por favor lean cuidadosamente . Su tarea es crear un ALU que soporte todas las operaciones que necesitan las instrucciones de nuestro ISA. Van a estar trabajando en el archivo alu.circ . Este tiene tres entradas: Nombre de Entrada Ancho en Bits Descripci\u00f3n A 32 Datos para usar por A en la operaci\u00f3n del ALU B 32 Datos para usar por B en la operaci\u00f3n del ALU ALU Op 4 Selecciona la operaci\u00f3n que el ALU deber\u00eda de efectuar y cuatro salidas: Nombre de Entrada Ancho en Bits Descripci\u00f3n Out 32 Resultado de la operaci\u00f3n efectuada por el ALU Equal 1 1 si A y B son iguales, 0 de lo contrario LT 1 1 si A es menor que B (signed), 0 de lo contrario LTU 1 1 si A es menor que B (unsigned), 0 de lo contrario Esta es la lista de operaciones que necesitan implementar. Ustedes tienen que utilizar y les recomendamos utilizar los componentes de logisim que ya efectuan estas operaciones, por favor no las implementen desde 0, ser\u00eda muy tardado y no es el objetivo del proyecto ni del laboratorio. Valor de ALU Op Instrucci\u00f3n 0 sll: Out = A << B[4:0] 1 srl: Out = (unsigned) A >> B[4:0] 2 add: Out = A + B 3 and: Out = A & B 4 or: Out = A | B 5 xor: Out = A ^ B 6 slt: Out = (A < B) ? 1 : 0 Signed 7 mul: Out = (X * Y)[31:0] 8 mulh: Out = (A * B)[63:32] 9 div: Out =(unsigned) A / B 10 rem: Out = A % B 11 sub: Out = A - B Algunas cosas adicionales que tienen que tener en mente: La salidas Equal , LT , LTU siempre tienen que sacar el valor correcto de comparaci\u00f3n sin importar el valor de ALU Op . Ustedes no pueden modificar (mover, reemplazar, cortar, pegar, eliminar, etc) los pines de entrada ni de salida que nosotros les damos de lo contrario el autograder no va a funcionar correctamente, tengan en cuenta esto para evitar problemas con el autograder a la hora de hacer submit. Calificaci\u00f3n \u00b6 Al finalizar su circuito puede usar ./check para probarlo de forma local. Debido a lo importante que sera el ALU para su proyecto, este lab se calificara con 0 o 100 unicamente. Cuando haya superado el test local puede hacer autograder --upload para subir su laboratorio y luego autograder --stats para comprobar su 100 de nota. No olvide hacer add + commit + push a su repositorio y subir el link de este al GES.","title":"8: Logisim PJ2 ALU"},{"location":"labs/lab08/#lab-7-alu-proyecto-2","text":"","title":"Lab 7 - ALU Proyecto 2"},{"location":"labs/lab08/#objetivo","text":"Este laboratorio es bastante corto y representa los primeros 25 puntos de su proyecto 2 (procesador de RISC-V en Logisim). El motivo principal es que tengan m\u00e1s tiempo para invertir en otras partes del proyecto. Si logran sacar 100 en el laboratorio tendr\u00e1n una de tres partes terminadas... \u00e9xitos.","title":"Objetivo"},{"location":"labs/lab08/#preparacion","text":"Para este laboratorio, nuevamente, es necesario que tengan la aplicaci\u00f3n de Logisim . Adicionalmente pueden utilizar la documentaci\u00f3n de Logisim para refrescar el conocimiento que adquirieron en los laboratorios anteriores. Tambi\u00e9n tienen que tener todos los archivos base, estos se encuentran aqu\u00ed . Cuando ya se haya creado el repositorio, pueden ejecutar los siguientes comandos abriendo una terminal ( CTRL + T ): git clone <link del repositorio>","title":"Preparaci\u00f3n"},{"location":"labs/lab08/#ejercicio-1-arithmetic-logic-unit-alu","text":"Las instrucciones de este ejercicio son una copia literal de las instrucciones del proyecto 2, por favor lean cuidadosamente . Su tarea es crear un ALU que soporte todas las operaciones que necesitan las instrucciones de nuestro ISA. Van a estar trabajando en el archivo alu.circ . Este tiene tres entradas: Nombre de Entrada Ancho en Bits Descripci\u00f3n A 32 Datos para usar por A en la operaci\u00f3n del ALU B 32 Datos para usar por B en la operaci\u00f3n del ALU ALU Op 4 Selecciona la operaci\u00f3n que el ALU deber\u00eda de efectuar y cuatro salidas: Nombre de Entrada Ancho en Bits Descripci\u00f3n Out 32 Resultado de la operaci\u00f3n efectuada por el ALU Equal 1 1 si A y B son iguales, 0 de lo contrario LT 1 1 si A es menor que B (signed), 0 de lo contrario LTU 1 1 si A es menor que B (unsigned), 0 de lo contrario Esta es la lista de operaciones que necesitan implementar. Ustedes tienen que utilizar y les recomendamos utilizar los componentes de logisim que ya efectuan estas operaciones, por favor no las implementen desde 0, ser\u00eda muy tardado y no es el objetivo del proyecto ni del laboratorio. Valor de ALU Op Instrucci\u00f3n 0 sll: Out = A << B[4:0] 1 srl: Out = (unsigned) A >> B[4:0] 2 add: Out = A + B 3 and: Out = A & B 4 or: Out = A | B 5 xor: Out = A ^ B 6 slt: Out = (A < B) ? 1 : 0 Signed 7 mul: Out = (X * Y)[31:0] 8 mulh: Out = (A * B)[63:32] 9 div: Out =(unsigned) A / B 10 rem: Out = A % B 11 sub: Out = A - B Algunas cosas adicionales que tienen que tener en mente: La salidas Equal , LT , LTU siempre tienen que sacar el valor correcto de comparaci\u00f3n sin importar el valor de ALU Op . Ustedes no pueden modificar (mover, reemplazar, cortar, pegar, eliminar, etc) los pines de entrada ni de salida que nosotros les damos de lo contrario el autograder no va a funcionar correctamente, tengan en cuenta esto para evitar problemas con el autograder a la hora de hacer submit.","title":"Ejercicio 1: Arithmetic Logic Unit (ALU)"},{"location":"labs/lab08/#calificacion","text":"Al finalizar su circuito puede usar ./check para probarlo de forma local. Debido a lo importante que sera el ALU para su proyecto, este lab se calificara con 0 o 100 unicamente. Cuando haya superado el test local puede hacer autograder --upload para subir su laboratorio y luego autograder --stats para comprobar su 100 de nota. No olvide hacer add + commit + push a su repositorio y subir el link de este al GES.","title":"Calificaci\u00f3n"},{"location":"labs/lab09/","text":"Lab 10 - SIMD Intrinsics y Loop Unrolling \u00b6 Objetivos \u00b6 Aprender acerca de las instrucciones SIMD y hacer data level parallelism. Escribir c\u00f3digo con funciones SIMD para hacer ciertas optimizaciones. Aprender acerca de loop unrolling y por qu\u00e9 este funciona. Preparaci\u00f3n \u00b6 Tienen que tener todos los archivos base, estos se encuentran aqu\u00ed . Recuerden que tienen que aprovechar el uso de Git y subir el link de su repositorio al GES, as\u00ed como al autograder, de lo contrario su nota ser\u00e1 de 0 . Ejercicio 1: Familiariz\u00e1ndose con las funciones SIMD. \u00b6 Dado el gran n\u00famero disponible de instrucciones SIMD, queremos que ustedes aprendan c\u00f3mo encontrar aquellas que necesitar\u00e1n para determinadas aplicaciones. Intel proporciona una variedad de herramientas relacionadas a intrinsics, las cuales pueden encontrar aqu\u00ed (estas no son necesarias para este laboratorio). Nosotros estamos, particularmente, interesados en la Gu\u00eda Intel Intrinsics . Abran esta p\u00e1gina y, una vez est\u00e9n dentro, hagan click en todos los checkboxes que empiecen con SSE (desde SSE hasta SSE4.2). Hagan su mejor esfuerzo para interpretar esta nueva sintaxis y terminolog\u00eda. Encuentren la instrucci\u00f3n de 128 bits para las siguientes operaciones SIMD: Cuatro divisiones de punto flotante con precisi\u00f3n simple (float): a ) __m128 _mm_div_ss(__m128 a, __m128 b) b ) __m128 _mm_cvtsi64_ss(__m128 a, __int64 b) c ) float _mm_cvtss_f32(__m128 a) d ) __m128_mm_div_ps(__mm128 a, __mm128 b) e ) __m128 _mm_load_ps(float const* mem_addr) f ) __m128 _mm_loadu_ps(float const* mem_addr) Diecis\u00e9is operaciones de m\u00e1ximo sobre enteros de 8 bits con signo (char): a ) __m128i _mm_max_epi16 (__m128i a, __m128i b) b ) __m128i _mm_max_epi32 (__m128i a, __m128i b) c ) __m128i _mm_max_epi8 (__m128i a, __m128i b) d ) __m128i _mm_max_epu16 (__m128i a, __m128i b) e ) __m128i _mm_max_epu32 (__m128i a, __m128i b) f ) __m128i _mm_max_epu8 (__m128i a, __m128i b) g ) __m128d _mm_max_pd (__m128d a, __m128d b) h ) __m64 _mm_max_pi16 (__m64 a, __m64 b) i ) __m128 _mm_max_ps (__m128 a, __m128 b) j ) __m64 _mm_max_pu8 (__m64 a, __m64 b) k ) __m128d _mm_max_sd (__m128d a, __m128d b) l ) __m128 _mm_max_ss (__m128 a, __m128 b) Shift right aritm\u00e9tico sobre ocho enteros de 16 bits con signo (short): a ) __m128i _mm_add_epi16(__m128i a, __m128i b) b ) __m128i _mm_maskz_abs_epi8(__mmask16 k, __m128i a) c ) __m128i _mm_srai_epi16(__m128i a, __m128i count) d ) __m128i _mm_slli_epi64(__m128i a, int count) e ) __m128i _mm_srai_epi32(__m128i a, __m128i count) f ) __m128i _mm_sra_epi16(__m128i a, __m128i count) Escriban sus respuestas en el archivo ex1.txt . Ustedes tienen que colocar \u00fanicamente la letra de la opci\u00f3n que consideren correcta; ejemplo de un archivo correcto: 1: a 2: a 3: a Ejercicio 2: Escribiendo C\u00f3digo SIMD \u00b6 Para el ejercicio 2, ustedes deben vectorizar el siguiente c\u00f3digo para lograr obtener, aproximadamente, cuatro veces la velocidad en comparaci\u00f3n a la implementaci\u00f3n que se muestra a continuaci\u00f3n: static int sum_naive ( int n , int * a ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ]; } return sum ; } Pueden encontrar \u00fatiles las siguientes intrinsics : SIMD Descripci\u00f3n __m128i _mm_setzero_si128( ) devuelve un vector de 128 bits de ceros __m128i _mm_loadu_si128(__m128i *p) devuelve el vector de 128 bits guardado en el puntero p __m128i _mm_add_epi32(__m128i a, __m128i b) devuelve el vector ($a_0 + b_0$, $a_1 + b_1$, $a_2 + b_2$, $a3 + b3$) void _mm_storeu_si128(__m128i *p,__m128i a) guarda el vector de 128 bits representado por el puntero p El archivo que deben modificar es sum.c . Usen las intrinsics SSE para implementar la funci\u00f3n sum_vectorized() . Para compilar su c\u00f3digo, ejecuten el siguiente comando: make sum Para ejecutar su c\u00f3digo, corran el siguiente comando: ./sum Ejercicio 3: Loop Unrolling \u00b6 Afortunadamente, a\u00fan pueden obtener m\u00e1s mejoras en el rendimiento. Cuidadosamente, tomen el c\u00f3digo que crearon en el ejercicio previo y hagan un \"unroll\" del vector SIMD. Esto deber\u00eda mejorar el rendimiento en , aproximadamente, un factor de dos. Como un ejemplo de un \"loop unroll\", consideren la funci\u00f3n sum_unrolled() que se les proporciona: static int sum_unrolled ( int n , int * a ) { int sum = 0 ; // unrolled loop for ( int i = 0 ; i < n / 4 * 4 ; i += 4 ) { sum += a [ i + 0 ]; sum += a [ i + 1 ]; sum += a [ i + 2 ]; sum += a [ i + 3 ]; } // tail case for ( int i = n / 4 * 4 ; i < n ; i ++ ) { sum += a [ i ]; } return sum ; } Adem\u00e1s, si\u00e9ntanse libres de darle un vistazo al art\u00edculo de Wikipedia: Loop Unrolling , para m\u00e1s informaci\u00f3n. Dentro de sum.c , copien su c\u00f3digo de sum_vectorized() hacia sum_vectorized_unrolled() y hagan un unroll de cuatro. Para compilar su c\u00f3digo, corran el siguiente comando: make sum Para ejecutar su c\u00f3digo, corran el siguiente comando: ./sum Calificaci\u00f3n \u00b6 Al terminar, deben de subir su laboratorio al autograder con: ./submit <TOKEN> No olviden subir el link de su repositorio en Github al GES.","title":"9: SIMD"},{"location":"labs/lab09/#lab-10-simd-intrinsics-y-loop-unrolling","text":"","title":"Lab 10 - SIMD Intrinsics y Loop Unrolling"},{"location":"labs/lab09/#objetivos","text":"Aprender acerca de las instrucciones SIMD y hacer data level parallelism. Escribir c\u00f3digo con funciones SIMD para hacer ciertas optimizaciones. Aprender acerca de loop unrolling y por qu\u00e9 este funciona.","title":"Objetivos"},{"location":"labs/lab09/#preparacion","text":"Tienen que tener todos los archivos base, estos se encuentran aqu\u00ed . Recuerden que tienen que aprovechar el uso de Git y subir el link de su repositorio al GES, as\u00ed como al autograder, de lo contrario su nota ser\u00e1 de 0 .","title":"Preparaci\u00f3n"},{"location":"labs/lab09/#ejercicio-1-familiarizandose-con-las-funciones-simd","text":"Dado el gran n\u00famero disponible de instrucciones SIMD, queremos que ustedes aprendan c\u00f3mo encontrar aquellas que necesitar\u00e1n para determinadas aplicaciones. Intel proporciona una variedad de herramientas relacionadas a intrinsics, las cuales pueden encontrar aqu\u00ed (estas no son necesarias para este laboratorio). Nosotros estamos, particularmente, interesados en la Gu\u00eda Intel Intrinsics . Abran esta p\u00e1gina y, una vez est\u00e9n dentro, hagan click en todos los checkboxes que empiecen con SSE (desde SSE hasta SSE4.2). Hagan su mejor esfuerzo para interpretar esta nueva sintaxis y terminolog\u00eda. Encuentren la instrucci\u00f3n de 128 bits para las siguientes operaciones SIMD: Cuatro divisiones de punto flotante con precisi\u00f3n simple (float): a ) __m128 _mm_div_ss(__m128 a, __m128 b) b ) __m128 _mm_cvtsi64_ss(__m128 a, __int64 b) c ) float _mm_cvtss_f32(__m128 a) d ) __m128_mm_div_ps(__mm128 a, __mm128 b) e ) __m128 _mm_load_ps(float const* mem_addr) f ) __m128 _mm_loadu_ps(float const* mem_addr) Diecis\u00e9is operaciones de m\u00e1ximo sobre enteros de 8 bits con signo (char): a ) __m128i _mm_max_epi16 (__m128i a, __m128i b) b ) __m128i _mm_max_epi32 (__m128i a, __m128i b) c ) __m128i _mm_max_epi8 (__m128i a, __m128i b) d ) __m128i _mm_max_epu16 (__m128i a, __m128i b) e ) __m128i _mm_max_epu32 (__m128i a, __m128i b) f ) __m128i _mm_max_epu8 (__m128i a, __m128i b) g ) __m128d _mm_max_pd (__m128d a, __m128d b) h ) __m64 _mm_max_pi16 (__m64 a, __m64 b) i ) __m128 _mm_max_ps (__m128 a, __m128 b) j ) __m64 _mm_max_pu8 (__m64 a, __m64 b) k ) __m128d _mm_max_sd (__m128d a, __m128d b) l ) __m128 _mm_max_ss (__m128 a, __m128 b) Shift right aritm\u00e9tico sobre ocho enteros de 16 bits con signo (short): a ) __m128i _mm_add_epi16(__m128i a, __m128i b) b ) __m128i _mm_maskz_abs_epi8(__mmask16 k, __m128i a) c ) __m128i _mm_srai_epi16(__m128i a, __m128i count) d ) __m128i _mm_slli_epi64(__m128i a, int count) e ) __m128i _mm_srai_epi32(__m128i a, __m128i count) f ) __m128i _mm_sra_epi16(__m128i a, __m128i count) Escriban sus respuestas en el archivo ex1.txt . Ustedes tienen que colocar \u00fanicamente la letra de la opci\u00f3n que consideren correcta; ejemplo de un archivo correcto: 1: a 2: a 3: a","title":"Ejercicio 1: Familiariz\u00e1ndose con las funciones SIMD."},{"location":"labs/lab09/#ejercicio-2-escribiendo-codigo-simd","text":"Para el ejercicio 2, ustedes deben vectorizar el siguiente c\u00f3digo para lograr obtener, aproximadamente, cuatro veces la velocidad en comparaci\u00f3n a la implementaci\u00f3n que se muestra a continuaci\u00f3n: static int sum_naive ( int n , int * a ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ]; } return sum ; } Pueden encontrar \u00fatiles las siguientes intrinsics : SIMD Descripci\u00f3n __m128i _mm_setzero_si128( ) devuelve un vector de 128 bits de ceros __m128i _mm_loadu_si128(__m128i *p) devuelve el vector de 128 bits guardado en el puntero p __m128i _mm_add_epi32(__m128i a, __m128i b) devuelve el vector ($a_0 + b_0$, $a_1 + b_1$, $a_2 + b_2$, $a3 + b3$) void _mm_storeu_si128(__m128i *p,__m128i a) guarda el vector de 128 bits representado por el puntero p El archivo que deben modificar es sum.c . Usen las intrinsics SSE para implementar la funci\u00f3n sum_vectorized() . Para compilar su c\u00f3digo, ejecuten el siguiente comando: make sum Para ejecutar su c\u00f3digo, corran el siguiente comando: ./sum","title":"Ejercicio 2: Escribiendo C\u00f3digo SIMD"},{"location":"labs/lab09/#ejercicio-3-loop-unrolling","text":"Afortunadamente, a\u00fan pueden obtener m\u00e1s mejoras en el rendimiento. Cuidadosamente, tomen el c\u00f3digo que crearon en el ejercicio previo y hagan un \"unroll\" del vector SIMD. Esto deber\u00eda mejorar el rendimiento en , aproximadamente, un factor de dos. Como un ejemplo de un \"loop unroll\", consideren la funci\u00f3n sum_unrolled() que se les proporciona: static int sum_unrolled ( int n , int * a ) { int sum = 0 ; // unrolled loop for ( int i = 0 ; i < n / 4 * 4 ; i += 4 ) { sum += a [ i + 0 ]; sum += a [ i + 1 ]; sum += a [ i + 2 ]; sum += a [ i + 3 ]; } // tail case for ( int i = n / 4 * 4 ; i < n ; i ++ ) { sum += a [ i ]; } return sum ; } Adem\u00e1s, si\u00e9ntanse libres de darle un vistazo al art\u00edculo de Wikipedia: Loop Unrolling , para m\u00e1s informaci\u00f3n. Dentro de sum.c , copien su c\u00f3digo de sum_vectorized() hacia sum_vectorized_unrolled() y hagan un unroll de cuatro. Para compilar su c\u00f3digo, corran el siguiente comando: make sum Para ejecutar su c\u00f3digo, corran el siguiente comando: ./sum","title":"Ejercicio 3: Loop Unrolling"},{"location":"labs/lab09/#calificacion","text":"Al terminar, deben de subir su laboratorio al autograder con: ./submit <TOKEN> No olviden subir el link de su repositorio en Github al GES.","title":"Calificaci\u00f3n"},{"location":"labs/lab10/","text":"Lab 11 - Thread Level parallelism con OpenMP \u00b6 Objetivo \u00b6 Aprender acerca de OpenMP y thread level parallelism Referencias Adicional \u00b6 OpenMP Hands On OpenMP Tutorials Preparaci\u00f3n \u00b6 Tienen que tener todos los archivos base, estos se encuentran aqu\u00ed . Recuerden que tienen que aprovechar el uso de Git y subir el link de su repositorio al GES, as\u00ed como al autograder, de lo contrario su nota ser\u00e1 de 0 . Por favor revisen la secci\u00f3n de calificaci\u00f3n para conocer el l\u00edmite de submits que tienen . Introducci\u00f3n a OpenMP \u00b6 OpenMP es un framework de programaci\u00f3n paralela para C/C++ y Fortran. Ha ganado bastante popularidad en los \u00faltimos a\u00f1os, principalmente por su simplicidad y buen performance. En este laboratorio vamos a darle un vistazo a una peque\u00f1a fracci\u00f3n de sus caracter\u00edsticas, pero en la secci\u00f3n Referencia Adicional hay links con m\u00e1s informaci\u00f3n y tutoriales ( para los interesados ). Hay muchos tipos de paralelismo y patrones para aprovechar ese paralelismo. OpenMP utiliza un modelo de fork y join anidado. Por defecto, un programa de OpenMP es un programa sequencial normal, exceptuando las regiones que el programador explicitamente declara para que se ejecuten en paralelo. En la regi\u00f3n paralela, el framework crea (hace un fork) un n\u00famero de threads. Tipicamente estos threads ejecutan las mismas instrucciones, solo que en diferentes porciones de los datos. Al final de la regi\u00f3n paralela, el framework espera por todos los threads a que terminen (hace join) antes de dejar la regi\u00f3n y continuar secuencialmente. OpenMP utiliza memoria compartida , esto significa que todos los threads pueden acceder al mismo espacio de direcciones. La alternativa a esto ser\u00eda memoria distribuida , que es lo principal en clusters donde los datos deber\u00edan de ser movidos explicitamente entre espacios de direcciones. Muchos programadores encuentran la memoria compartida m\u00e1s f\u00e1cil de programar, dado que no tienen que preocuparse de mover los datos, pero es usualmente m\u00e1s dif\u00edcil de implementar en hardware de una manera escalable. M\u00e1s adelante en este laboratorio vamos a declarar memoria que va a ser local al thread ( solo el thread que la declara puede acceder a esta memoria ) por motivos de performance, pero OpenMP provee la flexibilidad para que los threads puedan compartir memoria sin que el programador lo haga. Ejemplo Hola Mundo \u00b6 Para este laboratorio, vamos a utilizar C. OpenMP es un framework con una interfaz de C, esto quiere decir que no es una parte del lenguaje como tal. La mayor\u00eda de caracter\u00edsticas son realmente directivas al compilador. Consideren la siguiente implementaci\u00f3n del Hola Mundo ( hello.c ) int main () { #pragma omp parallel { int thread_ID = omp_get_thread_num (); printf ( \" hello world %d \\n \" , thread_ID ); } } Este programa va a crear (fork) el n\u00famero por defecto de threads y cada thread creado va a imprimir \" hello world \" as\u00ed como tambi\u00e9n el n\u00famero que le corresponde. El #pragma le dice al compilador que el resto de la linea es una directiva, y en este caso es omp parallel . omp declara que es para OpenMP y parallel le dice que el siguiente bloque de c\u00f3digo (lo que est\u00e1 contenido en {} ) puede ser ejecutado en paralelo. Pueden probarlo con lo siguiente: make hello ./hello Corran el comando ./hello unas cuantas veces. Noten como los n\u00fameros de los threads no necesariamente se imprimen en orden num\u00e9rico y tampoco en el mismo orden si corren ./hello multiples veces, esto es porque en una regi\u00f3n omp parallel , el programador se garantiza que las operaciones se pueden hacer en paralelo, y que no hay un orden entre los threads. Tambi\u00e9n vale la pena notar que la variable thread_ID es local a cada thread. En general en OpenMP, las variables que se declaran a fuera de un bloque omp parallel tienen una sola copia y son compartidas a traves de todos los threads, mientras que las variables que se declaran adentro de ese bloque tienen una copia privada para cada thread. Ejercicio 1: Suma de Vectores \u00b6 La suma de vectores es un c\u00e1lculo inherentemente paralelo, as\u00ed que es bueno para que sea el primer ejercicio. La funci\u00f3n v_add adentro de v_add.c va a retornar un arreglo que es la suma de los vectores de entrada x y y componente por componente. Un primer intento de resolverlo se podr\u00eda ver as\u00ed: void v_add ( double * x , double * y , double * z ) { #pragma omp parallel { for ( int i = 0 ; i < ARRAY_SIZE ; i ++ ) z [ i ] = x [ i ] + y [ i ]; } } Pueden correr esto haciendo lo siguiente: make v_add ./v_add Y las pruebas que se ejecutar\u00e1n van a tomar el tiempo autom\u00e1ticamente y variar el n\u00famero de threads. Ustedes van a ver que a medida de que se incrementa el n\u00famero de threads cada vez se va haciendo m\u00e1s lento. Este problema se debe a que cada thread est\u00e1 ejecutando todo el c\u00f3digo dentro del bloque omp parallel , esto significa que si tienen 8 threads, van a estar sumando los vectores 8 veces. \u00a1\u00a1NO HAGAN ESTE TIPO DE COSAS!! . Para obtener una aceleraci\u00f3n al incrementar el n\u00famero de threads, necesitamos que cada thread haga menos trabajo, no la misma cantidad como antes. Su tarea es modificar v_add de tal manera que se note la aceleraci\u00f3n (la aceleraci\u00f3n se puede estancar a medida de que el n\u00famero de threads se incrementa). La mejor manera para hacer esto es decrementar la cantidad de trabajo que un thread hace. Para ayudarlos en el proceso, hay dos funciones \u00fatiles de OpenMP: int omp_get_num_threads() int omp_get_thread_num() La funci\u00f3n omp_get_num_threads() va a retornar cuantos threads hay dentro de un bloque omp parallel , y omp_get_thread_num() va a retornar el ID o n\u00famero de thread. Hay dos formas para dividir el trabajo en cada thread, la primera (que no deber\u00edan utilizar) es la t\u00e9cnica de slicing : cada thread maneja sumas adyacentes, es decir, el thread 0 va a sumar todos los elementos que est\u00e1n en los indices i tal que i % omp_get_num_threads() es 0, el thread 1 va a sumar todos los elementos tal que i % omp_get_num_threads() es 1 y as\u00ed... noten que este m\u00e9todo no va a ser eficiente porque va a sufrir de un problema llamado false sharing . La segunda manera de hacerlo (y como lo tienen que hacer ustedes) es la t\u00e9cnica de chunking : si hay N threads, hay que partir los vectores en N chunks continuos, y hacer que cada thread sume cada chunk (como la figura de arriba). PISTA: Puede ser que necesiten un caso especial para prevenir salirse del arreglo. No teman escribir un caso especial. Para este ejercicio, nosotros les estamos pidiendo que manualmente dividan el trabajo a traves de los threads. Dado que es un patr\u00f3n comun, los dise\u00f1adores de OpenMP hicieron una directiva que hace esto por ustedes autom\u00e1ticamente. Aqu\u00ed est\u00e1 la funci\u00f3n utilizando la directiva: ( Ustedes NO pueden utilizar esta directiva en su soluci\u00f3n del ejercicio. ) void v_add ( double * x , double * y , double * z ) { #pragma omp parallel { #pragma omp for for ( int i = 0 ; i < ARRAY_SIZE ; i ++ ) z [ i ] = x [ i ] + y [ i ]; } } Ejercicio 2: Producto Punto \u00b6 El siguiente calculo interesante que queremos ver es el producto punto entre dos vectores. A primera vista, implementar esto puede ser no muy diferente a v_add , pero el reto es como sumar todos los productos en una misma variable (reducci\u00f3n/reduction). Manejar de forma no inteligente la reducci\u00f3n va a resultar en las famosas condiciones de carrera: todos los threads est\u00e1n tratando de leer y escribir a la misma direcci\u00f3n simult\u00e1neamente. Una soluci\u00f3n es utilizar una secci\u00f3n cr\u00edtica. El c\u00f3digo en la secci\u00f3n cr\u00edtica puede ser \u00fanicamente ejecutado por un solo thread. Tener una secci\u00f3n cr\u00edtica naturalmente previene que multiples threads lean y escriban a los mismos datos, un problema que podr\u00eda llevar a condiciones de carrera. Una soluci\u00f3n no muy buena proteger\u00eda la suma con una secci\u00f3n cr\u00edtica (dotp.c): double dotp ( double * x , double * y ) { double global_sum = 0.0 ; #pragma omp parallel { #pragma omp for for ( int i = 0 ; i < ARRAY_SIZE ; i ++ ) #pragma omp critical global_sum += x [ i ] * y [ i ]; } return global_sum ; } Pruben el c\u00f3digo haciendo: make dotp ./dotp Noten como el performance es peor a medida que el n\u00famero de threads se incrementa. Dado que se est\u00e1 poniendo todo el trabajo de la reducci\u00f3n en la secci\u00f3n cr\u00edtica, hemos desperdiciado el paralelismo y hecho que solo un thread pueda hacer el trabajo cada tiempo (que no es exactamente la idea detr\u00e1s del paralelismo a nivel de threads). Esto es algo problem\u00e1tico, cada thread est\u00e1 constantemente luchando por la secci\u00f3n cr\u00edtica y solo uno est\u00e1 haciendo progreso en cualquier momento. A medida que el n\u00famero de threads incrementa, la cantidad de threads en espera tambi\u00e9n, y el performance paga el precio. \u00bfPueden arreglar ustedes este cuello de botella? PISTA: Reduzcan el n\u00famero de veces que cada thread necesita utilizar la secci\u00f3n cr\u00edtica. Pueden hacer esto de dos maneras diferentes tambi\u00e9n Pueden arreglarlo sin utilizar la palabra clave de OpenMP reduction , y tratar de reducir la cantidad de veces que un thread debe de sumar a la variable compartida global_sum . Pueden arreglarlo utilizando la palabra clave de OpenMP reduction (abran Google para buscar informaci\u00f3n). Si utilizan esta opci\u00f3n, ya no deber\u00edan de tener una secci\u00f3n cr\u00edtica. Adem\u00e1s van a necesitar escribir un + en alguna parte utilizando esto. La sint\u00e1xis exacta para utilizar estas directivas puede ser un poco confusa. Aqu\u00ed va un poco de informaci\u00f3n adicional: Una secci\u00f3n #pragma omp parallel puede ser especificada utilizando llaves {} que rodeen el c\u00f3digo a paralelizar. Una secci\u00f3n #pragma omp for no deber\u00eda de estar acompa\u00f1ada con llaves {} . Solo pongan la directiva arriba del for. Calificaci\u00f3n \u00b6 Al terminar, deben de subir su laboratorio al autograder con: ./submit <TOKEN> Para este laboratorio su soluci\u00f3n ser\u00e1 evaluada en un servidor de AWS EC2 por lo que \u00fanicamente tienen permitido hacer 3 submits . Les aconsejamos probar bien su c\u00f3digo antes de enviarlo al autograder. No olviden tambi\u00e9n subir el link de su repositorio en Github al GES.","title":"10: OpenMP"},{"location":"labs/lab10/#lab-11-thread-level-parallelism-con-openmp","text":"","title":"Lab 11 - Thread Level parallelism con OpenMP"},{"location":"labs/lab10/#objetivo","text":"Aprender acerca de OpenMP y thread level parallelism","title":"Objetivo"},{"location":"labs/lab10/#referencias-adicional","text":"OpenMP Hands On OpenMP Tutorials","title":"Referencias Adicional"},{"location":"labs/lab10/#preparacion","text":"Tienen que tener todos los archivos base, estos se encuentran aqu\u00ed . Recuerden que tienen que aprovechar el uso de Git y subir el link de su repositorio al GES, as\u00ed como al autograder, de lo contrario su nota ser\u00e1 de 0 . Por favor revisen la secci\u00f3n de calificaci\u00f3n para conocer el l\u00edmite de submits que tienen .","title":"Preparaci\u00f3n"},{"location":"labs/lab10/#introduccion-a-openmp","text":"OpenMP es un framework de programaci\u00f3n paralela para C/C++ y Fortran. Ha ganado bastante popularidad en los \u00faltimos a\u00f1os, principalmente por su simplicidad y buen performance. En este laboratorio vamos a darle un vistazo a una peque\u00f1a fracci\u00f3n de sus caracter\u00edsticas, pero en la secci\u00f3n Referencia Adicional hay links con m\u00e1s informaci\u00f3n y tutoriales ( para los interesados ). Hay muchos tipos de paralelismo y patrones para aprovechar ese paralelismo. OpenMP utiliza un modelo de fork y join anidado. Por defecto, un programa de OpenMP es un programa sequencial normal, exceptuando las regiones que el programador explicitamente declara para que se ejecuten en paralelo. En la regi\u00f3n paralela, el framework crea (hace un fork) un n\u00famero de threads. Tipicamente estos threads ejecutan las mismas instrucciones, solo que en diferentes porciones de los datos. Al final de la regi\u00f3n paralela, el framework espera por todos los threads a que terminen (hace join) antes de dejar la regi\u00f3n y continuar secuencialmente. OpenMP utiliza memoria compartida , esto significa que todos los threads pueden acceder al mismo espacio de direcciones. La alternativa a esto ser\u00eda memoria distribuida , que es lo principal en clusters donde los datos deber\u00edan de ser movidos explicitamente entre espacios de direcciones. Muchos programadores encuentran la memoria compartida m\u00e1s f\u00e1cil de programar, dado que no tienen que preocuparse de mover los datos, pero es usualmente m\u00e1s dif\u00edcil de implementar en hardware de una manera escalable. M\u00e1s adelante en este laboratorio vamos a declarar memoria que va a ser local al thread ( solo el thread que la declara puede acceder a esta memoria ) por motivos de performance, pero OpenMP provee la flexibilidad para que los threads puedan compartir memoria sin que el programador lo haga.","title":"Introducci\u00f3n a OpenMP"},{"location":"labs/lab10/#ejemplo-hola-mundo","text":"Para este laboratorio, vamos a utilizar C. OpenMP es un framework con una interfaz de C, esto quiere decir que no es una parte del lenguaje como tal. La mayor\u00eda de caracter\u00edsticas son realmente directivas al compilador. Consideren la siguiente implementaci\u00f3n del Hola Mundo ( hello.c ) int main () { #pragma omp parallel { int thread_ID = omp_get_thread_num (); printf ( \" hello world %d \\n \" , thread_ID ); } } Este programa va a crear (fork) el n\u00famero por defecto de threads y cada thread creado va a imprimir \" hello world \" as\u00ed como tambi\u00e9n el n\u00famero que le corresponde. El #pragma le dice al compilador que el resto de la linea es una directiva, y en este caso es omp parallel . omp declara que es para OpenMP y parallel le dice que el siguiente bloque de c\u00f3digo (lo que est\u00e1 contenido en {} ) puede ser ejecutado en paralelo. Pueden probarlo con lo siguiente: make hello ./hello Corran el comando ./hello unas cuantas veces. Noten como los n\u00fameros de los threads no necesariamente se imprimen en orden num\u00e9rico y tampoco en el mismo orden si corren ./hello multiples veces, esto es porque en una regi\u00f3n omp parallel , el programador se garantiza que las operaciones se pueden hacer en paralelo, y que no hay un orden entre los threads. Tambi\u00e9n vale la pena notar que la variable thread_ID es local a cada thread. En general en OpenMP, las variables que se declaran a fuera de un bloque omp parallel tienen una sola copia y son compartidas a traves de todos los threads, mientras que las variables que se declaran adentro de ese bloque tienen una copia privada para cada thread.","title":"Ejemplo Hola Mundo"},{"location":"labs/lab10/#ejercicio-1-suma-de-vectores","text":"La suma de vectores es un c\u00e1lculo inherentemente paralelo, as\u00ed que es bueno para que sea el primer ejercicio. La funci\u00f3n v_add adentro de v_add.c va a retornar un arreglo que es la suma de los vectores de entrada x y y componente por componente. Un primer intento de resolverlo se podr\u00eda ver as\u00ed: void v_add ( double * x , double * y , double * z ) { #pragma omp parallel { for ( int i = 0 ; i < ARRAY_SIZE ; i ++ ) z [ i ] = x [ i ] + y [ i ]; } } Pueden correr esto haciendo lo siguiente: make v_add ./v_add Y las pruebas que se ejecutar\u00e1n van a tomar el tiempo autom\u00e1ticamente y variar el n\u00famero de threads. Ustedes van a ver que a medida de que se incrementa el n\u00famero de threads cada vez se va haciendo m\u00e1s lento. Este problema se debe a que cada thread est\u00e1 ejecutando todo el c\u00f3digo dentro del bloque omp parallel , esto significa que si tienen 8 threads, van a estar sumando los vectores 8 veces. \u00a1\u00a1NO HAGAN ESTE TIPO DE COSAS!! . Para obtener una aceleraci\u00f3n al incrementar el n\u00famero de threads, necesitamos que cada thread haga menos trabajo, no la misma cantidad como antes. Su tarea es modificar v_add de tal manera que se note la aceleraci\u00f3n (la aceleraci\u00f3n se puede estancar a medida de que el n\u00famero de threads se incrementa). La mejor manera para hacer esto es decrementar la cantidad de trabajo que un thread hace. Para ayudarlos en el proceso, hay dos funciones \u00fatiles de OpenMP: int omp_get_num_threads() int omp_get_thread_num() La funci\u00f3n omp_get_num_threads() va a retornar cuantos threads hay dentro de un bloque omp parallel , y omp_get_thread_num() va a retornar el ID o n\u00famero de thread. Hay dos formas para dividir el trabajo en cada thread, la primera (que no deber\u00edan utilizar) es la t\u00e9cnica de slicing : cada thread maneja sumas adyacentes, es decir, el thread 0 va a sumar todos los elementos que est\u00e1n en los indices i tal que i % omp_get_num_threads() es 0, el thread 1 va a sumar todos los elementos tal que i % omp_get_num_threads() es 1 y as\u00ed... noten que este m\u00e9todo no va a ser eficiente porque va a sufrir de un problema llamado false sharing . La segunda manera de hacerlo (y como lo tienen que hacer ustedes) es la t\u00e9cnica de chunking : si hay N threads, hay que partir los vectores en N chunks continuos, y hacer que cada thread sume cada chunk (como la figura de arriba). PISTA: Puede ser que necesiten un caso especial para prevenir salirse del arreglo. No teman escribir un caso especial. Para este ejercicio, nosotros les estamos pidiendo que manualmente dividan el trabajo a traves de los threads. Dado que es un patr\u00f3n comun, los dise\u00f1adores de OpenMP hicieron una directiva que hace esto por ustedes autom\u00e1ticamente. Aqu\u00ed est\u00e1 la funci\u00f3n utilizando la directiva: ( Ustedes NO pueden utilizar esta directiva en su soluci\u00f3n del ejercicio. ) void v_add ( double * x , double * y , double * z ) { #pragma omp parallel { #pragma omp for for ( int i = 0 ; i < ARRAY_SIZE ; i ++ ) z [ i ] = x [ i ] + y [ i ]; } }","title":"Ejercicio 1: Suma de Vectores"},{"location":"labs/lab10/#ejercicio-2-producto-punto","text":"El siguiente calculo interesante que queremos ver es el producto punto entre dos vectores. A primera vista, implementar esto puede ser no muy diferente a v_add , pero el reto es como sumar todos los productos en una misma variable (reducci\u00f3n/reduction). Manejar de forma no inteligente la reducci\u00f3n va a resultar en las famosas condiciones de carrera: todos los threads est\u00e1n tratando de leer y escribir a la misma direcci\u00f3n simult\u00e1neamente. Una soluci\u00f3n es utilizar una secci\u00f3n cr\u00edtica. El c\u00f3digo en la secci\u00f3n cr\u00edtica puede ser \u00fanicamente ejecutado por un solo thread. Tener una secci\u00f3n cr\u00edtica naturalmente previene que multiples threads lean y escriban a los mismos datos, un problema que podr\u00eda llevar a condiciones de carrera. Una soluci\u00f3n no muy buena proteger\u00eda la suma con una secci\u00f3n cr\u00edtica (dotp.c): double dotp ( double * x , double * y ) { double global_sum = 0.0 ; #pragma omp parallel { #pragma omp for for ( int i = 0 ; i < ARRAY_SIZE ; i ++ ) #pragma omp critical global_sum += x [ i ] * y [ i ]; } return global_sum ; } Pruben el c\u00f3digo haciendo: make dotp ./dotp Noten como el performance es peor a medida que el n\u00famero de threads se incrementa. Dado que se est\u00e1 poniendo todo el trabajo de la reducci\u00f3n en la secci\u00f3n cr\u00edtica, hemos desperdiciado el paralelismo y hecho que solo un thread pueda hacer el trabajo cada tiempo (que no es exactamente la idea detr\u00e1s del paralelismo a nivel de threads). Esto es algo problem\u00e1tico, cada thread est\u00e1 constantemente luchando por la secci\u00f3n cr\u00edtica y solo uno est\u00e1 haciendo progreso en cualquier momento. A medida que el n\u00famero de threads incrementa, la cantidad de threads en espera tambi\u00e9n, y el performance paga el precio. \u00bfPueden arreglar ustedes este cuello de botella? PISTA: Reduzcan el n\u00famero de veces que cada thread necesita utilizar la secci\u00f3n cr\u00edtica. Pueden hacer esto de dos maneras diferentes tambi\u00e9n Pueden arreglarlo sin utilizar la palabra clave de OpenMP reduction , y tratar de reducir la cantidad de veces que un thread debe de sumar a la variable compartida global_sum . Pueden arreglarlo utilizando la palabra clave de OpenMP reduction (abran Google para buscar informaci\u00f3n). Si utilizan esta opci\u00f3n, ya no deber\u00edan de tener una secci\u00f3n cr\u00edtica. Adem\u00e1s van a necesitar escribir un + en alguna parte utilizando esto. La sint\u00e1xis exacta para utilizar estas directivas puede ser un poco confusa. Aqu\u00ed va un poco de informaci\u00f3n adicional: Una secci\u00f3n #pragma omp parallel puede ser especificada utilizando llaves {} que rodeen el c\u00f3digo a paralelizar. Una secci\u00f3n #pragma omp for no deber\u00eda de estar acompa\u00f1ada con llaves {} . Solo pongan la directiva arriba del for.","title":"Ejercicio 2: Producto Punto"},{"location":"labs/lab10/#calificacion","text":"Al terminar, deben de subir su laboratorio al autograder con: ./submit <TOKEN> Para este laboratorio su soluci\u00f3n ser\u00e1 evaluada en un servidor de AWS EC2 por lo que \u00fanicamente tienen permitido hacer 3 submits . Les aconsejamos probar bien su c\u00f3digo antes de enviarlo al autograder. No olviden tambi\u00e9n subir el link de su repositorio en Github al GES.","title":"Calificaci\u00f3n"},{"location":"labs/labCache/","text":"Lab 9 - Localidad de Datos y Caches \u00b6 Objetivos \u00b6 Entender c\u00f3mo los patrones de acceso a memoria determinan las tasas de cache hits . Pensar qu\u00e9 patrones de acceso a memoria producen BUENAS tasas de acierto. Aprender sobre una t\u00e9cnica para mejorar los accesos a memoria. Preparaci\u00f3n \u00b6 Aqu\u00ed pueden descargar los archivos que utilizar\u00e1n para esta pr\u00e1ctica. Notas \u00b6 Para esta pr\u00e1ctica de laboratorio se utilizar\u00e1 Venus , un simulador de c\u00f3digo de ensamblador en l\u00ednea. Este programa permite visualizar los accesos al cache. Este laboratorio es complicado, largo y dif\u00edcil. Aseg\u00farense de saber lo requerido sobre el tema antes de subir los resultados al autograder y \u00a1PREGUNTEN si no entienden! No se olviden que el tema de caches viene en el examen parcial, por lo que la visualizaci\u00f3n de acceso a caches es una manera pr\u00e1ctica para aprender sobre los cache hits y cache misses . En este punto, lean cache.s para tener una idea de qu\u00e9 es lo que hace. Aseg\u00farense de revisar qu\u00e9 contienen los registros de argumentos antes de proceder a analizar la configuraci\u00f3n del cache. Lo m\u00e1s importante de entender de este archivo es que se pondr\u00e1n en cero algunos elementos de un arreglo (opci\u00f3n 0) o se incrementar\u00e1n (opci\u00f3n 1). Los elementos a editar est\u00e1n determinados por el step size y la cantidad de veces que se realiza este procedimiento lo indica repcount . Estos dos par\u00e1metros son los que m\u00e1s afectar\u00e1n la cantidad de cache hits y misses que ocurrir\u00e1n. El valor de option tambi\u00e9n alterar\u00e1 algunas, as\u00ed como los par\u00e1metros del cache mismo, por supuesto. Ejercicio 1: Algunos Escenarios de Acceso a Memoria \u00b6 Para este ejercicio deben de contestar las preguntas adjuntas, con el formato indicado, en el archivo ex1.txt . Intenten razonar cu\u00e1l va a ser la tasa de aciertos ANTES de correr la simulaci\u00f3n. Luego de ejecutar el c\u00f3digo, aseg\u00farense de entender POR QU\u00c9 ocurre lo que ocurre. No duden en preguntar si se sienten confundidos. Eso es totalmente normal y los auxiliares est\u00e1n ah\u00ed para ayudarlos. Estas son buenas preguntas para hacerse mientras realizan los ejercicios: \u00bfQu\u00e9 tan grande es su cache block ? \u00bfCu\u00e1ntos accesos consecutivos (tomando en cuenta el step size ) caben en un \u00fanico block? \u00bfCu\u00e1nta data cabe en el cache COMPLETO? \u00bfQu\u00e9 tan lejos, en memoria, est\u00e1n los bloques que mapean al mismo set (y que pudieran causar conflictos)? \u00bfCu\u00e1l es la asociatividad de su cache? \u00bfEn qu\u00e9 parte del cache mapea alg\u00fan bloque particular? * Al considerar por qu\u00e9 un acceso espec\u00edfico es un hit o un miss: \u00bfya se accedi\u00f3 a esta data antes? Si s\u00ed, \u00bfsigue en el cache o no? Escenario #1 \u00b6 Cache Parameters: (editados en la pesta\u00f1a de \"Cache\" en el simulador) Pol\u00edtica de colocaci\u00f3n: Direct Mapping Pol\u00edtica de reemplazo de bloques: LRU Tama\u00f1o del set (bloques) (setSize): 1 Cantidad de bloques: 4 * Tama\u00f1o de los bloques del cache (en words ) (blockSize): 2 Par\u00e1metros del Programa: (inicializando los valores de los argumentos en el c\u00f3digo) Tama\u00f1o del arreglo (arraySize): 128 bytes Tama\u00f1o del salto (stepSize): 8 N\u00famero de repeticiones (repCount): 4 Opci\u00f3n: 0 Tip : Si les es dif\u00edcil visualizar qu\u00e9 est\u00e1 entrando en el cache en cada acceso a memoria simplemente viendo el c\u00f3digo, prueben utilizando l\u00e1piz y papel: escriban cu\u00e1l ser\u00eda el tag:index:offset de las direcciones y averig\u00fcen cu\u00e1les direcciones de memoria mapean a los distintos sets en cache con los bits del index. Preguntas: \u00bfQu\u00e9 combinaci\u00f3n de par\u00e1metros produce el hit rate que se puede observar? (Pista: Su respuesta debe de ser de la forma: \"Porque [par\u00e1metro 1], en bytes, es exactamente igual a [par\u00e1metro 2], en bytes.\") \u00bfEn cu\u00e1nto aumenta el hit rate al incrementar la cantidad de repeticiones de manera arbitraria (en %)? \u00bfC\u00f3mo se puede modificar alg\u00fan par\u00e1metro del programa para mejorar el hit rate? Nota : No importa que accedan a los mismos elementos en el arreglo, s\u00f3lo provean una modificaci\u00f3n de un par\u00e1metro del programa que aumente el hit rate. Aumentar el tama\u00f1o del arreglo. Disminuir el tama\u00f1o del arreglo. Aumentar el tama\u00f1o del salto. Disminuir el tama\u00f1o del salto. Aumentar el n\u00famero de repeticiones. Disminuir el n\u00famero de repeticiones. Cambiar a la opci\u00f3n 1. Escenario #2 \u00b6 Cache Parameters: Pol\u00edtica de colocaci\u00f3n: N-Way Set Associative Pol\u00edtica de reemplazo de bloques: LRU Tama\u00f1o del set (bloques) (setSize): 4 Cantidad de bloques: 16 * Tama\u00f1o de los bloques del cache (en words ) (blockSize): 4 Par\u00e1metros del Programa: (inicializando los valores de los argumentos en el c\u00f3digo) Tama\u00f1o del arreglo (arraySize): 256 bytes Tama\u00f1o del salto (stepSize): 2 N\u00famero de repeticiones: 1 Opci\u00f3n (repCount): 1 Preguntas: \u00bfCu\u00e1ntos accesos a memoria hay por cada iteraci\u00f3n en el ciclo interno? (Pista: No es uno.) \u00bfCu\u00e1l es el patr\u00f3n que se repite de aciertos y fallos? miss/hit miss/hit/hit miss/hit/hit/hit hit/miss/miss/miss hit/miss \u00bfC\u00f3mo se relaciona el hit rate con el patr\u00f3n de la pregunta anterior? Aplicando una media geom\u00e9trica a los valores del patr\u00f3n se puede obtener el hit rate. El hit rate es el resultado de una media aritm\u00e9tica del patr\u00f3n. Se debe de calcular la media ponderada con los resultados del patr\u00f3n. Al patr\u00f3n se le debe aplicar la media arm\u00f3nica para calcular el hit rate. Ninguna de las anteriores. \u00bfQu\u00e9 ocurre si se altera la cantidad de iteraciones de manera arbitraria? La cantidad de cache misses aumenta. La cantidad de cache hits aumenta. La cantidad de cache misses se queda igual. La cantidad de cache hits se queda igual. El hit rate aumenta. El hit rate disminuye. El hit rate se mantiene constante. \u00bfPor qu\u00e9 le ocurre, lo indicado en la pregunta anterior, al hit rate? Porque se aprovecha la localidad espacial. Porque se aprovecha la localidad temporal. Porque no se aprovecha la localidad espacial. Porque no se aprovecha la localidad temporal. Porque la cantidad de repeticiones no tiene impacto en el hit rate. Nota importante para el archivo ex1.txt : Solo se debe escribir las inc\u00f3gnitas en cada fila, estas deben estar separadas por una coma, sin espacios (si la pregunta posee m\u00e1s de una respuesta). Por ejemplo: 1.blockSize,stepSize,arraySize. Ejercicio 2: Ordenamiento de Ciclos y Multiplicaci\u00f3n de Matrices \u00b6 Si recuerdan, las matrices son estructuras de datos bidimensionales en donde cada elemento es accedido por medio de dos \u00edndices. Para poder multiplicar dos matrices, se puede utilizar tres ciclos anidados. Asumiendo que las matrices A, B y C son de nxn y guardadas en un arreglo de una dimensi\u00f3n, en donde sus elementos est\u00e1n ubicados de manera contigua en memoria: for (int i = 0; i < n; i++) for (int j = 0; j < n; j++) for (int k = 0; k < n; k++) C[i+j*n] += A[i+k*n] * B[k+j*n]; Hecho: La multiplicaci\u00f3n de matrices se encuentran detr\u00e1s de numerosos algoritmos de \u00e1lgebra lineal y la operaci\u00f3n eficaz de ello es cr\u00edtico para muchas aplicaciones dentro de las ciencias aplicadas. N\u00f3tese que en el c\u00f3digo superior los ciclos est\u00e1n ordenados como i, j, k. Si se examina el bucle m\u00e1s \u00edntimo, se puede ver que este...: recorre B en pasos unitarios. recorre A en progresos de tama\u00f1o n. * no recorre C. RECORDAR: Para calcular la multiplicaci\u00f3n de matrices de manera correcta, no importa el orden de los ciclos . PERO , el orden elegido para acceder a los elementos de las matrices pueden tener un impacto muy grande en el rendimiento . Los caches se benefician m\u00e1s (m\u00e1s cache hits; menos misses) cuando el acceso a memoria se aprovecha de la temporalidad espacial y de la espacial, utilizando bloques ya dentro del cache. Optimizando los accesos de memoria de un programa es esencial para aprovecharse de la jerarqu\u00eda de memoria. Gu\u00eden su atenci\u00f3n a matrixMultiply.c , en este archivo se realizan varias implementaciones de la multiplicaci\u00f3n de matrices con tres ciclos anidados. Compilar y ejecutar el c\u00f3digo con el siguiente comando: make ex2 Esto realizar\u00e1 las operaciones de matrices e indicar\u00e1 la velocidad con la que cada iteraci\u00f3n complete las multiplicaciones. La unidad \"Gflops/s\" se lee como \"Giga-floating-point-operations per second\". Preguntas: 1. \u00bfQu\u00e9 ordenamiento(s) rinde(n) mejor? multMat1 multMat2 multMat3 multMat4 multMat5 multMat6 \u00bfPor qu\u00e9? Porque se aprovecha la localidad espacial. Porque se aprovecha la localidad temporal. Porque utiliza loop unrolling. Porque se realiza cache blocking. \u00bfQu\u00e9 versi\u00f3n (o versiones) muestra(n) ser la(s) m\u00e1s lenta(s)? multMat1 multMat2 multMat3 multMat4 multMat5 multMat6 \u00bfPor qu\u00e9? Porque no se aprovecha la localidad espacial. Porque no se aprovecha la localidad temporal. Porque no utiliza loop unrolling. Porque no se realiza cache blocking. \u00bfC\u00f3mo afecta la manera de recorrer las matrices, respecto del \u00edndice que se encuentra en el ciclo m\u00e1s \u00edntimo, al rendimiento? Es el que mayor impacto tiene en el rendimiento. Su impacto en el rendimiento es irrelevante. De este depende si se aprovecha la localidad temporal o no. Este influye directamente el aprovechamiento de la localidad espacial. Es igual de importante que el resto de \u00edndices. Nota importante para el archivo ex2.txt : Similar al archivo de texto del ejercicio anterior, si se requiere de m\u00e1s de una respuesta a una pregunta, estas deben de estar separadas por comas, sin espacios. Por ejemplo: 3.ii,iv. Ejercicio 3: Cache Blocking y Transposici\u00f3n de Matrices \u00b6 Transposici\u00f3n de Matrices \u00b6 En algunas ocasiones, se requiere intercambiar las filas con las columnas de una matriz, esta operaci\u00f3n se llama una transposici\u00f3n . Una implementaci\u00f3n eficiente pude ser de gran utilidad al implementar operaciones algebraicas m\u00e1s complejas. La matriz transpuesta de A suele denotarse como A T . Cache Blocking \u00b6 En el c\u00f3digo ejemplo de multiplicaci\u00f3n de matrices del ejercicio anterior se puede notar que se recorren las matrices A y B en su totalidad para calcular un \u00fanico valor para C. Por lo mismo, \u00a1constantemente se debe de acceder a valores nuevos de memoria, reusando muy poca data en con el cache! Se puede mejorar el reuso de data en los caches implementando un t\u00e9cnica llamada cache blocking. Formalmente, cache blocking es una t\u00e9cnica que busca reducir la tasa de cache misses a\u00fan m\u00e1s al explotar la temporalidad espacial y/o temporal . En el caso de la transposici\u00f3n de matrices, se considera realizarla un bloque a la vez. Notar: En la imagen superior, se transpone cada submatriz A ij de la matriz A en su posici\u00f3n final de la matriz de salida, una submatriz a la vez. Es importante entender que la transposici\u00f3n de por secciones es equivalente a hacerlo para toda la matriz. Como se opera y se termina de transponer cada submatriz una a la vez, se consodila el acceso a memoria a un espacio de memoria menor al transponer esa submatriz, aprovechando las localidades temporales (y espaciales), mejorando el rendimiento del cache, acortando el tiempo de ejecuci\u00f3n del programa. Para este laboratorio, se implementar\u00e1 una estructura de cache blocking para la transposici\u00f3n de matrices y se analizar\u00e1 su rendimiento. Su tarea es implementar esta t\u00e9cnica en la funci\u00f3n transpose_blocking() en transpose.c . NO pueden asumir que el ancho de la matriz (n) es un m\u00faltiplo del tama\u00f1o del bloque. Luego de implementar la funci\u00f3n, pueden probar el c\u00f3digo corriendo los siguientes comandos: make ex3 ./transpose <n> <blocksize> Donde n y blocksize son par\u00e1metros que ser\u00e1n especificados por el usuario. Se puede verificar el funcionamiento del c\u00f3digo eligiendo n=10000 y blocksize=33. La versi\u00f3n con blocking deber\u00eda terminar significantemente m\u00e1s r\u00e1pido. A continuaci\u00f3n, se muestra una gu\u00eda por si no saben c\u00f3mo comenzar . De lo contrario, pueden saltarse esta parte y comenzar. Algunos consejos: Pueden empezar viendo la funci\u00f3n transpose_naive . Notar que el \u00edndice y recorre TODA la matriz src de manera vertical en una iteraci\u00f3n del ciclo externo antes de ser reiniciada a cero. Es decir, x se actualiza hasta que y termine su recorrido. Este es el comportamiento que se debe corregir. Lo que se quiere es moverse a la siguiente fila de dst despu\u00e9s de recorrer el ancho (eje horizontal) de un solo bloque. \u00bfQu\u00e9 tan grande es cada bloque? El n\u00famero de enteros especificados por blocksize . Adem\u00e1s , solo se desea mover en el eje vertical (la altura) de un bloque antes de proseguir al siguiente. No se busca que x imite el comportamiento que se quiere evitar con el par\u00e1metro y . Ayuda: Una soluci\u00f3n est\u00e1ndar requiere de cuatro ciclos for . Finalmente, como no se puede asumir que n es un m\u00faltiplo de blocksize , la \u00faltima columna del bloque de cada fila ser\u00e1 m\u00e1s corta (no ser\u00e1 un cuadrado de block_size por block_size ). Adem\u00e1s, la \u00faltima fila del bloque estar\u00e1 truncada. Para arreglar este problema, se puede realizar la situaci\u00f3n general que n s\u00ed es m\u00faltiplo de block_size y agregar, como caso especial, una alternativa para lidiar con la excepci\u00f3n de que se est\u00e1 recorriendo una parte del arreglo inexistente. Cuando ya funcione el c\u00f3digo , se deben completar los siguientes ejercicios: Alternado los Tama\u00f1os de los Arreglos \u00b6 Fijar el tama\u00f1o del bloque a 20 y ejecutar el c\u00f3digo con las siguientes variantes de n : 50, 100, 500, 1000, 5000. \u00bfA partir de qu\u00e9 punto se puede notar una mejora en rendimiento al comparar la versi\u00f3n con cache blocking y la versi\u00f3n com\u00fan? 50 100 500 1000 5000 \u00bfPor qu\u00e9 el m\u00e9todo de cache blocking requiere que la matriz sea de cierto tama\u00f1o para que su mejora sea percibida? Porque necesita aprovechar la localidad espacial. Porque as\u00ed puede explotar la localidad temporal. Porque el tama\u00f1o de la matriz debe ser un m\u00faltiplo del tama\u00f1o del bloque. Por la Ley de Amdahl. Ninguna de las anteriores. Cambiando el Tama\u00f1o del Bloque \u00b6 Fijar el ancho de las matrices a 10000 y correr el c\u00f3digo con los siguientes valores para blocksize : 100, 1000, 2000, 5000, 10000. \u00bfC\u00f3mo se ve afectada la velocidad de ejecuci\u00f3n de transpose_blocking() al cambiar el tama\u00f1o del bloque? Aumenta de manera lineal. Disminuye de manera lineal. Aumenta de manera logar\u00edtmica. Disminuye de manera logar\u00edtmica. Se mantiene constante. \u00bfPor qu\u00e9 ocurre lo indicado en la respuesta anterior? Porque se aprovecha m\u00e1s el uso de los bloques si son m\u00e1s grandes. Porque se desaprovecha el uso de los bloques si su tama\u00f1o aumenta. Porque se aprovecha de la localidad espacial. Porque se aprovecha de la localidad temporal. Porque es una caracter\u00edstica intr\u00ednseca de la operaci\u00f3n realizada. Escribir las respuestas en el archivo ex3.txt . Siguiendo las directrices indicadas para los ejercicios anteriores. Es relevante notar que en los \u00faltimos dos ejercicios no fue necesario conocer los par\u00e1metros del cache de sus computadoras. Solo se exhibi\u00f3 un nivel m\u00e1s alto de localidad y se aceler\u00f3 la ejecuci\u00f3n del programa. Esto implica que todos los caches, sin importar sus par\u00e1metros espec\u00edficos, se benefician al ejecutar c\u00f3digo que se aprovecha de altos niveles de localidad. Calificaci\u00f3n \u00b6 Recuerden que pueden evaluar, de manera local, sus respuestas ejecutando: ./check Al terminar, deben de subir su laboratorio al calificador en l\u00ednea con: ./submit <TOKEN>","title":"Lab 9 - Localidad de Datos y Caches"},{"location":"labs/labCache/#lab-9-localidad-de-datos-y-caches","text":"","title":"Lab 9 - Localidad de Datos y Caches"},{"location":"labs/labCache/#objetivos","text":"Entender c\u00f3mo los patrones de acceso a memoria determinan las tasas de cache hits . Pensar qu\u00e9 patrones de acceso a memoria producen BUENAS tasas de acierto. Aprender sobre una t\u00e9cnica para mejorar los accesos a memoria.","title":"Objetivos"},{"location":"labs/labCache/#preparacion","text":"Aqu\u00ed pueden descargar los archivos que utilizar\u00e1n para esta pr\u00e1ctica.","title":"Preparaci\u00f3n"},{"location":"labs/labCache/#notas","text":"Para esta pr\u00e1ctica de laboratorio se utilizar\u00e1 Venus , un simulador de c\u00f3digo de ensamblador en l\u00ednea. Este programa permite visualizar los accesos al cache. Este laboratorio es complicado, largo y dif\u00edcil. Aseg\u00farense de saber lo requerido sobre el tema antes de subir los resultados al autograder y \u00a1PREGUNTEN si no entienden! No se olviden que el tema de caches viene en el examen parcial, por lo que la visualizaci\u00f3n de acceso a caches es una manera pr\u00e1ctica para aprender sobre los cache hits y cache misses . En este punto, lean cache.s para tener una idea de qu\u00e9 es lo que hace. Aseg\u00farense de revisar qu\u00e9 contienen los registros de argumentos antes de proceder a analizar la configuraci\u00f3n del cache. Lo m\u00e1s importante de entender de este archivo es que se pondr\u00e1n en cero algunos elementos de un arreglo (opci\u00f3n 0) o se incrementar\u00e1n (opci\u00f3n 1). Los elementos a editar est\u00e1n determinados por el step size y la cantidad de veces que se realiza este procedimiento lo indica repcount . Estos dos par\u00e1metros son los que m\u00e1s afectar\u00e1n la cantidad de cache hits y misses que ocurrir\u00e1n. El valor de option tambi\u00e9n alterar\u00e1 algunas, as\u00ed como los par\u00e1metros del cache mismo, por supuesto.","title":"Notas"},{"location":"labs/labCache/#ejercicio-1-algunos-escenarios-de-acceso-a-memoria","text":"Para este ejercicio deben de contestar las preguntas adjuntas, con el formato indicado, en el archivo ex1.txt . Intenten razonar cu\u00e1l va a ser la tasa de aciertos ANTES de correr la simulaci\u00f3n. Luego de ejecutar el c\u00f3digo, aseg\u00farense de entender POR QU\u00c9 ocurre lo que ocurre. No duden en preguntar si se sienten confundidos. Eso es totalmente normal y los auxiliares est\u00e1n ah\u00ed para ayudarlos. Estas son buenas preguntas para hacerse mientras realizan los ejercicios: \u00bfQu\u00e9 tan grande es su cache block ? \u00bfCu\u00e1ntos accesos consecutivos (tomando en cuenta el step size ) caben en un \u00fanico block? \u00bfCu\u00e1nta data cabe en el cache COMPLETO? \u00bfQu\u00e9 tan lejos, en memoria, est\u00e1n los bloques que mapean al mismo set (y que pudieran causar conflictos)? \u00bfCu\u00e1l es la asociatividad de su cache? \u00bfEn qu\u00e9 parte del cache mapea alg\u00fan bloque particular? * Al considerar por qu\u00e9 un acceso espec\u00edfico es un hit o un miss: \u00bfya se accedi\u00f3 a esta data antes? Si s\u00ed, \u00bfsigue en el cache o no?","title":"Ejercicio 1: Algunos Escenarios de Acceso a Memoria"},{"location":"labs/labCache/#escenario-1","text":"Cache Parameters: (editados en la pesta\u00f1a de \"Cache\" en el simulador) Pol\u00edtica de colocaci\u00f3n: Direct Mapping Pol\u00edtica de reemplazo de bloques: LRU Tama\u00f1o del set (bloques) (setSize): 1 Cantidad de bloques: 4 * Tama\u00f1o de los bloques del cache (en words ) (blockSize): 2 Par\u00e1metros del Programa: (inicializando los valores de los argumentos en el c\u00f3digo) Tama\u00f1o del arreglo (arraySize): 128 bytes Tama\u00f1o del salto (stepSize): 8 N\u00famero de repeticiones (repCount): 4 Opci\u00f3n: 0 Tip : Si les es dif\u00edcil visualizar qu\u00e9 est\u00e1 entrando en el cache en cada acceso a memoria simplemente viendo el c\u00f3digo, prueben utilizando l\u00e1piz y papel: escriban cu\u00e1l ser\u00eda el tag:index:offset de las direcciones y averig\u00fcen cu\u00e1les direcciones de memoria mapean a los distintos sets en cache con los bits del index. Preguntas: \u00bfQu\u00e9 combinaci\u00f3n de par\u00e1metros produce el hit rate que se puede observar? (Pista: Su respuesta debe de ser de la forma: \"Porque [par\u00e1metro 1], en bytes, es exactamente igual a [par\u00e1metro 2], en bytes.\") \u00bfEn cu\u00e1nto aumenta el hit rate al incrementar la cantidad de repeticiones de manera arbitraria (en %)? \u00bfC\u00f3mo se puede modificar alg\u00fan par\u00e1metro del programa para mejorar el hit rate? Nota : No importa que accedan a los mismos elementos en el arreglo, s\u00f3lo provean una modificaci\u00f3n de un par\u00e1metro del programa que aumente el hit rate. Aumentar el tama\u00f1o del arreglo. Disminuir el tama\u00f1o del arreglo. Aumentar el tama\u00f1o del salto. Disminuir el tama\u00f1o del salto. Aumentar el n\u00famero de repeticiones. Disminuir el n\u00famero de repeticiones. Cambiar a la opci\u00f3n 1.","title":"Escenario #1"},{"location":"labs/labCache/#escenario-2","text":"Cache Parameters: Pol\u00edtica de colocaci\u00f3n: N-Way Set Associative Pol\u00edtica de reemplazo de bloques: LRU Tama\u00f1o del set (bloques) (setSize): 4 Cantidad de bloques: 16 * Tama\u00f1o de los bloques del cache (en words ) (blockSize): 4 Par\u00e1metros del Programa: (inicializando los valores de los argumentos en el c\u00f3digo) Tama\u00f1o del arreglo (arraySize): 256 bytes Tama\u00f1o del salto (stepSize): 2 N\u00famero de repeticiones: 1 Opci\u00f3n (repCount): 1 Preguntas: \u00bfCu\u00e1ntos accesos a memoria hay por cada iteraci\u00f3n en el ciclo interno? (Pista: No es uno.) \u00bfCu\u00e1l es el patr\u00f3n que se repite de aciertos y fallos? miss/hit miss/hit/hit miss/hit/hit/hit hit/miss/miss/miss hit/miss \u00bfC\u00f3mo se relaciona el hit rate con el patr\u00f3n de la pregunta anterior? Aplicando una media geom\u00e9trica a los valores del patr\u00f3n se puede obtener el hit rate. El hit rate es el resultado de una media aritm\u00e9tica del patr\u00f3n. Se debe de calcular la media ponderada con los resultados del patr\u00f3n. Al patr\u00f3n se le debe aplicar la media arm\u00f3nica para calcular el hit rate. Ninguna de las anteriores. \u00bfQu\u00e9 ocurre si se altera la cantidad de iteraciones de manera arbitraria? La cantidad de cache misses aumenta. La cantidad de cache hits aumenta. La cantidad de cache misses se queda igual. La cantidad de cache hits se queda igual. El hit rate aumenta. El hit rate disminuye. El hit rate se mantiene constante. \u00bfPor qu\u00e9 le ocurre, lo indicado en la pregunta anterior, al hit rate? Porque se aprovecha la localidad espacial. Porque se aprovecha la localidad temporal. Porque no se aprovecha la localidad espacial. Porque no se aprovecha la localidad temporal. Porque la cantidad de repeticiones no tiene impacto en el hit rate. Nota importante para el archivo ex1.txt : Solo se debe escribir las inc\u00f3gnitas en cada fila, estas deben estar separadas por una coma, sin espacios (si la pregunta posee m\u00e1s de una respuesta). Por ejemplo: 1.blockSize,stepSize,arraySize.","title":"Escenario #2"},{"location":"labs/labCache/#ejercicio-2-ordenamiento-de-ciclos-y-multiplicacion-de-matrices","text":"Si recuerdan, las matrices son estructuras de datos bidimensionales en donde cada elemento es accedido por medio de dos \u00edndices. Para poder multiplicar dos matrices, se puede utilizar tres ciclos anidados. Asumiendo que las matrices A, B y C son de nxn y guardadas en un arreglo de una dimensi\u00f3n, en donde sus elementos est\u00e1n ubicados de manera contigua en memoria: for (int i = 0; i < n; i++) for (int j = 0; j < n; j++) for (int k = 0; k < n; k++) C[i+j*n] += A[i+k*n] * B[k+j*n]; Hecho: La multiplicaci\u00f3n de matrices se encuentran detr\u00e1s de numerosos algoritmos de \u00e1lgebra lineal y la operaci\u00f3n eficaz de ello es cr\u00edtico para muchas aplicaciones dentro de las ciencias aplicadas. N\u00f3tese que en el c\u00f3digo superior los ciclos est\u00e1n ordenados como i, j, k. Si se examina el bucle m\u00e1s \u00edntimo, se puede ver que este...: recorre B en pasos unitarios. recorre A en progresos de tama\u00f1o n. * no recorre C. RECORDAR: Para calcular la multiplicaci\u00f3n de matrices de manera correcta, no importa el orden de los ciclos . PERO , el orden elegido para acceder a los elementos de las matrices pueden tener un impacto muy grande en el rendimiento . Los caches se benefician m\u00e1s (m\u00e1s cache hits; menos misses) cuando el acceso a memoria se aprovecha de la temporalidad espacial y de la espacial, utilizando bloques ya dentro del cache. Optimizando los accesos de memoria de un programa es esencial para aprovecharse de la jerarqu\u00eda de memoria. Gu\u00eden su atenci\u00f3n a matrixMultiply.c , en este archivo se realizan varias implementaciones de la multiplicaci\u00f3n de matrices con tres ciclos anidados. Compilar y ejecutar el c\u00f3digo con el siguiente comando: make ex2 Esto realizar\u00e1 las operaciones de matrices e indicar\u00e1 la velocidad con la que cada iteraci\u00f3n complete las multiplicaciones. La unidad \"Gflops/s\" se lee como \"Giga-floating-point-operations per second\". Preguntas: 1. \u00bfQu\u00e9 ordenamiento(s) rinde(n) mejor? multMat1 multMat2 multMat3 multMat4 multMat5 multMat6 \u00bfPor qu\u00e9? Porque se aprovecha la localidad espacial. Porque se aprovecha la localidad temporal. Porque utiliza loop unrolling. Porque se realiza cache blocking. \u00bfQu\u00e9 versi\u00f3n (o versiones) muestra(n) ser la(s) m\u00e1s lenta(s)? multMat1 multMat2 multMat3 multMat4 multMat5 multMat6 \u00bfPor qu\u00e9? Porque no se aprovecha la localidad espacial. Porque no se aprovecha la localidad temporal. Porque no utiliza loop unrolling. Porque no se realiza cache blocking. \u00bfC\u00f3mo afecta la manera de recorrer las matrices, respecto del \u00edndice que se encuentra en el ciclo m\u00e1s \u00edntimo, al rendimiento? Es el que mayor impacto tiene en el rendimiento. Su impacto en el rendimiento es irrelevante. De este depende si se aprovecha la localidad temporal o no. Este influye directamente el aprovechamiento de la localidad espacial. Es igual de importante que el resto de \u00edndices. Nota importante para el archivo ex2.txt : Similar al archivo de texto del ejercicio anterior, si se requiere de m\u00e1s de una respuesta a una pregunta, estas deben de estar separadas por comas, sin espacios. Por ejemplo: 3.ii,iv.","title":"Ejercicio 2: Ordenamiento de Ciclos y Multiplicaci\u00f3n de Matrices"},{"location":"labs/labCache/#ejercicio-3-cache-blocking-y-transposicion-de-matrices","text":"","title":"Ejercicio 3: Cache Blocking y Transposici\u00f3n de Matrices"},{"location":"labs/labCache/#transposicion-de-matrices","text":"En algunas ocasiones, se requiere intercambiar las filas con las columnas de una matriz, esta operaci\u00f3n se llama una transposici\u00f3n . Una implementaci\u00f3n eficiente pude ser de gran utilidad al implementar operaciones algebraicas m\u00e1s complejas. La matriz transpuesta de A suele denotarse como A T .","title":"Transposici\u00f3n de Matrices"},{"location":"labs/labCache/#cache-blocking","text":"En el c\u00f3digo ejemplo de multiplicaci\u00f3n de matrices del ejercicio anterior se puede notar que se recorren las matrices A y B en su totalidad para calcular un \u00fanico valor para C. Por lo mismo, \u00a1constantemente se debe de acceder a valores nuevos de memoria, reusando muy poca data en con el cache! Se puede mejorar el reuso de data en los caches implementando un t\u00e9cnica llamada cache blocking. Formalmente, cache blocking es una t\u00e9cnica que busca reducir la tasa de cache misses a\u00fan m\u00e1s al explotar la temporalidad espacial y/o temporal . En el caso de la transposici\u00f3n de matrices, se considera realizarla un bloque a la vez. Notar: En la imagen superior, se transpone cada submatriz A ij de la matriz A en su posici\u00f3n final de la matriz de salida, una submatriz a la vez. Es importante entender que la transposici\u00f3n de por secciones es equivalente a hacerlo para toda la matriz. Como se opera y se termina de transponer cada submatriz una a la vez, se consodila el acceso a memoria a un espacio de memoria menor al transponer esa submatriz, aprovechando las localidades temporales (y espaciales), mejorando el rendimiento del cache, acortando el tiempo de ejecuci\u00f3n del programa. Para este laboratorio, se implementar\u00e1 una estructura de cache blocking para la transposici\u00f3n de matrices y se analizar\u00e1 su rendimiento. Su tarea es implementar esta t\u00e9cnica en la funci\u00f3n transpose_blocking() en transpose.c . NO pueden asumir que el ancho de la matriz (n) es un m\u00faltiplo del tama\u00f1o del bloque. Luego de implementar la funci\u00f3n, pueden probar el c\u00f3digo corriendo los siguientes comandos: make ex3 ./transpose <n> <blocksize> Donde n y blocksize son par\u00e1metros que ser\u00e1n especificados por el usuario. Se puede verificar el funcionamiento del c\u00f3digo eligiendo n=10000 y blocksize=33. La versi\u00f3n con blocking deber\u00eda terminar significantemente m\u00e1s r\u00e1pido. A continuaci\u00f3n, se muestra una gu\u00eda por si no saben c\u00f3mo comenzar . De lo contrario, pueden saltarse esta parte y comenzar. Algunos consejos: Pueden empezar viendo la funci\u00f3n transpose_naive . Notar que el \u00edndice y recorre TODA la matriz src de manera vertical en una iteraci\u00f3n del ciclo externo antes de ser reiniciada a cero. Es decir, x se actualiza hasta que y termine su recorrido. Este es el comportamiento que se debe corregir. Lo que se quiere es moverse a la siguiente fila de dst despu\u00e9s de recorrer el ancho (eje horizontal) de un solo bloque. \u00bfQu\u00e9 tan grande es cada bloque? El n\u00famero de enteros especificados por blocksize . Adem\u00e1s , solo se desea mover en el eje vertical (la altura) de un bloque antes de proseguir al siguiente. No se busca que x imite el comportamiento que se quiere evitar con el par\u00e1metro y . Ayuda: Una soluci\u00f3n est\u00e1ndar requiere de cuatro ciclos for . Finalmente, como no se puede asumir que n es un m\u00faltiplo de blocksize , la \u00faltima columna del bloque de cada fila ser\u00e1 m\u00e1s corta (no ser\u00e1 un cuadrado de block_size por block_size ). Adem\u00e1s, la \u00faltima fila del bloque estar\u00e1 truncada. Para arreglar este problema, se puede realizar la situaci\u00f3n general que n s\u00ed es m\u00faltiplo de block_size y agregar, como caso especial, una alternativa para lidiar con la excepci\u00f3n de que se est\u00e1 recorriendo una parte del arreglo inexistente. Cuando ya funcione el c\u00f3digo , se deben completar los siguientes ejercicios:","title":"Cache Blocking"},{"location":"labs/labCache/#alternado-los-tamanos-de-los-arreglos","text":"Fijar el tama\u00f1o del bloque a 20 y ejecutar el c\u00f3digo con las siguientes variantes de n : 50, 100, 500, 1000, 5000. \u00bfA partir de qu\u00e9 punto se puede notar una mejora en rendimiento al comparar la versi\u00f3n con cache blocking y la versi\u00f3n com\u00fan? 50 100 500 1000 5000 \u00bfPor qu\u00e9 el m\u00e9todo de cache blocking requiere que la matriz sea de cierto tama\u00f1o para que su mejora sea percibida? Porque necesita aprovechar la localidad espacial. Porque as\u00ed puede explotar la localidad temporal. Porque el tama\u00f1o de la matriz debe ser un m\u00faltiplo del tama\u00f1o del bloque. Por la Ley de Amdahl. Ninguna de las anteriores.","title":"Alternado los Tama\u00f1os de los Arreglos"},{"location":"labs/labCache/#cambiando-el-tamano-del-bloque","text":"Fijar el ancho de las matrices a 10000 y correr el c\u00f3digo con los siguientes valores para blocksize : 100, 1000, 2000, 5000, 10000. \u00bfC\u00f3mo se ve afectada la velocidad de ejecuci\u00f3n de transpose_blocking() al cambiar el tama\u00f1o del bloque? Aumenta de manera lineal. Disminuye de manera lineal. Aumenta de manera logar\u00edtmica. Disminuye de manera logar\u00edtmica. Se mantiene constante. \u00bfPor qu\u00e9 ocurre lo indicado en la respuesta anterior? Porque se aprovecha m\u00e1s el uso de los bloques si son m\u00e1s grandes. Porque se desaprovecha el uso de los bloques si su tama\u00f1o aumenta. Porque se aprovecha de la localidad espacial. Porque se aprovecha de la localidad temporal. Porque es una caracter\u00edstica intr\u00ednseca de la operaci\u00f3n realizada. Escribir las respuestas en el archivo ex3.txt . Siguiendo las directrices indicadas para los ejercicios anteriores. Es relevante notar que en los \u00faltimos dos ejercicios no fue necesario conocer los par\u00e1metros del cache de sus computadoras. Solo se exhibi\u00f3 un nivel m\u00e1s alto de localidad y se aceler\u00f3 la ejecuci\u00f3n del programa. Esto implica que todos los caches, sin importar sus par\u00e1metros espec\u00edficos, se benefician al ejecutar c\u00f3digo que se aprovecha de altos niveles de localidad.","title":"Cambiando el Tama\u00f1o del Bloque"},{"location":"labs/labCache/#calificacion","text":"Recuerden que pueden evaluar, de manera local, sus respuestas ejecutando: ./check Al terminar, deben de subir su laboratorio al calificador en l\u00ednea con: ./submit <TOKEN>","title":"Calificaci\u00f3n"},{"location":"labs/labPipeline/","text":"Lab 8 - Pipelining y preparaci\u00f3n para el CPU \u00b6 Objetivo \u00b6 Este laboratorio es bastante corto. Consiste \u00fanicamente en un ejercicio de pipelining , con el objetivo de darles suficiente tiempo para el proyecto 2, empiecen pronto... Preparaci\u00f3n \u00b6 Para este laboratorio, nuevamente, es necesario que tengan la aplicaci\u00f3n de Logisim . Adicionalmente, pueden utilizar la documentaci\u00f3n de Logisim para refrescar el conocimiento que adquirieron en los laboratorios anteriores. Tambi\u00e9n, tienen que tener todos los archivos base, estos se encuentran aqu\u00ed . Recuerden que deben aceptar la asignaci\u00f3n de GitHub Classroom y se les crear\u00e1 autom\u00e1ticamente un repositorio con una extensi\u00f3n que termina con su usuario de GitHub. Cuando ya se haya creado el repositorio, pueden ejecutar los siguientes comandos abriendo una terminal ( CTRL + T ): git clone <link del repositorio> Ejercicio 1: Pipeline \u00b6 Asuman que, al encender, todos los registros tienen 0. Consideren el siguiente FSM de 2 entradas, su salida es calculada por medio de una multiplicaci\u00f3n de sus entradas y sumada a su estado actual. Asuman que el tiempo de propagaci\u00f3n de un bloque de suma es de 50ns, el tiempo de propagaci\u00f3n de un bloque de multiplicaci\u00f3n es de 55ns, y el clk-to-q delay de un registro es de 5ns. Calculen la m\u00e1xima frecuencia del reloj en la que puede operar este circuito. Asuman que el tiempo de configuraci\u00f3n de un registro es despreciable y que las 2 entradas vienen de registros sincronizados que reciben informaci\u00f3n de fuentes externas. Ahora, deben mejorar el desempe\u00f1o de este circuito, de manera que pueda operar a una frecuencia de reloj m\u00e1s alta. Para ello, deben separar la multiplicaci\u00f3n y la suma en dos etapas de pipeline . En la primera etapa, se realiza la multiplicaci\u00f3n de las 2 entradas y, en la segunda etapa, se le suma el producto al estado actual. La forma en que se evaluar\u00e1 es muy simple: La secuencia de salidas de este circuito est\u00e1 bien, ssi corresponde a la secuencia de salidas del circuito sin pipeline , potencialmente, con algunos ceros en el principio. Por ejemplo, si el circuito da como salidas [3,5,1,2,4,...], su circuito correcto podr\u00eda devolver [0,3,5,1,2,4,...] para la misma secuencia de entradas. Para facilitar el proceso de calificaci\u00f3n, se les dar\u00e1 un punto de inicio est\u00e1ndar en los archivos del laboratorio. En pipeline.circ , el sub-circuito Non- pipelined est\u00e1 estructurado exactamente como la imagen de arriba. El main est\u00e1 programado para que la salida del subcircuito sin pipeline sea [3,5,1,2,4,-1,0,0,...]. Esto, tambi\u00e9n, los ayudar\u00e1 como ejemplo de c\u00f3mo usar una memoria con datos desde un archivo. El bloque ROM deber\u00eda tener los datos correctos, pero, si no, denle click derecho al bloque y elijan la opci\u00f3n \"Load image...\" y escogan ROMdata . Noten que necesitar\u00e1n un registro para guardar un valor intermedio entre etapas del pipeline , esto es bastante com\u00fan en pipelines. Completen el subcircuito pipelined . Tendr\u00e1n que agregar un registro entre los bloques de producto y suma para separar las dos etapas. Ahora, calculen la nueva frecuencia m\u00e1xima para la versi\u00f3n con pipeline del circuito. Cuando aprendieron de esto en clase, se les mencion\u00f3 que si un resultado depende de la salida de una instrucci\u00f3n previa, se suele agregar una \"burbuja\" en el pipeline para asegurar que el resultado de la primera instrucci\u00f3n est\u00e9 listo para ser usado en la segunda. Piensen por qu\u00e9 agregar burbujas en este ejemplo es innecesario. Calificaci\u00f3n \u00b6 Cuando crean que tengan ejercicios completos, pueden utilizar el autograder, localmente, escribiendo en la terminal: ./check Si todo esta correcto les saldr\u00e1 algo como esto: ___ __ __ / _ | __ __/ /____ ___ _______ ____/ /__ ____ / __ / // / __/ _ \\/ _ \\/ __/ _ \\/ _ / -_ ) __/ /_/ | _ \\_ ,_/ \\_ _/ \\_ __/ \\_ , /_/ \\_ ,_/ \\_ ,_/ \\_ _/_/ /___/ Machine Structures Great Ideas in Computer Architecture Lab 8 : Pipeline Exercise Grade Message ---------------- ------- --------- 1 . Pipeline 100 Passed = > Score: 100 /100 Pueden subir su laboratorio para calificaci\u00f3n utilizando: ./submit <TOKEN> Ejercicio 2: Gu\u00eda del proyecto de CPU \u00b6 Queremos incluir esta gu\u00eda para guiarlos en la tercera parte del proyecto. Aprovechen esta gu\u00eda para comenzar la parte 3 (CPU). Empezar esta parte desde cero puede ser intimidante, as\u00ed que queremos guiarlos en la forma de pensar en este proyecto con un ejemplo de instrucciones tipo R: una suma (la instrucci\u00f3n add ). Recuerden las 5 etapas de pipeline del CPU: Instruction fetch Instruction decode Execute Memory Writeback Esta gu\u00eda los ayudar\u00e1 a completar cada uno de estos pasos, de la instrucci\u00f3n add . Cada secci\u00f3n tendr\u00e1 preguntas para que analicen, detalles importantes y referencias al contenido del curso, pero no les dir\u00e1 c\u00f3mo implementarla exactamente. Tal vez necesiten leer y entender cada pregunta antes de pasar a la siguiente y podr\u00e1n ver las respuestas haciendo click a cada pregunta. Mientras implementen el proyecto, si\u00e9ntanse libres de poner cosas en subcircuitos conforme lo vean necesario. Etapa 1: Instruction fetch \u00b6 La parte principal de esta estapa es, \u00bfc\u00f3mo se obtiene la instrucci\u00f3n actual? De las clases, se sabe que las instrucciones son almacenadas en una memoria de instrucciones (texto) y cada instrucci\u00f3n se puede obtener con una direcci\u00f3n. \u00bfQu\u00e9 archivo tiene la memoria de datos? \u00bfC\u00f3mo se conecta a su archivo cpu.circ ? Est\u00e1 en el archivo riscv.circ; le da una entrada al cpu llamada Instruction y recibe una salida llamada fetch_addr . En el CPU, \u00bfc\u00f3mo afecta la direcci\u00f3n que tenemos en la salida fetch_addr a la entrada Instruction ? La instrucci\u00f3n que riscv.circ env\u00eda al CPU debe ser la instrucci\u00f3n en la posici\u00f3n fetch_addr de la memoria de texto. \u00bfC\u00f3mo sabemos qu\u00e9 valor deber\u00eda tener fetch_addr ? (pista: tambi\u00e9n se le llama PC) fetch_address es la direcci\u00f3n de la instrucci\u00f3n que actualmente est\u00e1 siendo ejecutada, as\u00ed que se guarda en el registro PC. Para este proyecto, est\u00e1 bien que PC empiece en 0, el valor por defecto de los registros. En este proyecto, \u00bfqu\u00e9 cantidad de bits tiene el PC? 32 bits. Para programas sencillos sin ning\u00fan jump o branch, \u00bfc\u00f3mo deber\u00eda cambiar el PC de l\u00ednea a l\u00ednea? El PC se debe incrementar en 1 instrucci\u00f3n para poder recibir la siguiente instrucci\u00f3n, ya que la direcci\u00f3n almacenada en el PC representa la instrucci\u00f3n a ejecutar. En los archivos del proyecto, ya est\u00e1 el PC. implementen el comportamiento del PC para programas simples (sin jumps o branches). Tendr\u00e1n que agregar esto m\u00e1s adelante, pero por ahora s\u00f3lo piensen en ejecutar un programa con add . Piensen a d\u00f3nde debe estar conectada la salida del PC. \u00a1No se olviden de conectar el clock! Etapa 2: Instruction decode \u00b6 Ya que tienen la instucci\u00f3n en el tunnel Instruction , deben separarla en el paso de decodificaci\u00f3n de acuerdo a lo que han aprendido en clase acerca de formatos de instrucciones de Risc-V. \u00bfQu\u00e9 tipo de instrucci\u00f3n es add ? \u00bfCu\u00e1les son sus diferentes campos y qu\u00e9 bits se necesitan para cada uno? (Vean las instrucciones del proyecto :D) En Logisim, \u00bfqu\u00e9 se utiliza para separar (split out) diferentes grupos de bits? \u00a1Un splitter! Implementen la etapa de decodificaci\u00f3n de los campos de la instrucci\u00f3n usando la entrada instruction . Deber\u00edan usar tunnels para etiquetar y agrupar los bits. Ahora deben obtener datos de los registros correspondientes usando el register file . \u00bfQu\u00e9 campos de bits deben estar conectados al register file ? \u00bfA qu\u00e9 entradas del register file deber\u00edan conectarse? Los campos rs1 y rs2 deben ir a Read register 1 y 2. Implementen la forma de leer del register file . Van a tener que usar su regfile.circ de la parte 1 (seguro ya la tienen hecha :), si no, ya van un poco tarde). \u00a1No se olviden de conectar el clock! Etapa 3: Execute \u00b6 Esta etapa, tambi\u00e9n conocida como ALU stage , es la etapa en la cual se computan la mayor\u00eda de instrucciones. Aqu\u00ed se introducir\u00e1 la idea de implementar un m\u00f3dulo de control . Para la instrucci\u00f3n add , \u00bfcu\u00e1les deber\u00edan ser las entradas del ALU? Read Data 1 y 2 deben ir a los puertos A y B del ALU En el ALU, \u00bfcu\u00e1l es el prop\u00f3sito del switch llamado ALU_ctr ? Elige la operaci\u00f3n que el ALU debe realizar. Aunque para un add es posible poner un valor constante en el control del ALU, \u00bfpor qu\u00e9 ser\u00eda malo hacer esto conforme siguen implementando m\u00e1s instrucciones del proyecto? En otras instrucciones, las entradas del ALU pueden cambiar, por lo que es necesario alg\u00fan tipo de (sub)circuito que cambie los valores de entrada y/o salida, dependiendo de la instrucci\u00f3n siendo ejecutada. Ahora implementen un subcircuito para el m\u00f3dulo de control. Este m\u00f3dulo debe recibir como entradas el opcode y funct y, como salidas, los valores adecuados para el manejo correcto del ALU para cada instrucci\u00f3n. Hay varias formar de lograr esto (pueden ver el instructivo del proyecto para m\u00e1s ayuda). Al implementar m\u00e1s instrucciones, este m\u00f3dulo puede hacerce m\u00e1s complejo. Utilicen el ALU de la parte anterior y con\u00e9ctenlo correctamente. \u00bfEs necesario conectar el clock? \u00bfPor qu\u00e9, o por qu\u00e9 no? Etapa 4: Memory \u00b6 En esta etapa se pueden almacenar datos a una memoria con instrucciones \"store\", y recuperar datos con instrucciones de \"load\". Como add no utiliza la memoria, la gu\u00eda no se enfocar\u00e1 mucho en esta etapa. Vean el m\u00f3dulo de memoria en el proyecto. En este punto no se explicar\u00e1 lo que debe tener en cada una de sus entradas, pero si\u00e9ntanse libres de implementarlo por su cuenta cuando aprendan qu\u00e9 hacer. Pueden conectarle el clock mientras tanto. Etapa 5: Write back \u00b6 La estapa de escritura es donde el resultado de la operaci\u00f3n se guarda de regreso a los registros. Aunque no todas las instrucciones escriben de regreso a los registros (piensen en cuales), add si lo hace. Viendo el ISA, \u00bfqu\u00e9 instrucciones s\u00ed usan esta etapa? add recibe un dato del ALU y lo guarda en un registro. lw recibe un dato de la memoria y lo escribe en un registro. Hay muchas instrucciones m\u00e1s que hacen esto. Implementen la etapa de escritura de modo que sea capaz de obtener datos, tanto del ALU como de la memoria, y escribirlos al Register File. Luego, cuando implementen saltos/branches, tal vez tengan que agregar m\u00e1s cosas a este MUX. Sin embargo, por el momento, deben poder escoger entre el ALU y la memoria, ya que s\u00f3lo una salida puede llegar al m\u00f3dulo de registros. Conecten un cable de las salidas del ALU y MEM hacia un multiplexor. \u00bfQu\u00e9 deber\u00eda tener el selector del mux? \u00bfDe qu\u00e9 depende esta entrada? El selector escoge qu\u00e9 salida (ALU o MEM) llega al Reg. File y la salida correcta depende de qu\u00e9 instrucci\u00f3n est\u00e1 ejecut\u00e1ndose. Esto sugiere que la entrada del selector deber\u00eda venir del m\u00f3dulo de control, porque el control se encarga de descifrar qu\u00e9 instrucci\u00f3n se ejecuta (con el opcode y las funct). Ahora viene el segundo (y posiblemente m\u00e1s importante) rol de los m\u00f3dulos de control: determinar qu\u00e9 valores salen del m\u00f3dulo al CPU, para poder controlar el flujo de ejecuci\u00f3n. A esto se le llaman Se\u00f1ales de Control. Un ejemplo de estas es la se\u00f1al que controla el MUX mencionado anteriormente, com\u00fanmente llamado WBsel. WBsel determina el valor que se escribe de regreso a los registros. Hay m\u00e1s se\u00f1ales de control que pueden encontrar en el material de la clase y van a tener que definir algunas m\u00e1s. Si notan que van a necesitar un mux en alguna parte del proyecto, muy posiblemente van a tener que definir una se\u00f1al de control para el mux. Hay varias formas de implementar el control para que traduzca los opcodes/functs a la instrucci\u00f3n correspondiente y luego configurar las se\u00f1ales de control correctamente. Una forma (vista en clase) es con una ROM. Los otros m\u00e9todos usan l\u00f3gica de and s y or s para alcanzar el objetivo. Prueben implementar las se\u00f1ales de control pertinentes a la instrucci\u00f3n add . Ya que tienen las entradas del mux, necesitan conectar la salida. \u00bfA d\u00f3nde va la salida? Como el output son los datos que quieren escribir al register file, deber\u00eda conectarse a la entrada Write Data del Register File Hay dos entradas m\u00e1s al Register File que son importantes para escribir datos: RegWEn y Write Register. Uno de estos viene de la etapa de decodificaci\u00f3n y, para el otro, deber\u00e1n hacer una nueva se\u00f1al de control. Terminen la etapa de Write Back conectando del m\u00f3dulo de control, y de la etapa de decodificaci\u00f3n, las entradas correspondientes al register file. Si han hecho todos estos pasos correctamente, deber\u00edan tener un procesador que funciona para sumar. Para el resto del proyecto, van a estar implementando m\u00e1s instrucciones de la misma forma; conectando salidas a entradas, agregando muxes y otros componentes de Logisim y definiendo se\u00f1ales de control nuevas. Deber\u00eda ser m\u00e1s f\u00e1cil ahora que tienen un esqueleto b\u00e1sico para trabajar. Recuerden el contenido del curso ya tienen bastante informaci\u00f3n y los ayudar\u00e1 a seguir construyendo los circuitos que tienen ahora. \u00a1\u00c9xitos!","title":"Lab 8 - Pipelining y preparaci\u00f3n para el CPU"},{"location":"labs/labPipeline/#lab-8-pipelining-y-preparacion-para-el-cpu","text":"","title":"Lab 8 - Pipelining y preparaci\u00f3n para el CPU"},{"location":"labs/labPipeline/#objetivo","text":"Este laboratorio es bastante corto. Consiste \u00fanicamente en un ejercicio de pipelining , con el objetivo de darles suficiente tiempo para el proyecto 2, empiecen pronto...","title":"Objetivo"},{"location":"labs/labPipeline/#preparacion","text":"Para este laboratorio, nuevamente, es necesario que tengan la aplicaci\u00f3n de Logisim . Adicionalmente, pueden utilizar la documentaci\u00f3n de Logisim para refrescar el conocimiento que adquirieron en los laboratorios anteriores. Tambi\u00e9n, tienen que tener todos los archivos base, estos se encuentran aqu\u00ed . Recuerden que deben aceptar la asignaci\u00f3n de GitHub Classroom y se les crear\u00e1 autom\u00e1ticamente un repositorio con una extensi\u00f3n que termina con su usuario de GitHub. Cuando ya se haya creado el repositorio, pueden ejecutar los siguientes comandos abriendo una terminal ( CTRL + T ): git clone <link del repositorio>","title":"Preparaci\u00f3n"},{"location":"labs/labPipeline/#ejercicio-1-pipeline","text":"Asuman que, al encender, todos los registros tienen 0. Consideren el siguiente FSM de 2 entradas, su salida es calculada por medio de una multiplicaci\u00f3n de sus entradas y sumada a su estado actual. Asuman que el tiempo de propagaci\u00f3n de un bloque de suma es de 50ns, el tiempo de propagaci\u00f3n de un bloque de multiplicaci\u00f3n es de 55ns, y el clk-to-q delay de un registro es de 5ns. Calculen la m\u00e1xima frecuencia del reloj en la que puede operar este circuito. Asuman que el tiempo de configuraci\u00f3n de un registro es despreciable y que las 2 entradas vienen de registros sincronizados que reciben informaci\u00f3n de fuentes externas. Ahora, deben mejorar el desempe\u00f1o de este circuito, de manera que pueda operar a una frecuencia de reloj m\u00e1s alta. Para ello, deben separar la multiplicaci\u00f3n y la suma en dos etapas de pipeline . En la primera etapa, se realiza la multiplicaci\u00f3n de las 2 entradas y, en la segunda etapa, se le suma el producto al estado actual. La forma en que se evaluar\u00e1 es muy simple: La secuencia de salidas de este circuito est\u00e1 bien, ssi corresponde a la secuencia de salidas del circuito sin pipeline , potencialmente, con algunos ceros en el principio. Por ejemplo, si el circuito da como salidas [3,5,1,2,4,...], su circuito correcto podr\u00eda devolver [0,3,5,1,2,4,...] para la misma secuencia de entradas. Para facilitar el proceso de calificaci\u00f3n, se les dar\u00e1 un punto de inicio est\u00e1ndar en los archivos del laboratorio. En pipeline.circ , el sub-circuito Non- pipelined est\u00e1 estructurado exactamente como la imagen de arriba. El main est\u00e1 programado para que la salida del subcircuito sin pipeline sea [3,5,1,2,4,-1,0,0,...]. Esto, tambi\u00e9n, los ayudar\u00e1 como ejemplo de c\u00f3mo usar una memoria con datos desde un archivo. El bloque ROM deber\u00eda tener los datos correctos, pero, si no, denle click derecho al bloque y elijan la opci\u00f3n \"Load image...\" y escogan ROMdata . Noten que necesitar\u00e1n un registro para guardar un valor intermedio entre etapas del pipeline , esto es bastante com\u00fan en pipelines. Completen el subcircuito pipelined . Tendr\u00e1n que agregar un registro entre los bloques de producto y suma para separar las dos etapas. Ahora, calculen la nueva frecuencia m\u00e1xima para la versi\u00f3n con pipeline del circuito. Cuando aprendieron de esto en clase, se les mencion\u00f3 que si un resultado depende de la salida de una instrucci\u00f3n previa, se suele agregar una \"burbuja\" en el pipeline para asegurar que el resultado de la primera instrucci\u00f3n est\u00e9 listo para ser usado en la segunda. Piensen por qu\u00e9 agregar burbujas en este ejemplo es innecesario.","title":"Ejercicio 1: Pipeline"},{"location":"labs/labPipeline/#calificacion","text":"Cuando crean que tengan ejercicios completos, pueden utilizar el autograder, localmente, escribiendo en la terminal: ./check Si todo esta correcto les saldr\u00e1 algo como esto: ___ __ __ / _ | __ __/ /____ ___ _______ ____/ /__ ____ / __ / // / __/ _ \\/ _ \\/ __/ _ \\/ _ / -_ ) __/ /_/ | _ \\_ ,_/ \\_ _/ \\_ __/ \\_ , /_/ \\_ ,_/ \\_ ,_/ \\_ _/_/ /___/ Machine Structures Great Ideas in Computer Architecture Lab 8 : Pipeline Exercise Grade Message ---------------- ------- --------- 1 . Pipeline 100 Passed = > Score: 100 /100 Pueden subir su laboratorio para calificaci\u00f3n utilizando: ./submit <TOKEN>","title":"Calificaci\u00f3n"},{"location":"labs/labPipeline/#ejercicio-2-guia-del-proyecto-de-cpu","text":"Queremos incluir esta gu\u00eda para guiarlos en la tercera parte del proyecto. Aprovechen esta gu\u00eda para comenzar la parte 3 (CPU). Empezar esta parte desde cero puede ser intimidante, as\u00ed que queremos guiarlos en la forma de pensar en este proyecto con un ejemplo de instrucciones tipo R: una suma (la instrucci\u00f3n add ). Recuerden las 5 etapas de pipeline del CPU: Instruction fetch Instruction decode Execute Memory Writeback Esta gu\u00eda los ayudar\u00e1 a completar cada uno de estos pasos, de la instrucci\u00f3n add . Cada secci\u00f3n tendr\u00e1 preguntas para que analicen, detalles importantes y referencias al contenido del curso, pero no les dir\u00e1 c\u00f3mo implementarla exactamente. Tal vez necesiten leer y entender cada pregunta antes de pasar a la siguiente y podr\u00e1n ver las respuestas haciendo click a cada pregunta. Mientras implementen el proyecto, si\u00e9ntanse libres de poner cosas en subcircuitos conforme lo vean necesario.","title":"Ejercicio 2: Gu\u00eda del proyecto de CPU"},{"location":"labs/labPipeline/#etapa-1-instruction-fetch","text":"La parte principal de esta estapa es, \u00bfc\u00f3mo se obtiene la instrucci\u00f3n actual? De las clases, se sabe que las instrucciones son almacenadas en una memoria de instrucciones (texto) y cada instrucci\u00f3n se puede obtener con una direcci\u00f3n. \u00bfQu\u00e9 archivo tiene la memoria de datos? \u00bfC\u00f3mo se conecta a su archivo cpu.circ ? Est\u00e1 en el archivo riscv.circ; le da una entrada al cpu llamada Instruction y recibe una salida llamada fetch_addr . En el CPU, \u00bfc\u00f3mo afecta la direcci\u00f3n que tenemos en la salida fetch_addr a la entrada Instruction ? La instrucci\u00f3n que riscv.circ env\u00eda al CPU debe ser la instrucci\u00f3n en la posici\u00f3n fetch_addr de la memoria de texto. \u00bfC\u00f3mo sabemos qu\u00e9 valor deber\u00eda tener fetch_addr ? (pista: tambi\u00e9n se le llama PC) fetch_address es la direcci\u00f3n de la instrucci\u00f3n que actualmente est\u00e1 siendo ejecutada, as\u00ed que se guarda en el registro PC. Para este proyecto, est\u00e1 bien que PC empiece en 0, el valor por defecto de los registros. En este proyecto, \u00bfqu\u00e9 cantidad de bits tiene el PC? 32 bits. Para programas sencillos sin ning\u00fan jump o branch, \u00bfc\u00f3mo deber\u00eda cambiar el PC de l\u00ednea a l\u00ednea? El PC se debe incrementar en 1 instrucci\u00f3n para poder recibir la siguiente instrucci\u00f3n, ya que la direcci\u00f3n almacenada en el PC representa la instrucci\u00f3n a ejecutar. En los archivos del proyecto, ya est\u00e1 el PC. implementen el comportamiento del PC para programas simples (sin jumps o branches). Tendr\u00e1n que agregar esto m\u00e1s adelante, pero por ahora s\u00f3lo piensen en ejecutar un programa con add . Piensen a d\u00f3nde debe estar conectada la salida del PC. \u00a1No se olviden de conectar el clock!","title":"Etapa 1: Instruction fetch"},{"location":"labs/labPipeline/#etapa-2-instruction-decode","text":"Ya que tienen la instucci\u00f3n en el tunnel Instruction , deben separarla en el paso de decodificaci\u00f3n de acuerdo a lo que han aprendido en clase acerca de formatos de instrucciones de Risc-V. \u00bfQu\u00e9 tipo de instrucci\u00f3n es add ? \u00bfCu\u00e1les son sus diferentes campos y qu\u00e9 bits se necesitan para cada uno? (Vean las instrucciones del proyecto :D) En Logisim, \u00bfqu\u00e9 se utiliza para separar (split out) diferentes grupos de bits? \u00a1Un splitter! Implementen la etapa de decodificaci\u00f3n de los campos de la instrucci\u00f3n usando la entrada instruction . Deber\u00edan usar tunnels para etiquetar y agrupar los bits. Ahora deben obtener datos de los registros correspondientes usando el register file . \u00bfQu\u00e9 campos de bits deben estar conectados al register file ? \u00bfA qu\u00e9 entradas del register file deber\u00edan conectarse? Los campos rs1 y rs2 deben ir a Read register 1 y 2. Implementen la forma de leer del register file . Van a tener que usar su regfile.circ de la parte 1 (seguro ya la tienen hecha :), si no, ya van un poco tarde). \u00a1No se olviden de conectar el clock!","title":"Etapa 2: Instruction decode"},{"location":"labs/labPipeline/#etapa-3-execute","text":"Esta etapa, tambi\u00e9n conocida como ALU stage , es la etapa en la cual se computan la mayor\u00eda de instrucciones. Aqu\u00ed se introducir\u00e1 la idea de implementar un m\u00f3dulo de control . Para la instrucci\u00f3n add , \u00bfcu\u00e1les deber\u00edan ser las entradas del ALU? Read Data 1 y 2 deben ir a los puertos A y B del ALU En el ALU, \u00bfcu\u00e1l es el prop\u00f3sito del switch llamado ALU_ctr ? Elige la operaci\u00f3n que el ALU debe realizar. Aunque para un add es posible poner un valor constante en el control del ALU, \u00bfpor qu\u00e9 ser\u00eda malo hacer esto conforme siguen implementando m\u00e1s instrucciones del proyecto? En otras instrucciones, las entradas del ALU pueden cambiar, por lo que es necesario alg\u00fan tipo de (sub)circuito que cambie los valores de entrada y/o salida, dependiendo de la instrucci\u00f3n siendo ejecutada. Ahora implementen un subcircuito para el m\u00f3dulo de control. Este m\u00f3dulo debe recibir como entradas el opcode y funct y, como salidas, los valores adecuados para el manejo correcto del ALU para cada instrucci\u00f3n. Hay varias formar de lograr esto (pueden ver el instructivo del proyecto para m\u00e1s ayuda). Al implementar m\u00e1s instrucciones, este m\u00f3dulo puede hacerce m\u00e1s complejo. Utilicen el ALU de la parte anterior y con\u00e9ctenlo correctamente. \u00bfEs necesario conectar el clock? \u00bfPor qu\u00e9, o por qu\u00e9 no?","title":"Etapa 3: Execute"},{"location":"labs/labPipeline/#etapa-4-memory","text":"En esta etapa se pueden almacenar datos a una memoria con instrucciones \"store\", y recuperar datos con instrucciones de \"load\". Como add no utiliza la memoria, la gu\u00eda no se enfocar\u00e1 mucho en esta etapa. Vean el m\u00f3dulo de memoria en el proyecto. En este punto no se explicar\u00e1 lo que debe tener en cada una de sus entradas, pero si\u00e9ntanse libres de implementarlo por su cuenta cuando aprendan qu\u00e9 hacer. Pueden conectarle el clock mientras tanto.","title":"Etapa 4: Memory"},{"location":"labs/labPipeline/#etapa-5-write-back","text":"La estapa de escritura es donde el resultado de la operaci\u00f3n se guarda de regreso a los registros. Aunque no todas las instrucciones escriben de regreso a los registros (piensen en cuales), add si lo hace. Viendo el ISA, \u00bfqu\u00e9 instrucciones s\u00ed usan esta etapa? add recibe un dato del ALU y lo guarda en un registro. lw recibe un dato de la memoria y lo escribe en un registro. Hay muchas instrucciones m\u00e1s que hacen esto. Implementen la etapa de escritura de modo que sea capaz de obtener datos, tanto del ALU como de la memoria, y escribirlos al Register File. Luego, cuando implementen saltos/branches, tal vez tengan que agregar m\u00e1s cosas a este MUX. Sin embargo, por el momento, deben poder escoger entre el ALU y la memoria, ya que s\u00f3lo una salida puede llegar al m\u00f3dulo de registros. Conecten un cable de las salidas del ALU y MEM hacia un multiplexor. \u00bfQu\u00e9 deber\u00eda tener el selector del mux? \u00bfDe qu\u00e9 depende esta entrada? El selector escoge qu\u00e9 salida (ALU o MEM) llega al Reg. File y la salida correcta depende de qu\u00e9 instrucci\u00f3n est\u00e1 ejecut\u00e1ndose. Esto sugiere que la entrada del selector deber\u00eda venir del m\u00f3dulo de control, porque el control se encarga de descifrar qu\u00e9 instrucci\u00f3n se ejecuta (con el opcode y las funct). Ahora viene el segundo (y posiblemente m\u00e1s importante) rol de los m\u00f3dulos de control: determinar qu\u00e9 valores salen del m\u00f3dulo al CPU, para poder controlar el flujo de ejecuci\u00f3n. A esto se le llaman Se\u00f1ales de Control. Un ejemplo de estas es la se\u00f1al que controla el MUX mencionado anteriormente, com\u00fanmente llamado WBsel. WBsel determina el valor que se escribe de regreso a los registros. Hay m\u00e1s se\u00f1ales de control que pueden encontrar en el material de la clase y van a tener que definir algunas m\u00e1s. Si notan que van a necesitar un mux en alguna parte del proyecto, muy posiblemente van a tener que definir una se\u00f1al de control para el mux. Hay varias formas de implementar el control para que traduzca los opcodes/functs a la instrucci\u00f3n correspondiente y luego configurar las se\u00f1ales de control correctamente. Una forma (vista en clase) es con una ROM. Los otros m\u00e9todos usan l\u00f3gica de and s y or s para alcanzar el objetivo. Prueben implementar las se\u00f1ales de control pertinentes a la instrucci\u00f3n add . Ya que tienen las entradas del mux, necesitan conectar la salida. \u00bfA d\u00f3nde va la salida? Como el output son los datos que quieren escribir al register file, deber\u00eda conectarse a la entrada Write Data del Register File Hay dos entradas m\u00e1s al Register File que son importantes para escribir datos: RegWEn y Write Register. Uno de estos viene de la etapa de decodificaci\u00f3n y, para el otro, deber\u00e1n hacer una nueva se\u00f1al de control. Terminen la etapa de Write Back conectando del m\u00f3dulo de control, y de la etapa de decodificaci\u00f3n, las entradas correspondientes al register file. Si han hecho todos estos pasos correctamente, deber\u00edan tener un procesador que funciona para sumar. Para el resto del proyecto, van a estar implementando m\u00e1s instrucciones de la misma forma; conectando salidas a entradas, agregando muxes y otros componentes de Logisim y definiendo se\u00f1ales de control nuevas. Deber\u00eda ser m\u00e1s f\u00e1cil ahora que tienen un esqueleto b\u00e1sico para trabajar. Recuerden el contenido del curso ya tienen bastante informaci\u00f3n y los ayudar\u00e1 a seguir construyendo los circuitos que tienen ahora. \u00a1\u00c9xitos!","title":"Etapa 5: Write back"},{"location":"labs/labSpark/","text":"Lab 12 - MapReduce y Spark \u00b6 Objetivos \u00b6 Obtener experiencia ejecutando MapReduce y conseguir un conocimiento m\u00e1s profundo del paradigma MapReduce. Familiarizarse con Apache Spark y conseguir experiencia con Spark en una instalaci\u00f3n local. Aprender a aplicar el paradigma MapReduce a Spark implementando ciertos algoritmos en Spark. Preparaci\u00f3n \u00b6 Tienen que tener todos los archivos base, estos se encuentran aqu\u00ed . Recuerden que tienen que aprovechar el uso de Git y subir el link de su repositorio al GES, as\u00ed como al autograder, de lo contrario su nota ser\u00e1 de 0 . Por favor revisen la secci\u00f3n de calificaci\u00f3n para conocer el l\u00edmite de submits que tienen . Cuando ya se haya creado el repositorio, pueden ejecutar los siguientes comandos abriendo una terminal ( CTRL + T ): git clone <link del repositorio> Tambi\u00e9n, tienen que instalar el entorno de Python para este laboratorio. Para hacer esto, ejecuten lo siguiente: conda env create -f environment.yml Respondan al mensaje de instalar paquetes con \"y\" (sin comillas). Despu\u00e9s de la instalaci\u00f3n, corran el siguiente comando para activar el entorno virtual: conda activate lab12 Cuando hayan terminado con el laboratorio pueden desactivar el entorno con: conda deactivate Introducci\u00f3n \u00b6 En clase los hemos expuesto a cluster computing (en particular, al framework MapReduce), como funciona y se ejecuta, pero ahora es tiempo de que ganen experiencia corriendo programas utilizando estos frameworks. En este laboratorio los vamos a introducir a Spark para que practiquen escribiendo rutinas de Map y Reduce. Este framework tiene su propia p\u00e1gina en linea, as\u00ed que son libres de probar instalarlo localmente en sus computadoras personales, de todas formas es m\u00e1s f\u00e1cil utilizar la m\u00e1quina virtual que les proporcionamos para completar este laboratorio. Aseg\u00farense de entender bien el framework de Spark, ya que lo vamos a estar utilizando en el \u00faltimo proyecto del curso. Variables Globales \u00b6 Cuando est\u00e9n utilizando Spark o un framework de cluster computing, no utilicen variables globales. Esto mata el prop\u00f3sito de tener m\u00faltiples tareas corriendo en paralelo y crea cuellos de botella cuando m\u00faltiples tareas tratan de acceder a la misma variable global. Como resultado, muchos algoritmos son implementados sin el uso de variables globales. En Spark pueden hacer uso de variables broadcast , sin embargo, no las vamos a necesitar en este laboratorio. Como correr Spark \u00b6 Para este laboratorio y en el proyecto les vamos a dar un archivo que les va a ayudar a correr los archivos de Spark, pero cuando ustedes utilicen Spark afuera de la clase (que deber\u00edan), van a necesitar saber como correr Spark en la l\u00ednea de comandos. Para poder correr un archivo de Spark foo.py (similar a como ustedes corren un programa de Python foo.py ) solo utilicen el siguiente comando: spark-submit foo.py # corre el archivo de spark foo.py Si su archivo de Spark necesita argumentos (as\u00ed como los archivos del laboratorio), el comando va a ser similar, pero ustedes van a pasar tantos argumentos como necesiten, as\u00ed: spark-submit foo.py arg1 arg2 # pasa los argumentos arg1 y arg2 a foo.py Spark tambi\u00e9n incluye un int\u00e9rprete que corre con la versi\u00f3n de Python que tengan instalada, y los va a dejar probar cualquier comando de Spark en el int\u00e9rprete. El int\u00e9rprete tambi\u00e9n puede recibir archivos (pasen los archivos con la bandera --py-files). Si est\u00e1n buscando solo correr el int\u00e9rprete, el comando es el siguiente: pyspark Si quieren pre-cargar unos archivos (digamos a.py, b.py y c.py) pueden correr el siguiente comando: pyspark --py-files a.py, b.py, c.py Tips r\u00e1pidos de Depuraci\u00f3n \u00b6 Si alguna vez se encuentran pregunt\u00e1ndose porqu\u00e9 su salida es extra\u00f1a o algo est\u00e1 mal cuando corren sus archivos de Spark, recuerden los siguientes tips: Aseg\u00farense de utilizar la funci\u00f3n de acci\u00f3n take . La funci\u00f3n take puede ser utilizada sobre cualquier objeto RDD (as\u00ed que pr\u00e1cticamente cualquier objeto que ustedes quieran paralelizar). Esta funci\u00f3n toma un argumento N , que es un entero y va a retornar los primeros N elementos dentro de su objeto RDD. Tambi\u00e9n pueden probar sus funciones (map, reduce, etc) adentro del int\u00e9rprete de Spark (pyspark, mencionado arriba). Simplemente importen la funci\u00f3n que quieren probar en pyspark (explicado arriba) y van a ser capaces de correr la funci\u00f3n y verificar que la salida es la que ustedes esperan. Aqu\u00ed hay un peque\u00f1o ejemplo de wordcount.py : pyspark --py-files wordcount.py # corre el interprete de spark con el archivo wordcount.py >>> from wordcount import flat_map # importa la funcion que quieren probar, flat_map, en este caso >>> file = sc.sequenceFile ( \"data/billOfRights.txt.seq\" ) # carga el archivo sequencial billOfRights.txt.seq >>> file.take ( 5 ) # retorna los primeros 5 elementos del RDD file [( <doc_name_1>, <text 1 > ) , ( <doc_name_2>, <text 2 > ) , ..., ( <doc_name_5>, <text 5 > )] >>> flat_map_output = file.flatMap ( flat_map ) # corre la funcion importada flat_map sobre file >>> flat_map_output.take ( 5 ) # retorna las primeras 5 palabras en el documento. [ 'Amendment' , 'I' , 'Congress' , 'shall' , 'make' ] Documentaci\u00f3n y Otros Recursos \u00b6 Una gu\u00eda r\u00e1pida de programaci\u00f3n en Spark (hagan click en la pesta\u00f1a de Python para ver el c\u00f3digo de Python) est\u00e1 disponile aqu\u00ed . Aqu\u00ed hay un link a la documentaci\u00f3n de la API. Para este laboratorio, no necesitan navegar mucho en ella, pero tomen un tiempo para verla cuando est\u00e9n haciendo el proyecto. Python \u00b6 Talvez algunos ya est\u00e9n familiarizados con Python ya que ha ganado popularidad en los \u00faltimos a\u00f1os (es el lenguaje m\u00e1s utilizado en universidades para cursos introductorios de programaci\u00f3n), adem\u00e1s siempre est\u00e1 en las primeras posiciones de los lenguajes de programaci\u00f3n m\u00e1s usados donde reposan los grandes como C y no hay que olvidar que es el scripting language por excelencia que utilizan compa\u00f1ias como Google, Facebook, etc. Se preguntar\u00e1n \u00bfpor qu\u00e9 aprender Python? adem\u00e1s de ser una nueva herramienta en su toolbox de conocimientos, es un lenguaje flexible, r\u00e1pido a pesar de ser interpretado y con dynamic typing (obvio no se compara con uno compilado y con static typing). Antes de empezar este laboratorio, asumimos que ya leyeron el tutorial de Python que se les proporciona en el siguiente link , es imperativo que lean el tutorial, en otros a\u00f1os han tratado de saltarse este paso y el resultado no es muy bueno, LEAN EL TUTORIAL . Ejercicio 1: Grafos Dirigidos (Warm-Up) \u00b6 Este ejercicio no tiene nada que ver con MapReduce, pero les servir\u00e1 para practicar sus habilidades de Python. Tienen que implementar el m\u00e9todo path de la clase DirectedGraph , el constructor de esta clase recibe de par\u00e1metro una matriz de booleans, la cual representar\u00e1 la matriz de adyacencias de un grafo dirigido. Los estados iran del 0, hasta length - 1 de la matriz. El m\u00e9todo path(self, start, end) devuelve una lista de Python con el camino m\u00e1s corto desde el estado start al estado end , el resultado (los elementos de la lista) debe contener los estados por los que se deben de pasar incluyendo el estado start (el inicio) y end (el final). Si nuestro grafo G fuera el siguiente: y quisieramos el camino m\u00e1s corto del estado 2 a los dem\u00e1s estados, obtendriamos el siguiente resultado: from state: 2 to state: 0 = shortest path: 2 -> 0, distance: 1 to state: 1 = shortest path: 2 -> 0 -> 1, distance: 2 to state: 3 = shortest path: 2 -> 3, distance: 1 to state: 4 = shortest path: 2 -> 3 -> 4, distance: 2 to state: 5 = shortest path: 2 -> 3 -> 5, distance: 2 to state: 6 = shortest path: 2 -> 3 -> 4 -> 6, distance: 3 to state: 7 = shortest path: 2 -> 3 -> 5 -> 7, distance: 3 Para este ejercicio les recomendamos utilizar Breadth-first search (BFS), para los que no se recuerdan aqu\u00ed hay una variante que solo toma en cuenta el arreglo de predecesores $\\pi$ (\u00bfPor qu\u00e9 solo predecesores?): BFS ( G , s ) { for each vertex u \u2208 V [ G ] \u2013 { s } { visited [ u ] = false \u03c0 [ u ] = null } visited [ s ] = true \u03c0 [ s ] = null Q = [ s ] while ( Q != \u2205 ) { u = Q . dequeue () for each v \u2208 Adj [ u ] { if not visited [ v ] { visited [ v ] = true \u03c0 [ v ] = u Q . enqueue ( v ) } } } return \u03c0 } Pueden probar su implementaci\u00f3n utilizando el siguiente comando: make graph Esto probar\u00e1 su implementaci\u00f3n con el grafo que se muestra en la figura de arriba, de esta manera pueden saber si el resultado que obtienen es el correcto. Ejemplo: Ejecutando un contador de palabras \u00b6 En este ejemplo vamos a ejecutar el hola mundo de MapReduce que es un contador de palabras. Pueden probarlo con: make sparkwc-small Esto ejecutar\u00e1 wordcount.py con billOfRights.txt.seq . El resultado deber\u00eda estar en wc-out-wordcount-small/part-00000 . Una caracter\u00edstica interesante de Spark es que es un motor de c\u00f3mputo distribuido en memoria, asi que no tiene un almacenamiento de archivos predeterminado. Por ello, utilizamos el Hadoop Distributed File System (HDFS) para poder guardar el resultado. Los exhortamos a leer acerca de Hadoop por su cuenta. en general, Hadoop requiere que el directorio de salida no exista al ejecutar un programa de MapReduce, pero el makefile se encarga de esto, removiendo el directorio de salida anterior. Traten con el archivo m\u00e1s grande, complete-works-mark-twain.txt.seq : make sparkwc-medium Su salida para este comando estar en el directorio spark-wc-out-wordcount-medium . Busquen en el archivo alguna palabra como \"the\" para entender mejor la salida. Tomen un tiempo para ver y analizar wordcount.py , traten de entender lo que est\u00e1 haciendo el c\u00f3digo les va a servir para el siguiente ejercicio del laboratorio. Ejercicio 2: Document Word Count \u00b6 Abran docwordcount.py . Noten que tiene casi el mismo c\u00f3digo que wordcount.py , que acaban de probar. Modif\u00edquenlo para contar la cantidad de documentos que contienen cada palabra en lugar de la cantidad de veces que aparece una palabra en la entrada. Para ayudarlos a entender el c\u00f3digo, hemos agregado varios comentarios, pero si\u00e9ntanse libres de revisar las transformaciones y acciones en la p\u00e1gina de Spark para una explicaci\u00f3n m\u00e1s detallada de algunos m\u00e9todos que pueden usarse en Spark. En esta parte, les ser\u00e1 \u00fatil revisar los links de transformaciones y acciones de arriba, ya que hay m\u00e9todos que pueden usar para ayudarlos a ordenar una salida o remover items duplicados. Para ayudarlos a distinguir cu\u00e1ndo aparece una palabra en un documento, tal vez quieran hacer uso del document_id tambi\u00e9n -- esto se menciona en los comentarios de flat_map() . Finalmente, aseg\u00farense de ordenar en orden alfab\u00e9tico el resultado final. (pista: \u00bfHabr\u00e1 alguna otra transformaci\u00f3n que puedan usar?) Pueden probar docwordcount.py usando cualquiera de estos dos comandos (para los 2 datasets): make sparkdwc-small # Output in spark-wc-out-docwordcount-small/ O make sparkdwc-medium # Output in spark-wc-out-docwordcount-medium/ Ejercicio 3: Full Text Index Creation \u00b6 Abran index.py . Noten que el c\u00f3digo es similar a docwordcount.py . Modif\u00edquenlo para desplegar cada palabra y una lista de ocurrencias (identificador de documento, seguido del \u00edndice de CADA vez que la palabra est\u00e9 en ese documento). Aseg\u00farense de que los \u00edndices empiecen con cero. La salida tendr\u00eda que tener lineas que se vean como lo siguiente: (word1 document1-id, word# word# ...) (word1 document2-id, word# word# ...) . . . (word2 document1-id, word# word# ...) (word2 document3-id, word# word# ...) . . . Noten que hay una linea para CADA documento en el que la palabra aparezca y CADA par de palabra y documento debe tener solo UNA lista de \u00edndices. Recuerden que tambi\u00e9n necesitan desplegar el document ID . Para este ejercicio, tal vez no necesiten todas las funciones definidas. Si una funci\u00f3n no se utiliza, si\u00e9ntanse libres de remover el m\u00e9todo que la llama. Aseg\u00farense de que su resultado est\u00e9 ordenado, al igual que los otros ejercicios. Pueden probar su index.py usando cualquiera de los dos comandos (para cada dataset): $ make index-small # Output in spark-wc-out-index-small/ O $ make index-medium # Output in spark-wc-out-index-medium/ La salida de make-index-medium ser\u00e1 un archivo muy grande. Para poder ver el contenido de manera m\u00e1s sencilla, pueden usar los comandos cat , head , more , y grep : $ head -25 OUTPUTFILE # view the first 25 lines of output $ cat OUTPUTFILE | more # scroll through output one screen at a time (use Space) $ cat OUTPUTFILE | grep the # output only lines containing 'the' (case-sensitive) Verifiquen su salida. Abran complete-works-mark-twain.txt y eligan algunas palabras. Cuenten manualmente algunos \u00edndices de la palabra y aseg\u00farense de que todos aparezcan en su archivo de salida. Calificaci\u00f3n \u00b6 Al terminar, deben de subir su laboratorio al autograder con: ./submit <TOKEN> Para este laboratorio su soluci\u00f3n ser\u00e1 evaluada en un servidor de AWS EC2 por lo que \u00fanicamente tienen permitido hacer 3 submits . Les aconsejamos probar bien su c\u00f3digo antes de enviarlo al autograder. No olviden tambi\u00e9n subir el link de su repositorio en Github al GES.","title":"Lab 12 - MapReduce y Spark"},{"location":"labs/labSpark/#lab-12-mapreduce-y-spark","text":"","title":"Lab 12 - MapReduce y Spark"},{"location":"labs/labSpark/#objetivos","text":"Obtener experiencia ejecutando MapReduce y conseguir un conocimiento m\u00e1s profundo del paradigma MapReduce. Familiarizarse con Apache Spark y conseguir experiencia con Spark en una instalaci\u00f3n local. Aprender a aplicar el paradigma MapReduce a Spark implementando ciertos algoritmos en Spark.","title":"Objetivos"},{"location":"labs/labSpark/#preparacion","text":"Tienen que tener todos los archivos base, estos se encuentran aqu\u00ed . Recuerden que tienen que aprovechar el uso de Git y subir el link de su repositorio al GES, as\u00ed como al autograder, de lo contrario su nota ser\u00e1 de 0 . Por favor revisen la secci\u00f3n de calificaci\u00f3n para conocer el l\u00edmite de submits que tienen . Cuando ya se haya creado el repositorio, pueden ejecutar los siguientes comandos abriendo una terminal ( CTRL + T ): git clone <link del repositorio> Tambi\u00e9n, tienen que instalar el entorno de Python para este laboratorio. Para hacer esto, ejecuten lo siguiente: conda env create -f environment.yml Respondan al mensaje de instalar paquetes con \"y\" (sin comillas). Despu\u00e9s de la instalaci\u00f3n, corran el siguiente comando para activar el entorno virtual: conda activate lab12 Cuando hayan terminado con el laboratorio pueden desactivar el entorno con: conda deactivate","title":"Preparaci\u00f3n"},{"location":"labs/labSpark/#introduccion","text":"En clase los hemos expuesto a cluster computing (en particular, al framework MapReduce), como funciona y se ejecuta, pero ahora es tiempo de que ganen experiencia corriendo programas utilizando estos frameworks. En este laboratorio los vamos a introducir a Spark para que practiquen escribiendo rutinas de Map y Reduce. Este framework tiene su propia p\u00e1gina en linea, as\u00ed que son libres de probar instalarlo localmente en sus computadoras personales, de todas formas es m\u00e1s f\u00e1cil utilizar la m\u00e1quina virtual que les proporcionamos para completar este laboratorio. Aseg\u00farense de entender bien el framework de Spark, ya que lo vamos a estar utilizando en el \u00faltimo proyecto del curso.","title":"Introducci\u00f3n"},{"location":"labs/labSpark/#variables-globales","text":"Cuando est\u00e9n utilizando Spark o un framework de cluster computing, no utilicen variables globales. Esto mata el prop\u00f3sito de tener m\u00faltiples tareas corriendo en paralelo y crea cuellos de botella cuando m\u00faltiples tareas tratan de acceder a la misma variable global. Como resultado, muchos algoritmos son implementados sin el uso de variables globales. En Spark pueden hacer uso de variables broadcast , sin embargo, no las vamos a necesitar en este laboratorio.","title":"Variables Globales"},{"location":"labs/labSpark/#como-correr-spark","text":"Para este laboratorio y en el proyecto les vamos a dar un archivo que les va a ayudar a correr los archivos de Spark, pero cuando ustedes utilicen Spark afuera de la clase (que deber\u00edan), van a necesitar saber como correr Spark en la l\u00ednea de comandos. Para poder correr un archivo de Spark foo.py (similar a como ustedes corren un programa de Python foo.py ) solo utilicen el siguiente comando: spark-submit foo.py # corre el archivo de spark foo.py Si su archivo de Spark necesita argumentos (as\u00ed como los archivos del laboratorio), el comando va a ser similar, pero ustedes van a pasar tantos argumentos como necesiten, as\u00ed: spark-submit foo.py arg1 arg2 # pasa los argumentos arg1 y arg2 a foo.py Spark tambi\u00e9n incluye un int\u00e9rprete que corre con la versi\u00f3n de Python que tengan instalada, y los va a dejar probar cualquier comando de Spark en el int\u00e9rprete. El int\u00e9rprete tambi\u00e9n puede recibir archivos (pasen los archivos con la bandera --py-files). Si est\u00e1n buscando solo correr el int\u00e9rprete, el comando es el siguiente: pyspark Si quieren pre-cargar unos archivos (digamos a.py, b.py y c.py) pueden correr el siguiente comando: pyspark --py-files a.py, b.py, c.py","title":"Como correr Spark"},{"location":"labs/labSpark/#tips-rapidos-de-depuracion","text":"Si alguna vez se encuentran pregunt\u00e1ndose porqu\u00e9 su salida es extra\u00f1a o algo est\u00e1 mal cuando corren sus archivos de Spark, recuerden los siguientes tips: Aseg\u00farense de utilizar la funci\u00f3n de acci\u00f3n take . La funci\u00f3n take puede ser utilizada sobre cualquier objeto RDD (as\u00ed que pr\u00e1cticamente cualquier objeto que ustedes quieran paralelizar). Esta funci\u00f3n toma un argumento N , que es un entero y va a retornar los primeros N elementos dentro de su objeto RDD. Tambi\u00e9n pueden probar sus funciones (map, reduce, etc) adentro del int\u00e9rprete de Spark (pyspark, mencionado arriba). Simplemente importen la funci\u00f3n que quieren probar en pyspark (explicado arriba) y van a ser capaces de correr la funci\u00f3n y verificar que la salida es la que ustedes esperan. Aqu\u00ed hay un peque\u00f1o ejemplo de wordcount.py : pyspark --py-files wordcount.py # corre el interprete de spark con el archivo wordcount.py >>> from wordcount import flat_map # importa la funcion que quieren probar, flat_map, en este caso >>> file = sc.sequenceFile ( \"data/billOfRights.txt.seq\" ) # carga el archivo sequencial billOfRights.txt.seq >>> file.take ( 5 ) # retorna los primeros 5 elementos del RDD file [( <doc_name_1>, <text 1 > ) , ( <doc_name_2>, <text 2 > ) , ..., ( <doc_name_5>, <text 5 > )] >>> flat_map_output = file.flatMap ( flat_map ) # corre la funcion importada flat_map sobre file >>> flat_map_output.take ( 5 ) # retorna las primeras 5 palabras en el documento. [ 'Amendment' , 'I' , 'Congress' , 'shall' , 'make' ]","title":"Tips r\u00e1pidos de Depuraci\u00f3n"},{"location":"labs/labSpark/#documentacion-y-otros-recursos","text":"Una gu\u00eda r\u00e1pida de programaci\u00f3n en Spark (hagan click en la pesta\u00f1a de Python para ver el c\u00f3digo de Python) est\u00e1 disponile aqu\u00ed . Aqu\u00ed hay un link a la documentaci\u00f3n de la API. Para este laboratorio, no necesitan navegar mucho en ella, pero tomen un tiempo para verla cuando est\u00e9n haciendo el proyecto.","title":"Documentaci\u00f3n y Otros Recursos"},{"location":"labs/labSpark/#python","text":"Talvez algunos ya est\u00e9n familiarizados con Python ya que ha ganado popularidad en los \u00faltimos a\u00f1os (es el lenguaje m\u00e1s utilizado en universidades para cursos introductorios de programaci\u00f3n), adem\u00e1s siempre est\u00e1 en las primeras posiciones de los lenguajes de programaci\u00f3n m\u00e1s usados donde reposan los grandes como C y no hay que olvidar que es el scripting language por excelencia que utilizan compa\u00f1ias como Google, Facebook, etc. Se preguntar\u00e1n \u00bfpor qu\u00e9 aprender Python? adem\u00e1s de ser una nueva herramienta en su toolbox de conocimientos, es un lenguaje flexible, r\u00e1pido a pesar de ser interpretado y con dynamic typing (obvio no se compara con uno compilado y con static typing). Antes de empezar este laboratorio, asumimos que ya leyeron el tutorial de Python que se les proporciona en el siguiente link , es imperativo que lean el tutorial, en otros a\u00f1os han tratado de saltarse este paso y el resultado no es muy bueno, LEAN EL TUTORIAL .","title":"Python"},{"location":"labs/labSpark/#ejercicio-1-grafos-dirigidos-warm-up","text":"Este ejercicio no tiene nada que ver con MapReduce, pero les servir\u00e1 para practicar sus habilidades de Python. Tienen que implementar el m\u00e9todo path de la clase DirectedGraph , el constructor de esta clase recibe de par\u00e1metro una matriz de booleans, la cual representar\u00e1 la matriz de adyacencias de un grafo dirigido. Los estados iran del 0, hasta length - 1 de la matriz. El m\u00e9todo path(self, start, end) devuelve una lista de Python con el camino m\u00e1s corto desde el estado start al estado end , el resultado (los elementos de la lista) debe contener los estados por los que se deben de pasar incluyendo el estado start (el inicio) y end (el final). Si nuestro grafo G fuera el siguiente: y quisieramos el camino m\u00e1s corto del estado 2 a los dem\u00e1s estados, obtendriamos el siguiente resultado: from state: 2 to state: 0 = shortest path: 2 -> 0, distance: 1 to state: 1 = shortest path: 2 -> 0 -> 1, distance: 2 to state: 3 = shortest path: 2 -> 3, distance: 1 to state: 4 = shortest path: 2 -> 3 -> 4, distance: 2 to state: 5 = shortest path: 2 -> 3 -> 5, distance: 2 to state: 6 = shortest path: 2 -> 3 -> 4 -> 6, distance: 3 to state: 7 = shortest path: 2 -> 3 -> 5 -> 7, distance: 3 Para este ejercicio les recomendamos utilizar Breadth-first search (BFS), para los que no se recuerdan aqu\u00ed hay una variante que solo toma en cuenta el arreglo de predecesores $\\pi$ (\u00bfPor qu\u00e9 solo predecesores?): BFS ( G , s ) { for each vertex u \u2208 V [ G ] \u2013 { s } { visited [ u ] = false \u03c0 [ u ] = null } visited [ s ] = true \u03c0 [ s ] = null Q = [ s ] while ( Q != \u2205 ) { u = Q . dequeue () for each v \u2208 Adj [ u ] { if not visited [ v ] { visited [ v ] = true \u03c0 [ v ] = u Q . enqueue ( v ) } } } return \u03c0 } Pueden probar su implementaci\u00f3n utilizando el siguiente comando: make graph Esto probar\u00e1 su implementaci\u00f3n con el grafo que se muestra en la figura de arriba, de esta manera pueden saber si el resultado que obtienen es el correcto.","title":"Ejercicio 1: Grafos Dirigidos (Warm-Up)"},{"location":"labs/labSpark/#ejemplo-ejecutando-un-contador-de-palabras","text":"En este ejemplo vamos a ejecutar el hola mundo de MapReduce que es un contador de palabras. Pueden probarlo con: make sparkwc-small Esto ejecutar\u00e1 wordcount.py con billOfRights.txt.seq . El resultado deber\u00eda estar en wc-out-wordcount-small/part-00000 . Una caracter\u00edstica interesante de Spark es que es un motor de c\u00f3mputo distribuido en memoria, asi que no tiene un almacenamiento de archivos predeterminado. Por ello, utilizamos el Hadoop Distributed File System (HDFS) para poder guardar el resultado. Los exhortamos a leer acerca de Hadoop por su cuenta. en general, Hadoop requiere que el directorio de salida no exista al ejecutar un programa de MapReduce, pero el makefile se encarga de esto, removiendo el directorio de salida anterior. Traten con el archivo m\u00e1s grande, complete-works-mark-twain.txt.seq : make sparkwc-medium Su salida para este comando estar en el directorio spark-wc-out-wordcount-medium . Busquen en el archivo alguna palabra como \"the\" para entender mejor la salida. Tomen un tiempo para ver y analizar wordcount.py , traten de entender lo que est\u00e1 haciendo el c\u00f3digo les va a servir para el siguiente ejercicio del laboratorio.","title":"Ejemplo: Ejecutando un contador de palabras"},{"location":"labs/labSpark/#ejercicio-2-document-word-count","text":"Abran docwordcount.py . Noten que tiene casi el mismo c\u00f3digo que wordcount.py , que acaban de probar. Modif\u00edquenlo para contar la cantidad de documentos que contienen cada palabra en lugar de la cantidad de veces que aparece una palabra en la entrada. Para ayudarlos a entender el c\u00f3digo, hemos agregado varios comentarios, pero si\u00e9ntanse libres de revisar las transformaciones y acciones en la p\u00e1gina de Spark para una explicaci\u00f3n m\u00e1s detallada de algunos m\u00e9todos que pueden usarse en Spark. En esta parte, les ser\u00e1 \u00fatil revisar los links de transformaciones y acciones de arriba, ya que hay m\u00e9todos que pueden usar para ayudarlos a ordenar una salida o remover items duplicados. Para ayudarlos a distinguir cu\u00e1ndo aparece una palabra en un documento, tal vez quieran hacer uso del document_id tambi\u00e9n -- esto se menciona en los comentarios de flat_map() . Finalmente, aseg\u00farense de ordenar en orden alfab\u00e9tico el resultado final. (pista: \u00bfHabr\u00e1 alguna otra transformaci\u00f3n que puedan usar?) Pueden probar docwordcount.py usando cualquiera de estos dos comandos (para los 2 datasets): make sparkdwc-small # Output in spark-wc-out-docwordcount-small/ O make sparkdwc-medium # Output in spark-wc-out-docwordcount-medium/","title":"Ejercicio 2: Document Word Count"},{"location":"labs/labSpark/#ejercicio-3-full-text-index-creation","text":"Abran index.py . Noten que el c\u00f3digo es similar a docwordcount.py . Modif\u00edquenlo para desplegar cada palabra y una lista de ocurrencias (identificador de documento, seguido del \u00edndice de CADA vez que la palabra est\u00e9 en ese documento). Aseg\u00farense de que los \u00edndices empiecen con cero. La salida tendr\u00eda que tener lineas que se vean como lo siguiente: (word1 document1-id, word# word# ...) (word1 document2-id, word# word# ...) . . . (word2 document1-id, word# word# ...) (word2 document3-id, word# word# ...) . . . Noten que hay una linea para CADA documento en el que la palabra aparezca y CADA par de palabra y documento debe tener solo UNA lista de \u00edndices. Recuerden que tambi\u00e9n necesitan desplegar el document ID . Para este ejercicio, tal vez no necesiten todas las funciones definidas. Si una funci\u00f3n no se utiliza, si\u00e9ntanse libres de remover el m\u00e9todo que la llama. Aseg\u00farense de que su resultado est\u00e9 ordenado, al igual que los otros ejercicios. Pueden probar su index.py usando cualquiera de los dos comandos (para cada dataset): $ make index-small # Output in spark-wc-out-index-small/ O $ make index-medium # Output in spark-wc-out-index-medium/ La salida de make-index-medium ser\u00e1 un archivo muy grande. Para poder ver el contenido de manera m\u00e1s sencilla, pueden usar los comandos cat , head , more , y grep : $ head -25 OUTPUTFILE # view the first 25 lines of output $ cat OUTPUTFILE | more # scroll through output one screen at a time (use Space) $ cat OUTPUTFILE | grep the # output only lines containing 'the' (case-sensitive) Verifiquen su salida. Abran complete-works-mark-twain.txt y eligan algunas palabras. Cuenten manualmente algunos \u00edndices de la palabra y aseg\u00farense de que todos aparezcan en su archivo de salida.","title":"Ejercicio 3: Full Text Index Creation"},{"location":"labs/labSpark/#calificacion","text":"Al terminar, deben de subir su laboratorio al autograder con: ./submit <TOKEN> Para este laboratorio su soluci\u00f3n ser\u00e1 evaluada en un servidor de AWS EC2 por lo que \u00fanicamente tienen permitido hacer 3 submits . Les aconsejamos probar bien su c\u00f3digo antes de enviarlo al autograder. No olviden tambi\u00e9n subir el link de su repositorio en Github al GES.","title":"Calificaci\u00f3n"},{"location":"notes/00_Numbers-Representation/","text":"Representaci\u00f3n Num\u00e9rica \u00b6 Como las computadoras representan n\u00fameros Los humanos pensamos en base 10, esto se debe a que usamos los 10 dedos de las manos para contar. Sin embargo los n\u00fameros pueden ser representado en cualquier base. Por ejemplo 123 (en base 10) se representa como 0b 1111011 (Notar el 0b al inicio) en base 2. Los n\u00fameros se guardan en la memoria de la computadora (ram, cache, registros, etc.) como una serie de se\u00f1ales electr\u00f3nicas (altas y bajas) por lo que se consideran n\u00fameros en base 2. Conversi\u00f3n de binario a decimal \u00b6 Para convertir un n\u00famero binario a decimal multiplicamos cada bit, empezando por el bit menos significativo, por potencias de 2. Por convenci\u00f3n consideraremos el bit menos significativo como el bit m\u00e1s a la derecha del n\u00famero binario (as\u00ed como el d\u00edgito de menor valor es el que eta m\u00e1s a la derecha en un numero decimal). Ejemplo \u00b6 Representar el n\u00famero 0b10011011 en base 10. Asuma que se encuentra en notaci\u00f3n sin signo. $$1 {\\color{red}\\times 2^7} + 0 {\\color{red}\\times 2^6} + 0 {\\color{red}\\times 2^5} + 1 {\\color{red}\\times 2^4} + 1 {\\color{red}\\times 2^3} +0 {\\color{red}\\times 2^2} + 1{\\color{red}\\times 2^1} + 1 {\\color{red}\\times 2^0}$$ $$=128 + 0 +0+16+8+0+2+1=155$$ Entonces 0b10011011 = 155 Conversi\u00f3n de decimal a binario \u00b6 Para hacer la conversi\u00f3n de decimal a binario, hay que dividir el n\u00famero decimal entre dos y anotar en una columna a la derecha el resto (un 0 si el resultado de la divisi\u00f3n es par y un 1 si es impar). Ejemplo \u00b6 Representar en numero 109 en base binaria, en su notaci\u00f3n sin signo. N N/2 N%2 109 54 1 54 27 0 27 13 1 13 6 1 6 3 0 3 1 1 1 0 1 Noten que terminamos la division cuando N/2 es 0. El n\u00famero binario resultante ser\u00edan entonces todos los residuos N%2 siendo el bit menos significativo el de la primera fila, y el bit m\u00e1s significativo el de la ultima fila: 0b1101101 Conversi\u00f3n de binario a hexadecimal \u00b6 El sistema hexadecimal tiene como base 16. Para suplir los digitos que faltan, usamos las letras A, B, C, D, E y F para representar los valores 10, 11,12,13, 14 y 15 respectivamente. Para convertir un n\u00famero binario a hexadecimal puede convertir el n\u00famero a base 10 y luego a base 16 o crear grupos de 4 bits (empezando por el bit menos significativo) y convertirlos a hexadecimal directamente. Ejemplo \u00b6 Representar el n\u00famero 0b10011011 en hexadecimal. Agrupado tenemos $0\\text{b}{\\color{red}1001}\\, {\\color{blue}1011}$. 1011 corresponde a 11 en base 10, es decir a 'A' en hexadecimal. 1001 corresponde a 9 en base 10, es decir a '9 en hexadecimal. Entonces 0b10011011 = 0x9A. Representar el n\u00famero 0b11101101101101 en hexadecimal. Agrupado tenemos $0\\text{b}{\\color{red}11}{1011}\\, {\\color{blue}0110} \\, {\\color{green}1101}$. 1101 corresponde a D en hexadecimal. 0110 corresponde a 6 en hexadecimal. 1011 corresponde a B en hexadecimal. 0011 corresponde a 3 en hexadecimal (notar que se le agreg\u00f3 dos ceros). Entonces 0b11101101101101 = 0x3B6D. - Para convertir un n\u00famero decimal a hexadecimal seguimos un procedimiento similar al empleado para convertir un n\u00famero decimal a binario, excepto que el dividendo debe cambiarse por 16. Representaci\u00f3n de n\u00fameros con signo \u00b6 Hasta el momento, solo se han tratado n\u00fameros binarios que representan n\u00fameros enteros positivos. Pero tambien necesitamos una forma de representar en binario n\u00fameros como el -6, -100, etc. 1. Signo Magnitud \u00b6 Cuando representamos n\u00fameros decimales negativos, se le antepone el s\u00edmbolo - para indicar que el n\u00famero es negativo. Es posible intentar lo mismo en binario, pero en vez de usar ese s\u00edmbolo, usar un 0 o un 1 para diferenciar entre numeros positivos y negativos. Usaremos el bit m\u00e1s significativo para especificar el signo del n\u00famero Un 1 denotar\u00e1 que el n\u00famero es negativo y un 0 que el n\u00famero es positivo. Ejemplo: \u00b6 El n\u00famero 0b11110101 = -117 Porque el 0b1110101 = 117 y como el bit m\u00e1s significativo es 1, el n\u00famero es negativo. El n\u00famero 0b01110101 = 117. El n\u00famero 0b10000001 = -1 El n\u00famero 0b00000001 = 1 Hay varias cosas que deben notarse con respecto de esta representaci\u00f3n. Estas son las m\u00e1s importantes: La cantidad de n\u00fameros que se pueden representar con la misma cantidad de bits disminuye. En los ejemplos anteriores se utilizan 8 bits, pero como el bit m\u00e1s significativo es de signo, el n\u00famero positivo m\u00e1s grande que podemos representar el $2^7-1=127$ en comparaci\u00f3n con $2^8 -1=255$ si no se usara signo. Hay dos \"0\". \u00bfC\u00f3mo se interpreta 0b10000000? Sumar y restar requiere m\u00e1s trabajo; m\u00e1s adelante ver\u00e1n que se necesitan circuitos m\u00e1s complejos para realizar estas operaciones. 2. Complemento a uno \u00b6 Para representar un n\u00famero en complemento a uno se invierten todos los bits de la representaci\u00f3n binaria del n\u00famero (se intercambia 1 por 0 y viceversa). Ejemplo \u00b6 Representar el n\u00famero -101 en complemento a uno. El n\u00famero 101 = 0b01100101 invirtiendo todos los bits obtenemos. -101 = 0b10011010. Complemento a uno facilita m\u00e1s las operaciones matem\u00e1ticas, pero tenemos ciertos problemas a\u00fan: - Existen dos ceros todavia: 0b00000000 y 0b11111111 - Las operaciones matem\u00e1ticas a\u00fan cuestan un poco mas. Por ejemplo, si sumamos 2 y -2 usando 4 bits: 0b0010 + 0b1101 = 0b1111 que es uno de los ceros, pero a\u00fan no es el la respuesta que deberiamos obtener. 3. Complemento a dos \u00b6 Para representar un n\u00famero en complemento a dos se le suma uno al complemento a uno del numero. Ejemplo \u00b6 Representar el n\u00famero -101 en complemento a dos. 101= 0b01100101 que en complemento a uno es 0b10011010, luego, es necesario sumare 1 a numero anterior: 0b10011010 +1 = 0b10011001 Con complemento a dos: - Eliminamos el segundo cero - Simplificamos las sumas y restas de gran manera: a+b siempre utiliza el mismo algoritmo, independientemente de si a y b son positivos o negativos. a-b es lo mismo que sumar a con el complemento a 2 de b Extensi\u00f3n de Signo \u00b6 \u00bfQu\u00e9 pasa si quiero representar un n\u00famero con 'm\u00e1s' bits? - Es de esperar que se preserve el valor del n\u00famero y el signo - En complemento a dos se 'rellenan' los 'espacios' faltantes con el bit de signo. Ejemplo \u00b6 Representar el n\u00famero 0b1111110001 (-15 en decimal) utilizando diecis\u00e9is bits. $-15 = \\text{0b}{\\color{red}111111}1111110001$ Los n\u00fameros escritos en color rojo se copiaron para extender el signo. - Tomar en cuenta que 1 word = 4 bytes = 32 bits - Corrimientos aritm\u00e9ticos y l\u00f3gicos - Operadores || y && en c","title":"N\u00fameros"},{"location":"notes/00_Numbers-Representation/#representacion-numerica","text":"Como las computadoras representan n\u00fameros Los humanos pensamos en base 10, esto se debe a que usamos los 10 dedos de las manos para contar. Sin embargo los n\u00fameros pueden ser representado en cualquier base. Por ejemplo 123 (en base 10) se representa como 0b 1111011 (Notar el 0b al inicio) en base 2. Los n\u00fameros se guardan en la memoria de la computadora (ram, cache, registros, etc.) como una serie de se\u00f1ales electr\u00f3nicas (altas y bajas) por lo que se consideran n\u00fameros en base 2.","title":"Representaci\u00f3n Num\u00e9rica"},{"location":"notes/00_Numbers-Representation/#conversion-de-binario-a-decimal","text":"Para convertir un n\u00famero binario a decimal multiplicamos cada bit, empezando por el bit menos significativo, por potencias de 2. Por convenci\u00f3n consideraremos el bit menos significativo como el bit m\u00e1s a la derecha del n\u00famero binario (as\u00ed como el d\u00edgito de menor valor es el que eta m\u00e1s a la derecha en un numero decimal).","title":"Conversi\u00f3n de binario a decimal"},{"location":"notes/00_Numbers-Representation/#ejemplo","text":"Representar el n\u00famero 0b10011011 en base 10. Asuma que se encuentra en notaci\u00f3n sin signo. $$1 {\\color{red}\\times 2^7} + 0 {\\color{red}\\times 2^6} + 0 {\\color{red}\\times 2^5} + 1 {\\color{red}\\times 2^4} + 1 {\\color{red}\\times 2^3} +0 {\\color{red}\\times 2^2} + 1{\\color{red}\\times 2^1} + 1 {\\color{red}\\times 2^0}$$ $$=128 + 0 +0+16+8+0+2+1=155$$ Entonces 0b10011011 = 155","title":"Ejemplo"},{"location":"notes/00_Numbers-Representation/#conversion-de-decimal-a-binario","text":"Para hacer la conversi\u00f3n de decimal a binario, hay que dividir el n\u00famero decimal entre dos y anotar en una columna a la derecha el resto (un 0 si el resultado de la divisi\u00f3n es par y un 1 si es impar).","title":"Conversi\u00f3n de decimal a binario"},{"location":"notes/00_Numbers-Representation/#ejemplo_1","text":"Representar en numero 109 en base binaria, en su notaci\u00f3n sin signo. N N/2 N%2 109 54 1 54 27 0 27 13 1 13 6 1 6 3 0 3 1 1 1 0 1 Noten que terminamos la division cuando N/2 es 0. El n\u00famero binario resultante ser\u00edan entonces todos los residuos N%2 siendo el bit menos significativo el de la primera fila, y el bit m\u00e1s significativo el de la ultima fila: 0b1101101","title":"Ejemplo"},{"location":"notes/00_Numbers-Representation/#conversion-de-binario-a-hexadecimal","text":"El sistema hexadecimal tiene como base 16. Para suplir los digitos que faltan, usamos las letras A, B, C, D, E y F para representar los valores 10, 11,12,13, 14 y 15 respectivamente. Para convertir un n\u00famero binario a hexadecimal puede convertir el n\u00famero a base 10 y luego a base 16 o crear grupos de 4 bits (empezando por el bit menos significativo) y convertirlos a hexadecimal directamente.","title":"Conversi\u00f3n de binario a hexadecimal"},{"location":"notes/00_Numbers-Representation/#ejemplo_2","text":"Representar el n\u00famero 0b10011011 en hexadecimal. Agrupado tenemos $0\\text{b}{\\color{red}1001}\\, {\\color{blue}1011}$. 1011 corresponde a 11 en base 10, es decir a 'A' en hexadecimal. 1001 corresponde a 9 en base 10, es decir a '9 en hexadecimal. Entonces 0b10011011 = 0x9A. Representar el n\u00famero 0b11101101101101 en hexadecimal. Agrupado tenemos $0\\text{b}{\\color{red}11}{1011}\\, {\\color{blue}0110} \\, {\\color{green}1101}$. 1101 corresponde a D en hexadecimal. 0110 corresponde a 6 en hexadecimal. 1011 corresponde a B en hexadecimal. 0011 corresponde a 3 en hexadecimal (notar que se le agreg\u00f3 dos ceros). Entonces 0b11101101101101 = 0x3B6D. - Para convertir un n\u00famero decimal a hexadecimal seguimos un procedimiento similar al empleado para convertir un n\u00famero decimal a binario, excepto que el dividendo debe cambiarse por 16.","title":"Ejemplo"},{"location":"notes/00_Numbers-Representation/#representacion-de-numeros-con-signo","text":"Hasta el momento, solo se han tratado n\u00fameros binarios que representan n\u00fameros enteros positivos. Pero tambien necesitamos una forma de representar en binario n\u00fameros como el -6, -100, etc.","title":"Representaci\u00f3n de n\u00fameros con signo"},{"location":"notes/00_Numbers-Representation/#1-signo-magnitud","text":"Cuando representamos n\u00fameros decimales negativos, se le antepone el s\u00edmbolo - para indicar que el n\u00famero es negativo. Es posible intentar lo mismo en binario, pero en vez de usar ese s\u00edmbolo, usar un 0 o un 1 para diferenciar entre numeros positivos y negativos. Usaremos el bit m\u00e1s significativo para especificar el signo del n\u00famero Un 1 denotar\u00e1 que el n\u00famero es negativo y un 0 que el n\u00famero es positivo.","title":"1. Signo Magnitud"},{"location":"notes/00_Numbers-Representation/#ejemplo_3","text":"El n\u00famero 0b11110101 = -117 Porque el 0b1110101 = 117 y como el bit m\u00e1s significativo es 1, el n\u00famero es negativo. El n\u00famero 0b01110101 = 117. El n\u00famero 0b10000001 = -1 El n\u00famero 0b00000001 = 1 Hay varias cosas que deben notarse con respecto de esta representaci\u00f3n. Estas son las m\u00e1s importantes: La cantidad de n\u00fameros que se pueden representar con la misma cantidad de bits disminuye. En los ejemplos anteriores se utilizan 8 bits, pero como el bit m\u00e1s significativo es de signo, el n\u00famero positivo m\u00e1s grande que podemos representar el $2^7-1=127$ en comparaci\u00f3n con $2^8 -1=255$ si no se usara signo. Hay dos \"0\". \u00bfC\u00f3mo se interpreta 0b10000000? Sumar y restar requiere m\u00e1s trabajo; m\u00e1s adelante ver\u00e1n que se necesitan circuitos m\u00e1s complejos para realizar estas operaciones.","title":"Ejemplo:"},{"location":"notes/00_Numbers-Representation/#2-complemento-a-uno","text":"Para representar un n\u00famero en complemento a uno se invierten todos los bits de la representaci\u00f3n binaria del n\u00famero (se intercambia 1 por 0 y viceversa).","title":"2. Complemento a uno"},{"location":"notes/00_Numbers-Representation/#ejemplo_4","text":"Representar el n\u00famero -101 en complemento a uno. El n\u00famero 101 = 0b01100101 invirtiendo todos los bits obtenemos. -101 = 0b10011010. Complemento a uno facilita m\u00e1s las operaciones matem\u00e1ticas, pero tenemos ciertos problemas a\u00fan: - Existen dos ceros todavia: 0b00000000 y 0b11111111 - Las operaciones matem\u00e1ticas a\u00fan cuestan un poco mas. Por ejemplo, si sumamos 2 y -2 usando 4 bits: 0b0010 + 0b1101 = 0b1111 que es uno de los ceros, pero a\u00fan no es el la respuesta que deberiamos obtener.","title":"Ejemplo"},{"location":"notes/00_Numbers-Representation/#3-complemento-a-dos","text":"Para representar un n\u00famero en complemento a dos se le suma uno al complemento a uno del numero.","title":"3. Complemento a dos"},{"location":"notes/00_Numbers-Representation/#ejemplo_5","text":"Representar el n\u00famero -101 en complemento a dos. 101= 0b01100101 que en complemento a uno es 0b10011010, luego, es necesario sumare 1 a numero anterior: 0b10011010 +1 = 0b10011001 Con complemento a dos: - Eliminamos el segundo cero - Simplificamos las sumas y restas de gran manera: a+b siempre utiliza el mismo algoritmo, independientemente de si a y b son positivos o negativos. a-b es lo mismo que sumar a con el complemento a 2 de b","title":"Ejemplo"},{"location":"notes/00_Numbers-Representation/#extension-de-signo","text":"\u00bfQu\u00e9 pasa si quiero representar un n\u00famero con 'm\u00e1s' bits? - Es de esperar que se preserve el valor del n\u00famero y el signo - En complemento a dos se 'rellenan' los 'espacios' faltantes con el bit de signo.","title":"Extensi\u00f3n de Signo"},{"location":"notes/00_Numbers-Representation/#ejemplo_6","text":"Representar el n\u00famero 0b1111110001 (-15 en decimal) utilizando diecis\u00e9is bits. $-15 = \\text{0b}{\\color{red}111111}1111110001$ Los n\u00fameros escritos en color rojo se copiaron para extender el signo. - Tomar en cuenta que 1 word = 4 bytes = 32 bits - Corrimientos aritm\u00e9ticos y l\u00f3gicos - Operadores || y && en c","title":"Ejemplo"},{"location":"notes/01_C/","text":"Introducci\u00f3n a C \u00b6 C es un lenguaje de programaci\u00f3n desarrollado en el a\u00f1o 1972 por Dennis Ritchie. El lenguaje C es un lenguaje estructurado el cual a pesar de ser un lenguaje de \"alto nivel\", da acceso a hacer uso de la memoria, registros, etc. C es un lenguaje compilado; se compila una vez para cada arquitectura y se genera un binario que se puede ejecutar directamente. Para poder compilar y ejecutar un archivo llamado HelloWorld.c, se realiza de la siguiente manera: $ gcc HelloWorld . c // se compila el archivo $ . / a . out // se ejecuta el programa $ Hello World //output del programa, en este caso Notese que el compilador que estamos utilizando se llama gcc . gcc * se encuentra por defecto en la mayoria de sistemas operativos con kernel linux . Cuando nosotros no especificamos un nombre para el archivo de salida, cgg lo nombra, por defecto, a.out**. Si queremos especificar un nombre para el archivo de salida entonces podemos utilizar la bandera -o : $ gcc - o Hello HelloWorld . c // se compila el archivo $ . / Hello // se ejecuta el programa $ Hello World //output del programa, en este caso Comentarios en c \u00b6 // para realizar comentarios de una l\u00ednea /* TODO LO QUE ESTE DENTRO DE ESTA PARTE ES UN COMENTARIO */ ``` ~ ## Tipos de declaraci\u00f3n Las variables deben ser declaradas antes de usarse y el tipo de la variable no puede ser cambiado . En C , el tama\u00f1o de la variable depende de la arquitectura en la cual se este trabajando ( x_86 , x_86_84 , ARM , RISC - V , etc .). Algo muy importante que diferencia lenguajes como Java de C , es que en C , si no se inicializa el valor de la variable , la podemos utilizar sin problemas , pero contendr\u00e1 informaci\u00f3n \"basura\" , es decir , los datos que estaban ubicados previamente en la direcci\u00f3n de memoria en donde la variable fue guardada . ## Declaraci\u00f3n de constantes ``` C #define CONSTANTE_DEFINE 25 enum T_ENUM { CONSTANTE_ENUM = 25 }; const int CONSTANTE_VARIABLE = 25 ; Valores Booleanos en C \u00b6 Es un importante mencionar que en C, las variables tipo booleanas no existen. En vez de eso, todo valor diferente de 0 se considera verdadero, es decir si se desea representar el valor falso se debe utilizar un 0. Funciones en C \u00b6 En la declaraci\u00f3n de la funci\u00f3n debe ir el tipo de dato del valor de retorno y de todos los argumentos. void para declarar funciones sin nigun retorno. Las funciones en C deben ser declaradas antes de ser usadas; esto implica que tendremos problemas con funciones de este tipo: int funcion1 ( int x ){ if ( x < 10 ){ return function2 ( x ); } return x + 1 ; } int funcion2 ( int x ){ if ( x >= 10 ){ return function1 ( x ); } return x - 1 ; } Noten que aqui function1(int x) ejecuta function2(int x) , pero function2(int x) esta definida abajo de function1(int x) . Para solucionar este problema, declaramos las funciones antes de definirlas: int function1 ( int x ); int function2 ( int x ); int funcion1 ( int x ){ if ( x < 10 ){ return function2 ( x ); } return x + 1 ; } int funcion2 ( int x ){ if ( x >= 10 ){ return function1 ( x ); } return x - 1 ; } Ejemplo: Funci\u00f3n que retorna un valor entero. \u00b6 int funcion1 (){ x = 10 ; return x ; } Ejemplo: Funci\u00f3n que no tiene un valor de retorno y que recibe un entero como argumento. \u00b6 void function2 ( int x ){ printf ( \"Hola Mundo %d!\" , x ); } Estructuras en c \u00b6 Es un tipo de dato compuesto el cual permite almacenar un conjunto de datos de tipos diferentes. Es muy similar a lo que en java se conoce como clases, pero sin m\u00e9todos. Ejemplo: \u00b6 int main ( void ){ /*definimos una estructura en C llamada Point que contiene 2 variables de tipo entero. */ typedef struct { int x , y ; } Point ; Point p1 ; //se define una variable de tipo Point llamada p1 //asignanci\u00f3n de valores a las variables x y y de la variable p1. p1 . x = 2 ; p1 . y = 4 ; return 0 ; } Punteros en c \u00b6 Un puntero es una variable la cual guarda la direcci\u00f3n de memoria de otra variable o de alg\u00fan dato. Es necesario al igual que una simple variable asignar el tipo que representa. Ejemplo: \u00b6 int * pi ; //declaraci\u00f3n de un puntero de datos enteros. char * pc ; //declaraci\u00f3n de un puntero d\u00e9 datos tipo char. Ejemplo: Puntero de tipo arbitrario. \u00b6 //definici\u00f3n de un puntero el cual puede ser asignado a diferentes tipos. void * vp ; Podemos incluso definir un puntero que apunta a un puntero Ejemplo: Puntero de Punteros \u00b6 //definici\u00f3n una variable, un puntero que apunta a ella, y un puntero que apunta a este puntero char c = '1' ; char * p = & c ; char ** args = & p ; Ejemplo: Asiginar Valores Usando Punteros \u00b6 int x = 10 ; int * pi = & x ; //al puntero pi se le asigna la direcci\u00f3n de memoria de la variable x. int valorx = * pi ; // en la variable valorx se almacena el valor al cual apunta la variable pi, en este ejemplo es 10 C pasa los argumentos a una funci\u00f3n por valor, esto quiere decir que la informaci\u00f3n de la variable que se recibe en la funci\u00f3n es almacenada en una diferente direcci\u00f3n de memoria por lo tanto si la variable se altera dentro de la funci\u00f3n, solo ser\u00e1 modificada en el contexto de la funci\u00f3n. Para poder modificar el valor de una variable x declarada en una funci\u00f3n A desde una funci\u00f3n B , enviamos un puntero que apunta a x como argumento a la funci\u00f3n B : Ejemplo: \u00b6 void addOne ( int * x ){ ( * x ) ++ ; } int functionA (){ int x = 10 ; addOne ( & x ); return x ; } Noten el usuo de los par\u00e9ntesis, sin los par\u00e9ntesis, aumentariamos en 1 el puntero, pero al agregarlos, aumentamos en 1 el valor al que apunta el puntero Manejo de Memoria en C \u00b6 Podemos diferenciar varias estructuras de memoria existentes al momento de ejecutar un programa: - \u00c0rea de Texto: Almacena las instrucciones que estamos ejecutando - \u00c0rea de Datos: Almacena datos como numeros y strings que son constantes globales en nuestro programa - Stack: Almacena datos estaticos como variables, arreglos de tama\u00f1o predefinito, etc. Estos datos tienen la caracteristica de que no existen en todo momento de la ejecuci\u00f3n del programa. Por ejemplo, una variable x definida en cierta funci\u00f3n solo existir\u00e1 cuando esa funci\u00f3n se este ejecutando. Algunas cosas a tomar en cuenta sobre el stack, aunque no las veremos directamente en C, son las siguientes: - Tiene 3 operaciones b\u00e1sicas de un stack: push, pop, top (observar que hay) - CUIDADO con la ubicacion del Stack; en assembler veremos que el Stack crece habia abajo , lo que significa que cuando agregamos un dato, la direcci\u00f3n de memoria disminuye - A nivel ensamblador existe un registro llamado Stack Pointer o SP . Probablemente el registro m\u00e1s usado en assembler - Las variables locales y los par\u00e1metros de las funciones se guardan en el Stack - La direcci\u00f3n de retorno tambien se guarda en el Stack - El compilador es el que se encarga de pedir memoria en cada llamada y devolverla cuando se termina, es decir, el Stack es \"transparente\" al programador de C Heap: Almacena datos din\u00e1micos , como por ejemplo, un arreglo del tama\u00f1o indicado por el usuario. En C, el Heap es la unica estructura de memoria que es administrada directamente por el programador (reservar, liberar y respetar el espacio asignado). El heap, a diferencia del Stack, crece a direcciones de memorias m\u00e1s altas. Manejo del Heap \u00b6 funci\u00f3n malloc() : los devuelve un bloque de memoria. No los inicializa con ning\u00fan valor. ptr = ( cast - type * ) malloc ( byte - size ) // prt es un puntero #### Ejemplo // ptr es puntero a un \"bloque\" de 100 enteros. ptr = ( int * ) malloc ( 100 * sizeof ( int )); funci\u00f3n calloc() : bloque de memoria inicializada con ceros. Es una operaci\u00f3n lenta. Evitar usarla en cuanto sea posible. funci\u00f3n free() : libera un bloque de memoria que previamente pedimos. cuidado con usar malloc sin el free. \"Aqu\u00ed no hay garbage collector\" Puede ser lento buscar espacio disponible Recordar que manejar el heap es tarea del programador. Uso de Valgrid \u00b6 Se puede descargar de: http://valgrind.org/ - Ayuda a la depuraci\u00f3n de problemas de memoria. Puede servir para detectar problemas como fugas de memoria (memory leak). Clasificaci\u00f3n de Bugs \u00b6 Bohr Bugs sabemos en precisamente en donde est\u00e1 (como los electones en el modelo at\u00f3mico de Bohr) F\u00e1ciles de reproducir Heinsenbugs Dif\u00edciles de diagnosticar Dificiles de reproducir","title":"C"},{"location":"notes/01_C/#introduccion-a-c","text":"C es un lenguaje de programaci\u00f3n desarrollado en el a\u00f1o 1972 por Dennis Ritchie. El lenguaje C es un lenguaje estructurado el cual a pesar de ser un lenguaje de \"alto nivel\", da acceso a hacer uso de la memoria, registros, etc. C es un lenguaje compilado; se compila una vez para cada arquitectura y se genera un binario que se puede ejecutar directamente. Para poder compilar y ejecutar un archivo llamado HelloWorld.c, se realiza de la siguiente manera: $ gcc HelloWorld . c // se compila el archivo $ . / a . out // se ejecuta el programa $ Hello World //output del programa, en este caso Notese que el compilador que estamos utilizando se llama gcc . gcc * se encuentra por defecto en la mayoria de sistemas operativos con kernel linux . Cuando nosotros no especificamos un nombre para el archivo de salida, cgg lo nombra, por defecto, a.out**. Si queremos especificar un nombre para el archivo de salida entonces podemos utilizar la bandera -o : $ gcc - o Hello HelloWorld . c // se compila el archivo $ . / Hello // se ejecuta el programa $ Hello World //output del programa, en este caso","title":"Introducci\u00f3n a C"},{"location":"notes/01_C/#comentarios-en-c","text":"// para realizar comentarios de una l\u00ednea /* TODO LO QUE ESTE DENTRO DE ESTA PARTE ES UN COMENTARIO */ ``` ~ ## Tipos de declaraci\u00f3n Las variables deben ser declaradas antes de usarse y el tipo de la variable no puede ser cambiado . En C , el tama\u00f1o de la variable depende de la arquitectura en la cual se este trabajando ( x_86 , x_86_84 , ARM , RISC - V , etc .). Algo muy importante que diferencia lenguajes como Java de C , es que en C , si no se inicializa el valor de la variable , la podemos utilizar sin problemas , pero contendr\u00e1 informaci\u00f3n \"basura\" , es decir , los datos que estaban ubicados previamente en la direcci\u00f3n de memoria en donde la variable fue guardada . ## Declaraci\u00f3n de constantes ``` C #define CONSTANTE_DEFINE 25 enum T_ENUM { CONSTANTE_ENUM = 25 }; const int CONSTANTE_VARIABLE = 25 ;","title":"Comentarios en c"},{"location":"notes/01_C/#valores-booleanos-en-c","text":"Es un importante mencionar que en C, las variables tipo booleanas no existen. En vez de eso, todo valor diferente de 0 se considera verdadero, es decir si se desea representar el valor falso se debe utilizar un 0.","title":"Valores Booleanos en C"},{"location":"notes/01_C/#funciones-en-c","text":"En la declaraci\u00f3n de la funci\u00f3n debe ir el tipo de dato del valor de retorno y de todos los argumentos. void para declarar funciones sin nigun retorno. Las funciones en C deben ser declaradas antes de ser usadas; esto implica que tendremos problemas con funciones de este tipo: int funcion1 ( int x ){ if ( x < 10 ){ return function2 ( x ); } return x + 1 ; } int funcion2 ( int x ){ if ( x >= 10 ){ return function1 ( x ); } return x - 1 ; } Noten que aqui function1(int x) ejecuta function2(int x) , pero function2(int x) esta definida abajo de function1(int x) . Para solucionar este problema, declaramos las funciones antes de definirlas: int function1 ( int x ); int function2 ( int x ); int funcion1 ( int x ){ if ( x < 10 ){ return function2 ( x ); } return x + 1 ; } int funcion2 ( int x ){ if ( x >= 10 ){ return function1 ( x ); } return x - 1 ; }","title":"Funciones en C"},{"location":"notes/01_C/#ejemplo-funcion-que-retorna-un-valor-entero","text":"int funcion1 (){ x = 10 ; return x ; }","title":"Ejemplo: Funci\u00f3n que retorna un valor entero."},{"location":"notes/01_C/#ejemplo-funcion-que-no-tiene-un-valor-de-retorno-y-que-recibe-un-entero-como-argumento","text":"void function2 ( int x ){ printf ( \"Hola Mundo %d!\" , x ); }","title":"Ejemplo: Funci\u00f3n que no tiene un valor de retorno y que recibe un entero como argumento."},{"location":"notes/01_C/#estructuras-en-c","text":"Es un tipo de dato compuesto el cual permite almacenar un conjunto de datos de tipos diferentes. Es muy similar a lo que en java se conoce como clases, pero sin m\u00e9todos.","title":"Estructuras en c"},{"location":"notes/01_C/#ejemplo","text":"int main ( void ){ /*definimos una estructura en C llamada Point que contiene 2 variables de tipo entero. */ typedef struct { int x , y ; } Point ; Point p1 ; //se define una variable de tipo Point llamada p1 //asignanci\u00f3n de valores a las variables x y y de la variable p1. p1 . x = 2 ; p1 . y = 4 ; return 0 ; }","title":"Ejemplo:"},{"location":"notes/01_C/#punteros-en-c","text":"Un puntero es una variable la cual guarda la direcci\u00f3n de memoria de otra variable o de alg\u00fan dato. Es necesario al igual que una simple variable asignar el tipo que representa.","title":"Punteros en c"},{"location":"notes/01_C/#ejemplo_1","text":"int * pi ; //declaraci\u00f3n de un puntero de datos enteros. char * pc ; //declaraci\u00f3n de un puntero d\u00e9 datos tipo char.","title":"Ejemplo:"},{"location":"notes/01_C/#ejemplo-puntero-de-tipo-arbitrario","text":"//definici\u00f3n de un puntero el cual puede ser asignado a diferentes tipos. void * vp ; Podemos incluso definir un puntero que apunta a un puntero","title":"Ejemplo: Puntero de tipo arbitrario."},{"location":"notes/01_C/#ejemplo-puntero-de-punteros","text":"//definici\u00f3n una variable, un puntero que apunta a ella, y un puntero que apunta a este puntero char c = '1' ; char * p = & c ; char ** args = & p ;","title":"Ejemplo: Puntero de Punteros"},{"location":"notes/01_C/#ejemplo-asiginar-valores-usando-punteros","text":"int x = 10 ; int * pi = & x ; //al puntero pi se le asigna la direcci\u00f3n de memoria de la variable x. int valorx = * pi ; // en la variable valorx se almacena el valor al cual apunta la variable pi, en este ejemplo es 10 C pasa los argumentos a una funci\u00f3n por valor, esto quiere decir que la informaci\u00f3n de la variable que se recibe en la funci\u00f3n es almacenada en una diferente direcci\u00f3n de memoria por lo tanto si la variable se altera dentro de la funci\u00f3n, solo ser\u00e1 modificada en el contexto de la funci\u00f3n. Para poder modificar el valor de una variable x declarada en una funci\u00f3n A desde una funci\u00f3n B , enviamos un puntero que apunta a x como argumento a la funci\u00f3n B :","title":"Ejemplo: Asiginar Valores Usando Punteros"},{"location":"notes/01_C/#ejemplo_2","text":"void addOne ( int * x ){ ( * x ) ++ ; } int functionA (){ int x = 10 ; addOne ( & x ); return x ; } Noten el usuo de los par\u00e9ntesis, sin los par\u00e9ntesis, aumentariamos en 1 el puntero, pero al agregarlos, aumentamos en 1 el valor al que apunta el puntero","title":"Ejemplo:"},{"location":"notes/01_C/#manejo-de-memoria-en-c","text":"Podemos diferenciar varias estructuras de memoria existentes al momento de ejecutar un programa: - \u00c0rea de Texto: Almacena las instrucciones que estamos ejecutando - \u00c0rea de Datos: Almacena datos como numeros y strings que son constantes globales en nuestro programa - Stack: Almacena datos estaticos como variables, arreglos de tama\u00f1o predefinito, etc. Estos datos tienen la caracteristica de que no existen en todo momento de la ejecuci\u00f3n del programa. Por ejemplo, una variable x definida en cierta funci\u00f3n solo existir\u00e1 cuando esa funci\u00f3n se este ejecutando. Algunas cosas a tomar en cuenta sobre el stack, aunque no las veremos directamente en C, son las siguientes: - Tiene 3 operaciones b\u00e1sicas de un stack: push, pop, top (observar que hay) - CUIDADO con la ubicacion del Stack; en assembler veremos que el Stack crece habia abajo , lo que significa que cuando agregamos un dato, la direcci\u00f3n de memoria disminuye - A nivel ensamblador existe un registro llamado Stack Pointer o SP . Probablemente el registro m\u00e1s usado en assembler - Las variables locales y los par\u00e1metros de las funciones se guardan en el Stack - La direcci\u00f3n de retorno tambien se guarda en el Stack - El compilador es el que se encarga de pedir memoria en cada llamada y devolverla cuando se termina, es decir, el Stack es \"transparente\" al programador de C Heap: Almacena datos din\u00e1micos , como por ejemplo, un arreglo del tama\u00f1o indicado por el usuario. En C, el Heap es la unica estructura de memoria que es administrada directamente por el programador (reservar, liberar y respetar el espacio asignado). El heap, a diferencia del Stack, crece a direcciones de memorias m\u00e1s altas.","title":"Manejo de Memoria en C"},{"location":"notes/01_C/#manejo-del-heap","text":"funci\u00f3n malloc() : los devuelve un bloque de memoria. No los inicializa con ning\u00fan valor. ptr = ( cast - type * ) malloc ( byte - size ) // prt es un puntero #### Ejemplo // ptr es puntero a un \"bloque\" de 100 enteros. ptr = ( int * ) malloc ( 100 * sizeof ( int )); funci\u00f3n calloc() : bloque de memoria inicializada con ceros. Es una operaci\u00f3n lenta. Evitar usarla en cuanto sea posible. funci\u00f3n free() : libera un bloque de memoria que previamente pedimos. cuidado con usar malloc sin el free. \"Aqu\u00ed no hay garbage collector\" Puede ser lento buscar espacio disponible Recordar que manejar el heap es tarea del programador.","title":"Manejo del Heap"},{"location":"notes/01_C/#uso-de-valgrid","text":"Se puede descargar de: http://valgrind.org/ - Ayuda a la depuraci\u00f3n de problemas de memoria. Puede servir para detectar problemas como fugas de memoria (memory leak).","title":"Uso de Valgrid"},{"location":"notes/01_C/#clasificacion-de-bugs","text":"Bohr Bugs sabemos en precisamente en donde est\u00e1 (como los electones en el modelo at\u00f3mico de Bohr) F\u00e1ciles de reproducir Heinsenbugs Dif\u00edciles de diagnosticar Dificiles de reproducir","title":"Clasificaci\u00f3n de Bugs"},{"location":"notes/02_Intro-RISCV/","text":"Introducci\u00f3n a RISC V \u00b6 Estos son algunos de los t\u00e9rminos m\u00e1s importantes de este tema: - ISA (probablemente uno de los t\u00e9rminos mas importantes del curso): Es el pegamento que une el hardware con el software . Una especie de \"contrato\" que nos dice lo que s\u00ed podemos hacer porque tiene un soporte por el hardware . El ISA o Instruction Set Architecture es el set de instrucciones reales soportadas por el procesador sobre el que estamos trabajando. - RISC: Reduced Instruction Set Computer - Un ejemplo de procesadores RISC son los procesadores MIPS, ARM y RISC-V. - Este tipo de procesadores utiliza muchos regitros (32 registros de 32 bits cada uno, por ejemplo) - Se caracteriza por tener pocas instrucciones, siendo todas de un tama\u00f1o fijo (32 bits, por ejemplo) - Existen pocas instrucciones para acceder a memoria, (2 basicamente: lw y sw ) - La base de los procesadores RISC es soportar pocas instrucciones, pero hacerlas muy eficientemente - CISC: Complex Instruction Set Computer - x86 x86_64 (Intel) - Este tipo de procesadores utiliza pocos regitros - Soporta una cantidad de instrucciones mucho mayor a los procesadores RISC, y muchas de estas instrucciones no son de un tama\u00f1o fijo - La base de los procesadores CISC es soportar la mayor cantidad de instrucciones posibles para darle multiples opciones a los desarrolladores \u00bfQu\u00e9 es RISC-V? \u00b6 RISC-V es la quinta versi\u00f3n de procesadores RISC dise\u00f1ador por Berkeley De licencia libre Los registros son \u00a1muy! r\u00e1pidos (y caros) y se encuentran dentro del procesador Tiene un formato rigido: operacion registro_destino registro_fuente1 registro_fuente2 Esta es la distribuci\u00f3n de registros utilizada en procesadores RISC-V (nombrados del x0 al x31): Registros Nombre Funci\u00f3n x0 ZERO Alambrado a tierra. x0 siempre contiene el valor 0x00000000 x1 RA Return Address: Contiene la direcci\u00f3n de retorno de la funci\u00f3n actual x2 SP Stack Pointer: Es un puntero a la cabeza del Stack x3 GP Global Pointer: Es un puntero a la secci\u00f3n global de Data x4 TP Thread Pointer: No lo utiilizaremos en este curso, pero cabe mencionar su existencia x5-x7 t0-t2 Temporaries: Registros de proposito general que no se conservan en llamadas a funciones x8 s0/fp Saved Register (Frame Pointer): Registro seguro , se debe conservar su valor entre llamadas. El frame pointer contiene la direcci\u00f3n justo antes de la llamada a una funci\u00f3n. Sirve para regresar el stack a su posici\u00f3n original al regresar de una funci\u00f3n x9 s1 Saved Register: Registro seguro de prop\u00f3sito general, se debe conservar su valor entre llamadas x10-x11 a0-a1 Function Arguments & Return Values: Registros utilizados para enviar argumentos en las llamadas a funciones. Tambien son usados como valor de retorno de las funciones x12-x17 a2-a7 Function Arguments: Registros utilizados para enviar argumentos en las llamadas a funciones x18-x27 s2-s11 Saved Registers: Registros seguros de prop\u00f3sito general, se debe conservar su valor entre llamadas x28-x31 t3-t6 Temporaries: Registros de proposito general que no se conservan en llamadas a funciones Algunos Ejemplos en RISC-V \u00b6 Convertir un ciclo a Ensamblador en RISC-V \u00b6 int a [ 20 ]; int sum = 0 ; for ( int i = 0 ; i < 20 ; i ++ ){ sum += a [ i ]; } # Asumimos A = x8 addi x5, x0, 0 # sum = 0 addi x6, x0, 0 # i = 0 addi x28, x0, 20 # x28 = 20 Condition: blt x6, x28, For # Evaluamos la condici\u00f3n antes de empezar el ciclo j EndFor # Si es falsa terminamos el ciclo For: lw x7, 0(x8) add x5, x5, x7 # sum+=A[i] addi x8, x8, 4 # A++ \u00bfPor qu\u00e9 +4? addi x6, x6, 1 # i++ j Condition EndFor: Partes de un Ciclo \u00b6 Inicializaci\u00f3n: fuera del ciclo Condici\u00f3n: para go to step, while y for queremos queremos un true para seguir. False para detenernos Instrucciones: \u00bfqu\u00e9 me pide el problema? Step: un peque\u00f1o cambio entre una iteraci\u00f3n y otra, se relaciona con la condici\u00f3n. Funciones \u00b6 Entre llamadas a funciones, pueden haber muchos valores que se sobreescriben. Una soluci\u00f3n simple a este problema es guardar estos valores en el Stack. Antes de hacer una llamada a una funci\u00f3n, el caller debe almacenar valores como los argumentos recibidos (si es que recibio alguno), su return address , y los valores que desee preservar en registros seguros (guardando el contenido actual de estos registros antes de sobreescribirlo). Es importante mencionar que, cualquier espacio reservado en el stack al inicio de una funci\u00f3n, debe ser liberado antes de retornar de ella. Esto garantiza que cuando se regrese a la funci\u00f3n anterior, el stack quedar\u00e1 en la misma posici\u00f3n de antes de ejecutar la funci\u00f3n. Ejemplo Funci\u00f3n \u00b6 La siguiente funci\u00f3n en C int sum ( int x , int y ){ return x + y ; } Se traduce a function_sum: add a0, a0, a1 #los argumentos vienen en a0 y a1, y el valor de retorno se devuelve en a0 jr ra #sabemos que ra tiene la direcci\u00f3n de retorno Ahora veamos como se codifica la llamada a esta funci\u00f3n int x = 1 ; int y = 1 ; sum ( x , y ); addi a0, zero, 1 #int x = 1 addi a1, zero, 1 #int y = 1 addi sp, sp, -12 #reservamos espacio en el stack para las variables y el return address sw ra, 0(sp) # sw s0, 4(sp) #guardamos los registros en el stack sw s1, 8(sp) # add s0, a0, zero add s1, a1, zero #guardamos los valores de las variables el registros seguros para no perderlos jal function_sum #saltamos a la funcion add t0, zero, a0 #nuestro valor de retorno esta en a0, lo pasamos a cualquier otro registro add a0, zero, s0 #restauramos nuestra variable x en a0 add a1, zero, s1 #restauramos nuestra variable y en a1 lw ra, 0(sp) # lw s0, 4(sp) #restauramos los registros seguros y el return address lw s1, 8(sp) # addi sp, sp, 12 #regresamos el stack a la posici\u00f3n original","title":"RISC-V"},{"location":"notes/02_Intro-RISCV/#introduccion-a-risc-v","text":"Estos son algunos de los t\u00e9rminos m\u00e1s importantes de este tema: - ISA (probablemente uno de los t\u00e9rminos mas importantes del curso): Es el pegamento que une el hardware con el software . Una especie de \"contrato\" que nos dice lo que s\u00ed podemos hacer porque tiene un soporte por el hardware . El ISA o Instruction Set Architecture es el set de instrucciones reales soportadas por el procesador sobre el que estamos trabajando. - RISC: Reduced Instruction Set Computer - Un ejemplo de procesadores RISC son los procesadores MIPS, ARM y RISC-V. - Este tipo de procesadores utiliza muchos regitros (32 registros de 32 bits cada uno, por ejemplo) - Se caracteriza por tener pocas instrucciones, siendo todas de un tama\u00f1o fijo (32 bits, por ejemplo) - Existen pocas instrucciones para acceder a memoria, (2 basicamente: lw y sw ) - La base de los procesadores RISC es soportar pocas instrucciones, pero hacerlas muy eficientemente - CISC: Complex Instruction Set Computer - x86 x86_64 (Intel) - Este tipo de procesadores utiliza pocos regitros - Soporta una cantidad de instrucciones mucho mayor a los procesadores RISC, y muchas de estas instrucciones no son de un tama\u00f1o fijo - La base de los procesadores CISC es soportar la mayor cantidad de instrucciones posibles para darle multiples opciones a los desarrolladores","title":"Introducci\u00f3n a RISC V"},{"location":"notes/02_Intro-RISCV/#que-es-risc-v","text":"RISC-V es la quinta versi\u00f3n de procesadores RISC dise\u00f1ador por Berkeley De licencia libre Los registros son \u00a1muy! r\u00e1pidos (y caros) y se encuentran dentro del procesador Tiene un formato rigido: operacion registro_destino registro_fuente1 registro_fuente2 Esta es la distribuci\u00f3n de registros utilizada en procesadores RISC-V (nombrados del x0 al x31): Registros Nombre Funci\u00f3n x0 ZERO Alambrado a tierra. x0 siempre contiene el valor 0x00000000 x1 RA Return Address: Contiene la direcci\u00f3n de retorno de la funci\u00f3n actual x2 SP Stack Pointer: Es un puntero a la cabeza del Stack x3 GP Global Pointer: Es un puntero a la secci\u00f3n global de Data x4 TP Thread Pointer: No lo utiilizaremos en este curso, pero cabe mencionar su existencia x5-x7 t0-t2 Temporaries: Registros de proposito general que no se conservan en llamadas a funciones x8 s0/fp Saved Register (Frame Pointer): Registro seguro , se debe conservar su valor entre llamadas. El frame pointer contiene la direcci\u00f3n justo antes de la llamada a una funci\u00f3n. Sirve para regresar el stack a su posici\u00f3n original al regresar de una funci\u00f3n x9 s1 Saved Register: Registro seguro de prop\u00f3sito general, se debe conservar su valor entre llamadas x10-x11 a0-a1 Function Arguments & Return Values: Registros utilizados para enviar argumentos en las llamadas a funciones. Tambien son usados como valor de retorno de las funciones x12-x17 a2-a7 Function Arguments: Registros utilizados para enviar argumentos en las llamadas a funciones x18-x27 s2-s11 Saved Registers: Registros seguros de prop\u00f3sito general, se debe conservar su valor entre llamadas x28-x31 t3-t6 Temporaries: Registros de proposito general que no se conservan en llamadas a funciones","title":"\u00bfQu\u00e9 es RISC-V?"},{"location":"notes/02_Intro-RISCV/#algunos-ejemplos-en-risc-v","text":"","title":"Algunos Ejemplos en RISC-V"},{"location":"notes/02_Intro-RISCV/#convertir-un-ciclo-a-ensamblador-en-risc-v","text":"int a [ 20 ]; int sum = 0 ; for ( int i = 0 ; i < 20 ; i ++ ){ sum += a [ i ]; } # Asumimos A = x8 addi x5, x0, 0 # sum = 0 addi x6, x0, 0 # i = 0 addi x28, x0, 20 # x28 = 20 Condition: blt x6, x28, For # Evaluamos la condici\u00f3n antes de empezar el ciclo j EndFor # Si es falsa terminamos el ciclo For: lw x7, 0(x8) add x5, x5, x7 # sum+=A[i] addi x8, x8, 4 # A++ \u00bfPor qu\u00e9 +4? addi x6, x6, 1 # i++ j Condition EndFor:","title":"Convertir un ciclo a Ensamblador en RISC-V"},{"location":"notes/02_Intro-RISCV/#partes-de-un-ciclo","text":"Inicializaci\u00f3n: fuera del ciclo Condici\u00f3n: para go to step, while y for queremos queremos un true para seguir. False para detenernos Instrucciones: \u00bfqu\u00e9 me pide el problema? Step: un peque\u00f1o cambio entre una iteraci\u00f3n y otra, se relaciona con la condici\u00f3n.","title":"Partes de un Ciclo"},{"location":"notes/02_Intro-RISCV/#funciones","text":"Entre llamadas a funciones, pueden haber muchos valores que se sobreescriben. Una soluci\u00f3n simple a este problema es guardar estos valores en el Stack. Antes de hacer una llamada a una funci\u00f3n, el caller debe almacenar valores como los argumentos recibidos (si es que recibio alguno), su return address , y los valores que desee preservar en registros seguros (guardando el contenido actual de estos registros antes de sobreescribirlo). Es importante mencionar que, cualquier espacio reservado en el stack al inicio de una funci\u00f3n, debe ser liberado antes de retornar de ella. Esto garantiza que cuando se regrese a la funci\u00f3n anterior, el stack quedar\u00e1 en la misma posici\u00f3n de antes de ejecutar la funci\u00f3n.","title":"Funciones"},{"location":"notes/02_Intro-RISCV/#ejemplo-funcion","text":"La siguiente funci\u00f3n en C int sum ( int x , int y ){ return x + y ; } Se traduce a function_sum: add a0, a0, a1 #los argumentos vienen en a0 y a1, y el valor de retorno se devuelve en a0 jr ra #sabemos que ra tiene la direcci\u00f3n de retorno Ahora veamos como se codifica la llamada a esta funci\u00f3n int x = 1 ; int y = 1 ; sum ( x , y ); addi a0, zero, 1 #int x = 1 addi a1, zero, 1 #int y = 1 addi sp, sp, -12 #reservamos espacio en el stack para las variables y el return address sw ra, 0(sp) # sw s0, 4(sp) #guardamos los registros en el stack sw s1, 8(sp) # add s0, a0, zero add s1, a1, zero #guardamos los valores de las variables el registros seguros para no perderlos jal function_sum #saltamos a la funcion add t0, zero, a0 #nuestro valor de retorno esta en a0, lo pasamos a cualquier otro registro add a0, zero, s0 #restauramos nuestra variable x en a0 add a1, zero, s1 #restauramos nuestra variable y en a1 lw ra, 0(sp) # lw s0, 4(sp) #restauramos los registros seguros y el return address lw s1, 8(sp) # addi sp, sp, 12 #regresamos el stack a la posici\u00f3n original","title":"Ejemplo Funci\u00f3n"},{"location":"notes/03_Instruction-Format/","text":"RISC V Instruction Formats \u00b6 Gran idea: almacenar los programas en la computadora (Programa almacenado) \u00a1Lectura recomendada: https://es.wikipedia.org/wiki/John_von_Neumann ! Nacen dos grandes arquitecturas: Harvard (instrucciones y datos separados) Von Neumann (programas y datos en una memoria en com\u00fan) Program counter: alambrado a un sumador para moverse de 4 en 4 (que es el tama\u00f1o de instruccci\u00f3n) \u00f3 cuando hay saltos. \u00bfqu\u00e9 pasa con los programas que se distriuyen en forma binaria? 6 tipos b\u00e1sicos de instrucciones: R: operaciones aritm\u00e9ticas con dos registros I: operaciones con valores inmediatos S: para stores B: para branch's U: para upper immediate (20 bits) J: para jump Formato R \u00b6 32 bits dividido en 6 campos (7,5,5,3,5,7 bits respectivamente) funct7 rs2 rs1 funct3 rd opcode 7 bits 5 bits 5 bits 3 bits 5 bits 7 bits el opcode nos especifica parcialmente que instrucci\u00f3n es funct7 + funct3: combinado con el opcode, decriben que operaci\u00f3n hacer. Las tipo I y las R tienen el mismo funct3 Formato I \u00b6 imm rs1 funct3 rd opcode 12 bits 5 bits 3 bits 5 bits 7 bits imm puede tener valores en el rango [-2048, 2047] Las instrucciones load son tipo I Formato S \u00b6 imm[5:11] rs2 rs1 function3 imm[0:4] opcode 7 bits 5 bits 5 bits 3 bits 5 bits 7 bits A pesar de que en assembler los loads y stores son similares, en lenguaje de m\u00e1quina son dos tipos diferentes de instrucciones. Esto se debe a que los stores no tienen registro destino La raz\u00f3n por la que los 5 bits menos significativos del valor inmediato est\u00e1n donde estan, es para mantener rs1 y rs2 en las mismas posiciones Formato J \u00b6 imm[20] imm[10:1] imm[11] imm[19:12] rd opcode 1 bits 10 bits 1 bits 8 bits 5 bits 7 bits Formato B \u00b6 imm[12] imm[10:5] rs2 rs1 func3 imm[4:1] imm[11] opcode 1 bit 6 bits 5 bits 5 bits 3 bits 4 bits 1 bit 7 bits El valor inmediato representa la cantidad de halfwords (2 bytes) que se van a saltar, en representaci\u00f3n complemento a 2. Se utilizan halfwords y no words para mantener compatibilidad con la versi\u00f3n reducida de de RISC-V que utiliza instrucciones de 16 bits.","title":"Formato de instrucciones"},{"location":"notes/03_Instruction-Format/#risc-v-instruction-formats","text":"Gran idea: almacenar los programas en la computadora (Programa almacenado) \u00a1Lectura recomendada: https://es.wikipedia.org/wiki/John_von_Neumann ! Nacen dos grandes arquitecturas: Harvard (instrucciones y datos separados) Von Neumann (programas y datos en una memoria en com\u00fan) Program counter: alambrado a un sumador para moverse de 4 en 4 (que es el tama\u00f1o de instruccci\u00f3n) \u00f3 cuando hay saltos. \u00bfqu\u00e9 pasa con los programas que se distriuyen en forma binaria? 6 tipos b\u00e1sicos de instrucciones: R: operaciones aritm\u00e9ticas con dos registros I: operaciones con valores inmediatos S: para stores B: para branch's U: para upper immediate (20 bits) J: para jump","title":"RISC V Instruction Formats"},{"location":"notes/03_Instruction-Format/#formato-r","text":"32 bits dividido en 6 campos (7,5,5,3,5,7 bits respectivamente) funct7 rs2 rs1 funct3 rd opcode 7 bits 5 bits 5 bits 3 bits 5 bits 7 bits el opcode nos especifica parcialmente que instrucci\u00f3n es funct7 + funct3: combinado con el opcode, decriben que operaci\u00f3n hacer. Las tipo I y las R tienen el mismo funct3","title":"Formato R"},{"location":"notes/03_Instruction-Format/#formato-i","text":"imm rs1 funct3 rd opcode 12 bits 5 bits 3 bits 5 bits 7 bits imm puede tener valores en el rango [-2048, 2047] Las instrucciones load son tipo I","title":"Formato I"},{"location":"notes/03_Instruction-Format/#formato-s","text":"imm[5:11] rs2 rs1 function3 imm[0:4] opcode 7 bits 5 bits 5 bits 3 bits 5 bits 7 bits A pesar de que en assembler los loads y stores son similares, en lenguaje de m\u00e1quina son dos tipos diferentes de instrucciones. Esto se debe a que los stores no tienen registro destino La raz\u00f3n por la que los 5 bits menos significativos del valor inmediato est\u00e1n donde estan, es para mantener rs1 y rs2 en las mismas posiciones","title":"Formato S"},{"location":"notes/03_Instruction-Format/#formato-j","text":"imm[20] imm[10:1] imm[11] imm[19:12] rd opcode 1 bits 10 bits 1 bits 8 bits 5 bits 7 bits","title":"Formato J"},{"location":"notes/03_Instruction-Format/#formato-b","text":"imm[12] imm[10:5] rs2 rs1 func3 imm[4:1] imm[11] opcode 1 bit 6 bits 5 bits 5 bits 3 bits 4 bits 1 bit 7 bits El valor inmediato representa la cantidad de halfwords (2 bytes) que se van a saltar, en representaci\u00f3n complemento a 2. Se utilizan halfwords y no words para mantener compatibilidad con la versi\u00f3n reducida de de RISC-V que utiliza instrucciones de 16 bits.","title":"Formato B"},{"location":"notes/04_CALL/","text":"Compiling, Assembling, Linking and Loading (CALL) \u00b6 Notas Importantes: Multiplicaci\u00f3n y Divisi\u00f3n \u00b6 La multiplicaci\u00f3n de enteros de n bytes puede generar enteros de hasta 2n bytes La multiplicaci\u00f3n es una operaci\u00f3n mucho m\u00e1s costosa que la suma RISC-V maneja la multiplicaci\u00f3n de la siguiente forma: mul rd, rs1, rs2 multiplica rs1 y rs2 y deja la parte baja del resultado en rd , mulh rd, rs1, rs2 multiplica rs1 y rs2 y deja la parte alta del resultado en rd . Para la divisi\u00f3n existen tambien dos operaciones: div rd, rs1, rs2 que realiza la divisi\u00f3n entera rs1/rs2 y coloca el resultado en rd , y rem rd, rs1, rs2 qye realiza una divisi\u00f3n entera rs1/rs2 y coloca el residuo en rd Interpretaci\u00f3n vs Traducci\u00f3n \u00b6 Un programa en lenguajes compilados, como C, tiene los siguientes niveles de representaci\u00f3n: Stack de Traducci\u00f3n Lenguaje de Alto Nivel: C Lenguaje Ensamblador: RISC-V Assembler C\u00f3digo de M\u00e1quina: RISC-V Machine Code Hardware: Compuertas L\u00f3gicas, Transistores Ventajas de Traducci\u00f3n \u00b6 Se hace unicamente una vez Es muy rapida en tiempo de ejecuci\u00f3n Nos da cierto nivel de privacidad en el c\u00f3digo fuente: podemos distribuir unicamente el archivo ya compilado Ventajas de Interpretaci\u00f3n \u00b6 No se necesita compilarlo m\u00f3s de una vez para una arquitectura y sistema operativo particulares No se tiene que recompilar el archivo luego de hacer un cambio Un archivo corre sobre todas las combinaciones de sistema operativo y arquitectura siempre que se tenga el interprete instalado","title":"CALL"},{"location":"notes/04_CALL/#compiling-assembling-linking-and-loading-call","text":"","title":"Compiling, Assembling, Linking and Loading (CALL)"},{"location":"notes/04_CALL/#notas-importantes-multiplicacion-y-division","text":"La multiplicaci\u00f3n de enteros de n bytes puede generar enteros de hasta 2n bytes La multiplicaci\u00f3n es una operaci\u00f3n mucho m\u00e1s costosa que la suma RISC-V maneja la multiplicaci\u00f3n de la siguiente forma: mul rd, rs1, rs2 multiplica rs1 y rs2 y deja la parte baja del resultado en rd , mulh rd, rs1, rs2 multiplica rs1 y rs2 y deja la parte alta del resultado en rd . Para la divisi\u00f3n existen tambien dos operaciones: div rd, rs1, rs2 que realiza la divisi\u00f3n entera rs1/rs2 y coloca el resultado en rd , y rem rd, rs1, rs2 qye realiza una divisi\u00f3n entera rs1/rs2 y coloca el residuo en rd","title":"Notas Importantes: Multiplicaci\u00f3n y Divisi\u00f3n"},{"location":"notes/04_CALL/#interpretacion-vs-traduccion","text":"Un programa en lenguajes compilados, como C, tiene los siguientes niveles de representaci\u00f3n: Stack de Traducci\u00f3n Lenguaje de Alto Nivel: C Lenguaje Ensamblador: RISC-V Assembler C\u00f3digo de M\u00e1quina: RISC-V Machine Code Hardware: Compuertas L\u00f3gicas, Transistores","title":"Interpretaci\u00f3n vs Traducci\u00f3n"},{"location":"notes/04_CALL/#ventajas-de-traduccion","text":"Se hace unicamente una vez Es muy rapida en tiempo de ejecuci\u00f3n Nos da cierto nivel de privacidad en el c\u00f3digo fuente: podemos distribuir unicamente el archivo ya compilado","title":"Ventajas de Traducci\u00f3n"},{"location":"notes/04_CALL/#ventajas-de-interpretacion","text":"No se necesita compilarlo m\u00f3s de una vez para una arquitectura y sistema operativo particulares No se tiene que recompilar el archivo luego de hacer un cambio Un archivo corre sobre todas las combinaciones de sistema operativo y arquitectura siempre que se tenga el interprete instalado","title":"Ventajas de Interpretaci\u00f3n"},{"location":"projs/proj01/","text":"Proyecto 1: C y RISC-V \u00b6 Objetivos \u00b6 Mejorar sus habilidades de programaci\u00f3n en C. Conocer algunos de los detalles de RISC-V. Prepararse para lo que viene m\u00e1s adelante en el curso. Requisitos de Conocimiento \u00b6 Para realizar este proyecto ustedes tienen que tener claros algunos conceptos, de lo contrario ser\u00e1 bastante dif\u00edcil e inc\u00f3modo empezar a trabajar. Les recomendamos que antes de empezar est\u00e9n totalmente seguros que dominan al 100% los siguientes puntos: Operaciones binarias en C ( xor , or , and , etc). Operaciones aritm\u00e9ticas con signo y sin signo en C. Type casting en C. Control de flujo en C ( switch , if , etc). Funciones en C. Entender qu\u00e9 son las estructuras ( struct ) en C. Entender c\u00f3mo funcionan las uniones ( union ) en C. Uso correcto de printf . Entender la estructura del set de instrucciones de RISC-V. Programar en lenguaje ensamblador RISC-V. Si creen que no tienen claro alguno de estos temas al 100%, por favor no duden en ir a consultar los libros y material correspondiente del curso, por ejemplo K&R , es indispensable. En Lecturas Recomendadas pueden encontrar algunas lecturas que tocan los puntos antes mencionados y otras cosas que tambi\u00e9n les pueden servir, nunca est\u00e1 dem\u00e1s tener un poco m\u00e1s de informaci\u00f3n. Lecturas Recomendadas \u00b6 Gu\u00eda Pr\u00e1ctica de RISC-V: 2 K&R: 6 P&H: B-43 Introducci\u00f3n \u00b6 En este proyecto ustedes deben de crear un emulador que pueda ejecutar un subconjunto de instrucciones de RISC-V . Ustedes se van a encargar de hacer un programa que decodifique y ejecute varias instrucciones de RISC-V. Consid\u00e9renlo como una versi\u00f3n miniatura de V-Sim . RISC-V Green Card \u00b6 Aqu\u00ed hay dos RISC-V Green Cards que pueden consultar y as\u00ed tener m\u00e1s herramientras que les pueden ayudar a completar el proyecto. La primera tiene informaci\u00f3n acerca de los opcodes y otros campos de cada uno de los diferentes formatos de instrucci\u00f3n, por lo que esta ser\u00eda su mejor opci\u00f3n. Preparaci\u00f3n \u00b6 Antes de comenzar aseg\u00farense de que hayan le\u00eddo y comprendido todas las instrucciones del proyecto de principio a fin . Si tienen alguna pregunta pueden consultar la secci\u00f3n de preguntas frecuentes para ver si ya ha sido resuelta, de lo contrario por favor dir\u00edjanse a Slack y pregunten en los canales correspondientes. Para comenzar con el proyecto, primero tienen que tener todos los archivos base, estos se encuentran aqu\u00ed . Tienen permitido trabajar en parejas o de forma individual, por lo que al aceptar la asignaci\u00f3n les preguntar\u00e1 si desean crear un grupo nuevo o unirse a uno ya existente. Si crean un grupo nuevo, ingresen un nombre que represente al grupo y que no est\u00e9 ya en los grupos existentes. Si desean unirse a un grupo ya creado, tienen que buscar el nombre del grupo y pulsar el bot\u00f3n que dice join Tienen que tener mucho cuidado al unirse a un grupo ya existente, ya que esto no se puede cambiar despu\u00e9s, adem\u00e1s lo consideraremos como PLAGIO si lo realizan de manera incorrecta, ya que al hacer esto pueden tener acceso al repositorio del otro miembro del grupo. Ya sea que se unan o creen un nuevo grupo, al finalizar el proceso les crear\u00e1 autom\u00e1ticamente un repositorio con una extensi\u00f3n que termina con su nombre de grupo. Ya habiendo hecho todo eso, pueden ejecutar los siguientes comandos abriendo una terminal ( CTRL + T ): git clone <link del repositorio> NOTA : Tienen que reemplazar <link del repositorio> con el link del repositorio que se cre\u00f3. Estructura del Proyecto \u00b6 Cuando hayan clonado el repositorio, se van a encontrar con los siguientes archivos: Makefile part1.c part2.c README.md riscv.c riscvcode/ riscv.h submit types.h utils.c utils.h Los \u00fanicos archivos que pueden modificar son: part1.c : Este es el archivo que van a modificar en la parte 1 del proyecto. utils.c : Archivo auxiliar que contendr\u00e1 varias funciones de ayuda para la parte 1 y 2 del proyecto. part2.c : Este es el archivo que van a modificar en la parte 2 del proyecto. Ustedes NO pueden crear otros archivos ni crear archivos de cabecera .h . Si necesitan agregar funciones de ayuda, por favor col\u00f3quenlas en los archivos C correspondientes ( utils.c , part1.c , part2.c ). Si ustedes no siguen estas recomendaciones, su c\u00f3digo no va a compilar en el autograder y obtendr\u00e1n 0 como nota . Otros archivos que necesitan consultar detenidamente para entender el proyecto: type.h : Archivo de cabecera que tiene los tipos de datos que ustedes van a utilizar. Makefile : Para compilar y probar su c\u00f3digo. riscvcode/* : Archivos para hacer algunas pruebas. utils.h : Archivo que contiene el formato de las instrucciones a ser utilizadas en la parte 1 del proyecto. Archivos que no es necesario que los revisen, pero si son curiosos: riscv.h : tiene declaraciones de funciones que se utilizan en la parte 1 y 2 del proyecto. riscv.c : programa encargado de probar la parte 1 y 2 del proyecto, el simulador como tal. El emulador de RISC-V \u00b6 Los archivos proporcionados en el repositorio que crearon con GitHub Classroom son la base para un emulador de RISC-V. Primero, ustedes deber\u00e1n agregar c\u00f3digo en part1.c y utils.c para imprimir las instrucciones en ensamblador correspondientes al c\u00f3digo de m\u00e1quina (binario). Una vez realizaron esto, ustedes completar\u00e1n el programa agregando c\u00f3digo en el archivo parte2.c para ejecutar cada instrucci\u00f3n (incluyendo los accesos a memoria). Su simulador debe de ser capaz de entender cada una de las instrucciones siguientes ya codificadas en c\u00f3digo de m\u00e1quina (binario), nosotros ya les damos una tabla de los tipos de instrucciones que debe de ser capaz de manejar su emulador. Es muy IMPORTANTE que ustedes lean y entiendan las definiciones encontradas en types.h antes de empezar su proyecto. Si tiene alguna duda, o encuentran algo que no entiendan respecto a las mismas consulten el cap\u00edtulo 6 de K&R, que habla sobre estructuras, bitfields y uniones . Set de Instrucciones \u00b6 El set de instrucciones que su emulador debe soportar esta listado a continuaci\u00f3n. Toda la informaci\u00f3n ac\u00e1 es copiada desde RISC-V green card , como ayuda adicional pueden utilizar la hoja proporcionada anteriormente. Tipo R \u00b6 FORMATO DE UNA INSTRUCCI\u00d3N DE TIPO R R-TYPE funct7 rs2 rs1 funct3 rd opcode Bits 7 5 5 3 5 7 INTRUCCIONES TIPO R (OPCODE 0x33) INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N add rd , rs1 , rs2 0x0 0x00 R [ rd ] < - R [ rs1 ] + R [ rs2 ] mul rd , rs1 , rs2 0x0 0x01 R [ rd ] < -( R [ rs1 ] * R [ rs2 ]) [31:0] sub rd , rs1 , rs2 0x0 0x20 R [ rd ] < - R [ rs1 ] - R [ rs2 ] sll rd , rs1 , rs2 0x1 0x00 R [ rd ] < - R [ rs1 ] < < R [ rs2 ] mulh rd , rs1 , rs2 0x1 0x01 R [ rd ] < -( R [ rs1 ] * R [ rs2 ]) [63:32] slt rd , rs1 , rs2 0x2 0x00 R [ rd ] < -( R [ rs1 ] < R [ rs2 ]) ? 1 : 0 xor rd , rs1 , rs2 0x4 0x00 R [ rd ] < - R [ rs1 ] ^ R [ rs2 ] div rd , rs1 , rs2 0x4 0x01 R [ rd ] < - R [ rs1 ] / R [ rs2 ] srl rd , rs1 , rs2 0x5 0x00 R [ rd ] < - R [ rs1 ] >> R [ rs2 ] sra rd , rs1 , rs2 0x5 0x20 R [ rd ] < - R [ rs1 ] >> R [ rs2 ] or rd , rs1 , rs2 0x6 0x00 R [ rd ] < - R [ rs1 ] | R [ rs2 ] rem rd , rs1 , rs2 0x6 0x01 R [ rd ] < - R [ rs1 ] % R [ rs2 ] and rd , rs1 , rs2 0x7 0x00 R [ rd ] < - R [ rs1 ] & R [ rs2 ] Tipo I \u00b6 FORMATO DE UNA INSTRUCCI\u00d3N DE TIPO I I-TYPE imm[11:0] rs1 funct3 rd opcode Bits 12 5 3 5 7 INTRUCCIONES TIPO I (OPCODE 0x03) INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N lb rd, offset ( rs1 ) 0x0 R [ rd ]<- SignExt(Mem( R [ rs1 ] + offset , byte )) lh rd, offset ( rs1 ) 0x1 R [ rd ]<- SignExt(Mem( R [ rs1 ] + offset , half )) lw rd, offset ( rs1 ) 0x2 R [ rd ]<- Mem( R [ rs1 ] + offset , word ) INTRUCCIONES TIPO I (OPCODE 0x13) INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N addi rd, rs1, imm 0x0 R [ rd ]<- R [ rs1 ] + imm slli rd, rs1, imm 0x1 0x00 R [ rd ]<- R [ rs1 ] << imm slti rd, rs1, imm 0x2 R [ rd ]<- ( R [ rs1 ] < imm ) ? 1 : 0 xori rd, rs1, imm 0x4 R [ rd ]<- R [ rs1 ] ^ imm srli rd, rs1, imm 0x5 0x00 R [ rd ]<- R [ rs1 ] >> imm srai rd, rs1, imm 0x5 0x20 R [ rd ]<- R [ rs1 ] >> imm ori rd, rs1, imm 0x6 R [ rd ]<- R [ rs1 ] | imm andi rd, rs1, imm 0x7 R [ rd ]<- R [ rs1 ] & imm INTRUCCIONES TIPO I (OPCODE 0x67) INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N jalr 0x0 R [ rd ]<- PC + 4 PC <- R [ rs1 ] + imm INTRUCCIONES TIPO I (OPCODE 0x73) INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N ecall 0x0 0x000 (Transfiere el control al Sistema Operativo) a0 = 1 imprime el valor contenido en a1 como entero. a0 = 10 es exit o un indicador de final de c\u00f3digo. Tipo S \u00b6 FORMATO DE UNA INSTRUCCI\u00d3N DE TIPO S S-TYPE imm[11:5] rs2 rs1 funct3 imm[4:0] opcode Bits 7 5 5 3 5 7 INTRUCCIONES TIPO S (OPCODE 0x23) INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N sb rs2 , offset ( rs1 ) 0x0 Mem( R [ rs1 ] + offset )<- R [ rs2 ][7:0] sh rs2 , offset ( rs1 ) 0x1 Mem( R [ rs1 ] + offset )<- R [ rs2 ][15:0] sw rs2 , offset ( rs1 ) 0x2 Mem( R [ rs1 ] + offset )<- R [ rs2 ] Tipo SB \u00b6 FORMATO DE UNA INSTRUCCI\u00d3N DE TIPO SB SB-TYPE imm[12] imm[10:5] rs2 rs1 funct3 imm[4:1] imm[11] opcode Bits 1 6 5 5 3 4 1 7 INTRUCCIONES TIPO SB (OPCODE 0x63) INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N beq rs1 , rs2 , offset 0x0 if( R [ rs1 ] == R [ rs2 ]) PC <- PC + { offset , 1b'0} bne rs1 , rs2 , offset 0x1 if( R [ rs1 ] != R [ rs2 ]) PC <- PC + { offset , 1b'0} Tipo U \u00b6 FORMATO DE UNA INSTRUCCI\u00d3N DE TIPO U U-TYPE imm[31:12] rd opcode Bits 20 5 7 INTRUCCIONES TIPO U (OPCODE 0x17) INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N auipc rd , offset R [ rd ]<- PC + { offset , 12b'0} INTRUCCIONES TIPO U (OPCODE 0x37) INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N lui rd , offset R [ rd ]<- { offset , 12b'0} Tipo UJ \u00b6 FORMATO DE UNA INSTRUCCI\u00d3N DE TIPO UJ UJ-TYPE imm[20] imm[10:1] imm[11] imm[19:12] rd opcode Bits 1 10 1 8 5 7 INTRUCCIONES TIPO UJ (OPCODE 0x6F) INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N jal rd , imm R [ rd ]<- PC + 4 PC <- PC + { imm , 1b'0} Al igual que la arquitectura RISC-V normal, el sistema RISC-V que est\u00e1n implementando es little-endian. Esto significa que cuando se le da un valor compuesto de m\u00faltiples bytes, el byte menos significativo se almacena en la direcci\u00f3n m\u00e1s baja. Consulten la p\u00e1gina B-43 de P&H (4\u00aa edici\u00f3n) para obtener informaci\u00f3n sobre endianness. Estructura del C\u00f3digo \u00b6 El c\u00f3digo base que les fue proporcionado funciona de la siguiente manera: Lee los programas en c\u00f3digo de m\u00e1quina que se encuentran en la memoria (Empezando en la direcci\u00f3n 0x01000 ). Para \"ejecutar\" el programa este es pasado como un par\u00e1metro en la l\u00ednea de comandos. Cada programa tiene 1 MiB de memoria y la unidad m\u00ednima de direccionamiento son los bytes. Todos los registros de RISC-V son inicializados en 0 y el program counter ( pc ) hacia la direcci\u00f3n 0x01000 . Las \u00fanicas excepciones a las inicializaciones antes mencionadas son el stack pointer ( sp ) que tiene un valor inicial de 0xEFFFF y el global pointer ( gp ) que tiene un valor inicial de 0x03000 . En el contexto de su emulador, el global pointer hace referencia a la secci\u00f3n est\u00e1tica de su memoria. Los registros y el program counter est\u00e1n definidos en el Processor struct definido en types.h . Se definieron banderas con las cuales puede manejar la interacci\u00f3n con el usuario. Dependiendo de la opci\u00f3n especificada en la l\u00ednea de comandos, el simulador mostrar\u00e1 un dissassembly dump ( -d ) o se ejecutar\u00e1 el programa. Habr\u00e1 m\u00e1s informaci\u00f3n sobre las opciones de l\u00ednea de comandos m\u00e1s adelante. Lo que prosigue es qu\u00e9 entra al flujo de simulaci\u00f3n principal, el cual ejecuta una \u00fanica instrucci\u00f3n repetitivamente hasta que la simulaci\u00f3n se completa. La ejecuci\u00f3n de una instrucci\u00f3n realiza las siguientes tareas: Trae una instrucci\u00f3n desde la memoria, usando el pc como direcci\u00f3n ( fetch ). Examina el opcode/funct3 para determinar que instrucci\u00f3n es ( decode ). Ejecuta la instrucci\u00f3n y actualiza el pc ( execute ). Opciones en la l\u00ednea de comandos \u00b6 -i : Corre el simulador en modo interactivo ( interactive ), es decir que se ejecutar\u00e1 una instrucci\u00f3n a la vez al presionar enter . Cada instrucci\u00f3n es mostrada en su forma desensamblada. -t : Corre el simulador en modo rastreo ( trace ), en donde cada instrucci\u00f3n es ejecutada y es mostrada al usuario. -r : Indica al simulador que imprima el contenido de los 32 registros despu\u00e9s de que es ejecutada cada instrucci\u00f3n. Esta opci\u00f3n es m\u00e1s \u00fatil cuando se combina con la opci\u00f3n -i . -d : Indica al simulador que desensamble el programa completo y que termine sin ejecutarlo. En la parte 2, ustedes deber\u00e1n implementar los siguientes m\u00e9todos: El execute_instruction() . Los diferentes executes . El store() . El load() . Para cuando ustedes hayan terminado la implementaci\u00f3n de todos los m\u00e9todos, el simulador ser\u00e1 capaz de manejar todas las instrucciones de la tabla anterior. Parte 1 \u00b6 Su primera tarea es implementar un desensamblador al completar el m\u00e9todo decode_instruction() en el archivo part1.c junto a otras funciones. El objetivo de esta parte, es que, dada una instrucci\u00f3n en c\u00f3digo de m\u00e1quina, ustedes deber\u00e1n traducirla a su instrucci\u00f3n en lenguaje ensamblador RISC-V (e.g. add x1, x2, x3 ). Para esta parte, ustedes no har\u00e1n referencia a los registros por nombre sino por su n\u00famero (como est\u00e1 definido en RISC-V Green Card ). Cuando impriman las instrucciones revisen las constantes definidas en utils.h , ya que estas le pueden ser de ayuda. M\u00e1s detalles sobre los requisitos a continuaci\u00f3n. Requisitos Parte 1 \u00b6 Imprimir el nombre de la instrucci\u00f3n. Si la instrucci\u00f3n tiene argumentos, impriman un tab ( \\t ). Imprimir todos los argumentos, siguiendo el orden y formato dado en la columna de INSTRUCCI\u00d3N de las tablas mostradas anteriormente. Los argumentos son generalmente separados por coma ( lw / sw , usan tambi\u00e9n par\u00e9ntesis), pero no est\u00e1n separados por espacios. Ustedes encontrar\u00e1n de ayuda revisar el archivo utils.h . Los registros que son argumentos de la instrucci\u00f3n son impresos con una x seguido del n\u00famero de registro, en decimal. (e.g. x0 o x31 ) Todos los inmediatos deben mostrarse como un n\u00famero decimal con signo. Los corrimientos (e.g. para slli ) se imprimen como n\u00fameros decimales sin signo (e.g. 0 a 31). Imprimir un salto de l\u00ednea ( \\n ) al final de cada instrucci\u00f3n. Se estar\u00e1 utilizando un autograder para calificar esta tarea. Si su output difiere del nuestro debido a errores de formato, no obtendr\u00e1n nota. Nosotros les proveemos ciertas pruebas. Sin embargo, dado que estas pruebas s\u00f3lo cubren un subconjunto de todos los escenarios posibles, pasar estas pruebas no significa que su c\u00f3digo est\u00e9 libre de errores. Ustedes deber\u00e1n identificar todos los casos y probarlos. Para completar la funcionalidad de la parte 1, deben de completar lo siguiente: La funci\u00f3n decode_instrucction() en part1.c . Los diferentes writes en part1.c . Los diferentes prints en part1.c . Los diferentes gets en utils.c . La funci\u00f3n bitSigner en utils.c . Ustedes deben de correr el test brindado para su proyecto escribiendo el siguiente comando. Si ustedes pasan el test, ver\u00e1n en su consola el siguiente output. make part1 gcc -g -Wall -Werror -Wfatal-errors -O2 -o riscv utils.c part1.c part2.c riscv.c simple_disasm TEST PASSED! multiply_disasm TEST PASSED! random_disasm TEST PASSED! ---------Disassembly Tests Complete--------- Probando la Parte 1 \u00b6 Los tests que se les dieron no eval\u00faan todas las posibilidades, por eso mismo ustedes pueden ( deben ) crear sus propios archivos de prueba para comprobar su funcionamiento. Si ustedes desean correr un test en espec\u00edfico, pueden usar el siguiente comando para ello: make [test_name]_disasm Para crear sus propios archivos de prueba, primero necesitar\u00e1n crear c\u00f3digo de m\u00e1quina. Para ello pueden ayudarse de V-Sim o hacerlo a mano. Si utilizan V-Sim tienen que crear un archivo .s y hacer un dump del c\u00f3digo de m\u00e1quina utilizando la bandera -code en la terminal: vsim <archivo>.s -code <test_name>.input Ustedes deben de poner las instrucciones en c\u00f3digo de m\u00e1quina en un archivo llamado [test_name].input y colocar el archivo dentro de la carpeta riscvcode/code . Despu\u00e9s, deben crear el archivo [test_name].solution el cual contendr\u00e1 las instrucciones que se espera obtener; y colocar el archivo en la carpeta riscvcode/ref . Vean las pruebas proporcionadas como ejemplos de este tipo de archivos. Para integrar sus pruebas en el comando make , ustedes deben de modificar el archivo Makefile . En la l\u00ednea 4 del archivo Makefile , donde dice ASM_TESTS , agregar [test_name] a la lista con espacios entre cada nombre de archivo: SOURCES := utils.c part1.c part2.c riscv.c HEADERS := types.h utils.h riscv.h ASM_TESTS := simple multiply random test_name Si su instrucci\u00f3n desensamblada no es igual a la esperada, ustedes obtendr\u00e1n la diferencia entre el output esperado y el output que devolvieron. Aseg\u00farense de al menos pasar esta prueba antes de enviar la parte 1 al autograder . # Output Esperado < 00001014 : lui x8, 1048575 --- # Output Devuelto > 00001014 : Invalid Instruction: 0xfffff437 Calificaci\u00f3n Parte 1 \u00b6 Recuerden que para la primera parte, s\u00f3lo deben modificar los archivos part1.c y utils.c , esto representa el 50% de su nota as\u00ed que pueden enviar sus archivos al autograder para verificar su nota de esta parte haciendo: ./submit <TOKEN> Si est\u00e1n trabajando en pareja, AMBOS miembros del grupo tienen que hacer el submit con su respectivo TOKEN . Parte 2 \u00b6 Su segunda tarea es completar el emulador implementando los m\u00e9todos execute_instruction() . execute() 's, store() y load() del archivo part2.c . Requisitos \u00b6 Esta parte consistir\u00e1 en implementar la funcionalidad de cada instrucci\u00f3n. Por favor implementen las funciones descritas a continuaci\u00f3n (todas en part2.c ): execute_instruction() : Ejecuta la instrucci\u00f3n proporcionada como par\u00e1metro. Esta deber\u00eda modificar los registros apropiados, realizar las llamadas a memoria necesarias y actualizar el program counter para apuntar a la siguiente instrucci\u00f3n a ejecutar. execute() 's: Varias funciones de ayuda para ser llamadas en ciertas condiciones para ciertas instrucciones. Es su decisi\u00f3n usar estas funciones, pero estas les ayudar\u00e1n de gran manera a organizar el c\u00f3digo. store() : Toma una direcci\u00f3n, un tama\u00f1o, un valor y almacena los primeros (tama\u00f1o) bytes del valor dado en la direcci\u00f3n dada. Cuando el par\u00e1metro check_align sea 1 se validar\u00e1n las restricciones de alineaci\u00f3n. Se incluy\u00f3 este par\u00e1metro para obligar a las instrucciones a estar alineadas por palabras de memoria (word-aligned). Cuando implementen el store y load , este par\u00e1metro debe ser 0 dado que RISC-V no hace cumplir las restricciones de alineaci\u00f3n. load() : Toma una direcci\u00f3n y un tama\u00f1o, y retorna los siguientes (tama\u00f1o) bytes empezando en la direcci\u00f3n dada. El check_align funciona de la misma forma que en store() . Probando la Parte 2 \u00b6 Les hemos adjuntado un self-checking assembly test que prueba varias de las instruciones, sin embargo este test no es exhaustivo y no prueba todas las instrucciones. A continuaci\u00f3n, se ejemplifica c\u00f3mo ejecutar los test (el output es de una soluci\u00f3n correcta). make part2 gcc -Wall -Werror -Wfatal-errors -O2 -o riscv utils.c part1.c part2.c riscv.c simple_execute TEST PASSED! multiply_execute TEST PASSED! random_execute TEST PASSED! -----------Execute Tests Complete----------- Lo m\u00e1s probable es que ustedes tenga errores al empezar a realizar la parte 2, entonces prueben el modo de rastreo ( trace ) descrito en Opciones en la l\u00ednea de Comandos . Les hemos dado unos cuantos tests m\u00e1s, adem\u00e1s de la posibilidad de escribir test propios. Como en la parte 1, ustedes tendr\u00e1n que crear archivos .input . Sin embargo, para la parte 2, ustedes deber\u00e1n nombrar su archivo soluci\u00f3n con una extensi\u00f3n .trace . Creen el nuevo archivo de ensamblador en el directorio riscvcode (utilicen riscvcode/simple.input como plantilla). Agreguen el nombre base del test a la lista de ASM_TESTS en el Makefile . Para realizar esto s\u00f3lo agreguen [test_name] al final de la l\u00ednea 4. Ahora compilen su test de ensamblador y ejec\u00fatenlo escribiendo el siguiente comando: make [ test_name ] _execute Ustedes pueden, y en efecto deben, escribir sus propios test para probar instrucciones espec\u00edficas y todos los posibles casos. Adem\u00e1s, ustedes deben compilar y probar su c\u00f3digo despu\u00e9s de cada grupo de instrucciones implementadas. De lo contrario ser\u00e1 muy dif\u00edcil probar su proyecto si esperan hasta el final. Calificaci\u00f3n Parte 2 \u00b6 Al completar esta parte ustedes s\u00f3lo deber\u00edan haber modificado los archivos part1.c , part2.c y utils.c , deben realizar commit de todos los cambios realizados y enviar el link de su repositorio por medio del GES. Para obtener su nota completa tienen que hacer: ./submit <TOKEN> Si est\u00e1n trabajando en pareja, AMBOS miembros del grupo tienen que hacer el submit con su respectivo TOKEN . Preguntas Frecuentes \u00b6 1. \u00bfC\u00f3mo puedo empezar? \u00b6 Lo mejor es revisar types.h y analizar la estructura Instruction para empezar a trabajar en la parte1.c , por ejemplo como acceder a cada campo de cada diferente tipo de instrucci\u00f3n y al opcode tambi\u00e9n. Por ejemplo, para acceder al opcode pueden utilizar: instruction . opcode siendo instruction una variable que representa una \"instancia\" de la estructura Instruction . Luego de esto, pueden ver c\u00f3mo accediendo a estos campos pueden decodificar la instrucci\u00f3n y as\u00ed lograr imprimirla. 2. En mi m\u00e1quina local saco 100% y en el autograder 0, \u00bfpor qu\u00e9? \u00b6 Al trabajar con uniones y estructuras de C y al utilizar la bandera -O2 pueden pasar cosas muy raras, una de ellas es el strict aliasing , por eso les recomendamos probar su c\u00f3digo en la m\u00e1quina virtual que les proporcionamos, as\u00ed est\u00e1n totalmente seguros de que c\u00f3digo funciona correctamente. 3. Me da Floating-point Exception (core dumped) al hacer algunas operaciones aritm\u00e9ticas, \u00bfpor qu\u00e9? \u00b6 Generalmente esto se da porque se divide por 0 o hay overflow utilizando variables enteras con signo. Por ejemplo: Division por 0 int x = 10 ; int y = 0 ; int z = x / y ; Overflow int32_t x = 0x80000000 ; int32_t y = 0xffffffff ; int32_t z = x / y ; La soluci\u00f3n para la divisi\u00f3n por 0 es simplemente tienen que devolver -1 como dice la especificaci\u00f3n de RISC-V y para el residuo devolver el primer argumento de la operaci\u00f3n. En el caso de overflow devolvemos rs1 para la division y 0 para el residuo. Division // division if ( rs2 == 0 ) { rd = - 1 ; // division entre cero } else if ( rs1 == 0x80000000 && rs2 == 0xffffffff ) { rd = rs1 ; // overflow } else { rd = rs1 / rs2 ; } Residuo // residuo if ( rs2 == 0 ) { rd = rs1 ; // residuo entre cero } else if ( rs1 == 0x80000000 && rs2 == 0xffffffff ) { rd = 0 ; // overflow } else { rd = rs1 % rs2 ; } 4. En la parte 1 el formato nunca es el esperado por las pruebas, \u00bfpor qu\u00e9? \u00b6 Seguramente no est\u00e1n utilizando el formato correcto, les recomendamos que utilicen las siguientes macros para imprimir las instrucciones que se encuentran en el archivo utils.h : #define RTYPE_FORMAT \"%s\\tx%d, x%d, x%d\\n\" #define ITYPE_FORMAT \"%s\\tx%d, x%d, %d\\n\" #define JALR_FORMAT \"jalr\\tx%d, x%d, %d\\n\" #define MEM_FORMAT \"%s\\tx%d, %d(x%d)\\n\" #define AUIPC_FORMAT \"auipc\\tx%d, %d\\n\" #define LUI_FORMAT \"lui\\tx%d, %d\\n\" #define JAL_FORMAT \"jal\\tx%d, %d\\n\" #define BRANCH_FORMAT \"%s\\tx%d, x%d, %d\\n\" #define ECALL_FORMAT \"ecall\\n\" 5. \u00bfPuedo crear mis propias funciones? \u00b6 S\u00ed, siempre y cuando estas est\u00e9n declaradas, ya sea en part1.c , part2.c o utils.c , ya que son los \u00fanicos archivos que se env\u00edan al autograder. Sin embargo, NO est\u00e1 permitido renombrar o eliminar las siguientes funciones : /* archivo part1.c */ void decode_instruction ( Instruction i ); /* archivo part2.c */ void execute_instruction ( Instruction instruction , Processor * processor , Byte * memory ); void store ( Byte * memory , Address address , Alignment alignment , Word value , int ); Word load ( Byte * memory , Address address , Alignment alignment , int ); Ya que el simulador riscv.c espera que estas est\u00e9n definidas.","title":"1: C y RISC-V"},{"location":"projs/proj01/#proyecto-1-c-y-risc-v","text":"","title":"Proyecto 1: C y RISC-V"},{"location":"projs/proj01/#objetivos","text":"Mejorar sus habilidades de programaci\u00f3n en C. Conocer algunos de los detalles de RISC-V. Prepararse para lo que viene m\u00e1s adelante en el curso.","title":"Objetivos"},{"location":"projs/proj01/#requisitos-de-conocimiento","text":"Para realizar este proyecto ustedes tienen que tener claros algunos conceptos, de lo contrario ser\u00e1 bastante dif\u00edcil e inc\u00f3modo empezar a trabajar. Les recomendamos que antes de empezar est\u00e9n totalmente seguros que dominan al 100% los siguientes puntos: Operaciones binarias en C ( xor , or , and , etc). Operaciones aritm\u00e9ticas con signo y sin signo en C. Type casting en C. Control de flujo en C ( switch , if , etc). Funciones en C. Entender qu\u00e9 son las estructuras ( struct ) en C. Entender c\u00f3mo funcionan las uniones ( union ) en C. Uso correcto de printf . Entender la estructura del set de instrucciones de RISC-V. Programar en lenguaje ensamblador RISC-V. Si creen que no tienen claro alguno de estos temas al 100%, por favor no duden en ir a consultar los libros y material correspondiente del curso, por ejemplo K&R , es indispensable. En Lecturas Recomendadas pueden encontrar algunas lecturas que tocan los puntos antes mencionados y otras cosas que tambi\u00e9n les pueden servir, nunca est\u00e1 dem\u00e1s tener un poco m\u00e1s de informaci\u00f3n.","title":"Requisitos de Conocimiento"},{"location":"projs/proj01/#lecturas-recomendadas","text":"Gu\u00eda Pr\u00e1ctica de RISC-V: 2 K&R: 6 P&H: B-43","title":"Lecturas Recomendadas"},{"location":"projs/proj01/#introduccion","text":"En este proyecto ustedes deben de crear un emulador que pueda ejecutar un subconjunto de instrucciones de RISC-V . Ustedes se van a encargar de hacer un programa que decodifique y ejecute varias instrucciones de RISC-V. Consid\u00e9renlo como una versi\u00f3n miniatura de V-Sim .","title":"Introducci\u00f3n"},{"location":"projs/proj01/#risc-v-green-card","text":"Aqu\u00ed hay dos RISC-V Green Cards que pueden consultar y as\u00ed tener m\u00e1s herramientras que les pueden ayudar a completar el proyecto. La primera tiene informaci\u00f3n acerca de los opcodes y otros campos de cada uno de los diferentes formatos de instrucci\u00f3n, por lo que esta ser\u00eda su mejor opci\u00f3n.","title":"RISC-V Green Card"},{"location":"projs/proj01/#preparacion","text":"Antes de comenzar aseg\u00farense de que hayan le\u00eddo y comprendido todas las instrucciones del proyecto de principio a fin . Si tienen alguna pregunta pueden consultar la secci\u00f3n de preguntas frecuentes para ver si ya ha sido resuelta, de lo contrario por favor dir\u00edjanse a Slack y pregunten en los canales correspondientes. Para comenzar con el proyecto, primero tienen que tener todos los archivos base, estos se encuentran aqu\u00ed . Tienen permitido trabajar en parejas o de forma individual, por lo que al aceptar la asignaci\u00f3n les preguntar\u00e1 si desean crear un grupo nuevo o unirse a uno ya existente. Si crean un grupo nuevo, ingresen un nombre que represente al grupo y que no est\u00e9 ya en los grupos existentes. Si desean unirse a un grupo ya creado, tienen que buscar el nombre del grupo y pulsar el bot\u00f3n que dice join Tienen que tener mucho cuidado al unirse a un grupo ya existente, ya que esto no se puede cambiar despu\u00e9s, adem\u00e1s lo consideraremos como PLAGIO si lo realizan de manera incorrecta, ya que al hacer esto pueden tener acceso al repositorio del otro miembro del grupo. Ya sea que se unan o creen un nuevo grupo, al finalizar el proceso les crear\u00e1 autom\u00e1ticamente un repositorio con una extensi\u00f3n que termina con su nombre de grupo. Ya habiendo hecho todo eso, pueden ejecutar los siguientes comandos abriendo una terminal ( CTRL + T ): git clone <link del repositorio> NOTA : Tienen que reemplazar <link del repositorio> con el link del repositorio que se cre\u00f3.","title":"Preparaci\u00f3n"},{"location":"projs/proj01/#estructura-del-proyecto","text":"Cuando hayan clonado el repositorio, se van a encontrar con los siguientes archivos: Makefile part1.c part2.c README.md riscv.c riscvcode/ riscv.h submit types.h utils.c utils.h Los \u00fanicos archivos que pueden modificar son: part1.c : Este es el archivo que van a modificar en la parte 1 del proyecto. utils.c : Archivo auxiliar que contendr\u00e1 varias funciones de ayuda para la parte 1 y 2 del proyecto. part2.c : Este es el archivo que van a modificar en la parte 2 del proyecto. Ustedes NO pueden crear otros archivos ni crear archivos de cabecera .h . Si necesitan agregar funciones de ayuda, por favor col\u00f3quenlas en los archivos C correspondientes ( utils.c , part1.c , part2.c ). Si ustedes no siguen estas recomendaciones, su c\u00f3digo no va a compilar en el autograder y obtendr\u00e1n 0 como nota . Otros archivos que necesitan consultar detenidamente para entender el proyecto: type.h : Archivo de cabecera que tiene los tipos de datos que ustedes van a utilizar. Makefile : Para compilar y probar su c\u00f3digo. riscvcode/* : Archivos para hacer algunas pruebas. utils.h : Archivo que contiene el formato de las instrucciones a ser utilizadas en la parte 1 del proyecto. Archivos que no es necesario que los revisen, pero si son curiosos: riscv.h : tiene declaraciones de funciones que se utilizan en la parte 1 y 2 del proyecto. riscv.c : programa encargado de probar la parte 1 y 2 del proyecto, el simulador como tal.","title":"Estructura del Proyecto"},{"location":"projs/proj01/#el-emulador-de-risc-v","text":"Los archivos proporcionados en el repositorio que crearon con GitHub Classroom son la base para un emulador de RISC-V. Primero, ustedes deber\u00e1n agregar c\u00f3digo en part1.c y utils.c para imprimir las instrucciones en ensamblador correspondientes al c\u00f3digo de m\u00e1quina (binario). Una vez realizaron esto, ustedes completar\u00e1n el programa agregando c\u00f3digo en el archivo parte2.c para ejecutar cada instrucci\u00f3n (incluyendo los accesos a memoria). Su simulador debe de ser capaz de entender cada una de las instrucciones siguientes ya codificadas en c\u00f3digo de m\u00e1quina (binario), nosotros ya les damos una tabla de los tipos de instrucciones que debe de ser capaz de manejar su emulador. Es muy IMPORTANTE que ustedes lean y entiendan las definiciones encontradas en types.h antes de empezar su proyecto. Si tiene alguna duda, o encuentran algo que no entiendan respecto a las mismas consulten el cap\u00edtulo 6 de K&R, que habla sobre estructuras, bitfields y uniones .","title":"El emulador de RISC-V"},{"location":"projs/proj01/#set-de-instrucciones","text":"El set de instrucciones que su emulador debe soportar esta listado a continuaci\u00f3n. Toda la informaci\u00f3n ac\u00e1 es copiada desde RISC-V green card , como ayuda adicional pueden utilizar la hoja proporcionada anteriormente.","title":"Set de Instrucciones"},{"location":"projs/proj01/#tipo-r","text":"FORMATO DE UNA INSTRUCCI\u00d3N DE TIPO R R-TYPE funct7 rs2 rs1 funct3 rd opcode Bits 7 5 5 3 5 7 INTRUCCIONES TIPO R (OPCODE 0x33) INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N add rd , rs1 , rs2 0x0 0x00 R [ rd ] < - R [ rs1 ] + R [ rs2 ] mul rd , rs1 , rs2 0x0 0x01 R [ rd ] < -( R [ rs1 ] * R [ rs2 ]) [31:0] sub rd , rs1 , rs2 0x0 0x20 R [ rd ] < - R [ rs1 ] - R [ rs2 ] sll rd , rs1 , rs2 0x1 0x00 R [ rd ] < - R [ rs1 ] < < R [ rs2 ] mulh rd , rs1 , rs2 0x1 0x01 R [ rd ] < -( R [ rs1 ] * R [ rs2 ]) [63:32] slt rd , rs1 , rs2 0x2 0x00 R [ rd ] < -( R [ rs1 ] < R [ rs2 ]) ? 1 : 0 xor rd , rs1 , rs2 0x4 0x00 R [ rd ] < - R [ rs1 ] ^ R [ rs2 ] div rd , rs1 , rs2 0x4 0x01 R [ rd ] < - R [ rs1 ] / R [ rs2 ] srl rd , rs1 , rs2 0x5 0x00 R [ rd ] < - R [ rs1 ] >> R [ rs2 ] sra rd , rs1 , rs2 0x5 0x20 R [ rd ] < - R [ rs1 ] >> R [ rs2 ] or rd , rs1 , rs2 0x6 0x00 R [ rd ] < - R [ rs1 ] | R [ rs2 ] rem rd , rs1 , rs2 0x6 0x01 R [ rd ] < - R [ rs1 ] % R [ rs2 ] and rd , rs1 , rs2 0x7 0x00 R [ rd ] < - R [ rs1 ] & R [ rs2 ]","title":"Tipo R"},{"location":"projs/proj01/#tipo-i","text":"FORMATO DE UNA INSTRUCCI\u00d3N DE TIPO I I-TYPE imm[11:0] rs1 funct3 rd opcode Bits 12 5 3 5 7 INTRUCCIONES TIPO I (OPCODE 0x03) INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N lb rd, offset ( rs1 ) 0x0 R [ rd ]<- SignExt(Mem( R [ rs1 ] + offset , byte )) lh rd, offset ( rs1 ) 0x1 R [ rd ]<- SignExt(Mem( R [ rs1 ] + offset , half )) lw rd, offset ( rs1 ) 0x2 R [ rd ]<- Mem( R [ rs1 ] + offset , word ) INTRUCCIONES TIPO I (OPCODE 0x13) INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N addi rd, rs1, imm 0x0 R [ rd ]<- R [ rs1 ] + imm slli rd, rs1, imm 0x1 0x00 R [ rd ]<- R [ rs1 ] << imm slti rd, rs1, imm 0x2 R [ rd ]<- ( R [ rs1 ] < imm ) ? 1 : 0 xori rd, rs1, imm 0x4 R [ rd ]<- R [ rs1 ] ^ imm srli rd, rs1, imm 0x5 0x00 R [ rd ]<- R [ rs1 ] >> imm srai rd, rs1, imm 0x5 0x20 R [ rd ]<- R [ rs1 ] >> imm ori rd, rs1, imm 0x6 R [ rd ]<- R [ rs1 ] | imm andi rd, rs1, imm 0x7 R [ rd ]<- R [ rs1 ] & imm INTRUCCIONES TIPO I (OPCODE 0x67) INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N jalr 0x0 R [ rd ]<- PC + 4 PC <- R [ rs1 ] + imm INTRUCCIONES TIPO I (OPCODE 0x73) INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N ecall 0x0 0x000 (Transfiere el control al Sistema Operativo) a0 = 1 imprime el valor contenido en a1 como entero. a0 = 10 es exit o un indicador de final de c\u00f3digo.","title":"Tipo I"},{"location":"projs/proj01/#tipo-s","text":"FORMATO DE UNA INSTRUCCI\u00d3N DE TIPO S S-TYPE imm[11:5] rs2 rs1 funct3 imm[4:0] opcode Bits 7 5 5 3 5 7 INTRUCCIONES TIPO S (OPCODE 0x23) INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N sb rs2 , offset ( rs1 ) 0x0 Mem( R [ rs1 ] + offset )<- R [ rs2 ][7:0] sh rs2 , offset ( rs1 ) 0x1 Mem( R [ rs1 ] + offset )<- R [ rs2 ][15:0] sw rs2 , offset ( rs1 ) 0x2 Mem( R [ rs1 ] + offset )<- R [ rs2 ]","title":"Tipo S"},{"location":"projs/proj01/#tipo-sb","text":"FORMATO DE UNA INSTRUCCI\u00d3N DE TIPO SB SB-TYPE imm[12] imm[10:5] rs2 rs1 funct3 imm[4:1] imm[11] opcode Bits 1 6 5 5 3 4 1 7 INTRUCCIONES TIPO SB (OPCODE 0x63) INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N beq rs1 , rs2 , offset 0x0 if( R [ rs1 ] == R [ rs2 ]) PC <- PC + { offset , 1b'0} bne rs1 , rs2 , offset 0x1 if( R [ rs1 ] != R [ rs2 ]) PC <- PC + { offset , 1b'0}","title":"Tipo SB"},{"location":"projs/proj01/#tipo-u","text":"FORMATO DE UNA INSTRUCCI\u00d3N DE TIPO U U-TYPE imm[31:12] rd opcode Bits 20 5 7 INTRUCCIONES TIPO U (OPCODE 0x17) INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N auipc rd , offset R [ rd ]<- PC + { offset , 12b'0} INTRUCCIONES TIPO U (OPCODE 0x37) INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N lui rd , offset R [ rd ]<- { offset , 12b'0}","title":"Tipo U"},{"location":"projs/proj01/#tipo-uj","text":"FORMATO DE UNA INSTRUCCI\u00d3N DE TIPO UJ UJ-TYPE imm[20] imm[10:1] imm[11] imm[19:12] rd opcode Bits 1 10 1 8 5 7 INTRUCCIONES TIPO UJ (OPCODE 0x6F) INSTRUCCI\u00d3N FUNCT3 FUNCT7/IMM OPERACI\u00d3N jal rd , imm R [ rd ]<- PC + 4 PC <- PC + { imm , 1b'0} Al igual que la arquitectura RISC-V normal, el sistema RISC-V que est\u00e1n implementando es little-endian. Esto significa que cuando se le da un valor compuesto de m\u00faltiples bytes, el byte menos significativo se almacena en la direcci\u00f3n m\u00e1s baja. Consulten la p\u00e1gina B-43 de P&H (4\u00aa edici\u00f3n) para obtener informaci\u00f3n sobre endianness.","title":"Tipo UJ"},{"location":"projs/proj01/#estructura-del-codigo","text":"El c\u00f3digo base que les fue proporcionado funciona de la siguiente manera: Lee los programas en c\u00f3digo de m\u00e1quina que se encuentran en la memoria (Empezando en la direcci\u00f3n 0x01000 ). Para \"ejecutar\" el programa este es pasado como un par\u00e1metro en la l\u00ednea de comandos. Cada programa tiene 1 MiB de memoria y la unidad m\u00ednima de direccionamiento son los bytes. Todos los registros de RISC-V son inicializados en 0 y el program counter ( pc ) hacia la direcci\u00f3n 0x01000 . Las \u00fanicas excepciones a las inicializaciones antes mencionadas son el stack pointer ( sp ) que tiene un valor inicial de 0xEFFFF y el global pointer ( gp ) que tiene un valor inicial de 0x03000 . En el contexto de su emulador, el global pointer hace referencia a la secci\u00f3n est\u00e1tica de su memoria. Los registros y el program counter est\u00e1n definidos en el Processor struct definido en types.h . Se definieron banderas con las cuales puede manejar la interacci\u00f3n con el usuario. Dependiendo de la opci\u00f3n especificada en la l\u00ednea de comandos, el simulador mostrar\u00e1 un dissassembly dump ( -d ) o se ejecutar\u00e1 el programa. Habr\u00e1 m\u00e1s informaci\u00f3n sobre las opciones de l\u00ednea de comandos m\u00e1s adelante. Lo que prosigue es qu\u00e9 entra al flujo de simulaci\u00f3n principal, el cual ejecuta una \u00fanica instrucci\u00f3n repetitivamente hasta que la simulaci\u00f3n se completa. La ejecuci\u00f3n de una instrucci\u00f3n realiza las siguientes tareas: Trae una instrucci\u00f3n desde la memoria, usando el pc como direcci\u00f3n ( fetch ). Examina el opcode/funct3 para determinar que instrucci\u00f3n es ( decode ). Ejecuta la instrucci\u00f3n y actualiza el pc ( execute ).","title":"Estructura del C\u00f3digo"},{"location":"projs/proj01/#opciones-en-la-linea-de-comandos","text":"-i : Corre el simulador en modo interactivo ( interactive ), es decir que se ejecutar\u00e1 una instrucci\u00f3n a la vez al presionar enter . Cada instrucci\u00f3n es mostrada en su forma desensamblada. -t : Corre el simulador en modo rastreo ( trace ), en donde cada instrucci\u00f3n es ejecutada y es mostrada al usuario. -r : Indica al simulador que imprima el contenido de los 32 registros despu\u00e9s de que es ejecutada cada instrucci\u00f3n. Esta opci\u00f3n es m\u00e1s \u00fatil cuando se combina con la opci\u00f3n -i . -d : Indica al simulador que desensamble el programa completo y que termine sin ejecutarlo. En la parte 2, ustedes deber\u00e1n implementar los siguientes m\u00e9todos: El execute_instruction() . Los diferentes executes . El store() . El load() . Para cuando ustedes hayan terminado la implementaci\u00f3n de todos los m\u00e9todos, el simulador ser\u00e1 capaz de manejar todas las instrucciones de la tabla anterior.","title":"Opciones en la l\u00ednea de comandos"},{"location":"projs/proj01/#parte-1","text":"Su primera tarea es implementar un desensamblador al completar el m\u00e9todo decode_instruction() en el archivo part1.c junto a otras funciones. El objetivo de esta parte, es que, dada una instrucci\u00f3n en c\u00f3digo de m\u00e1quina, ustedes deber\u00e1n traducirla a su instrucci\u00f3n en lenguaje ensamblador RISC-V (e.g. add x1, x2, x3 ). Para esta parte, ustedes no har\u00e1n referencia a los registros por nombre sino por su n\u00famero (como est\u00e1 definido en RISC-V Green Card ). Cuando impriman las instrucciones revisen las constantes definidas en utils.h , ya que estas le pueden ser de ayuda. M\u00e1s detalles sobre los requisitos a continuaci\u00f3n.","title":"Parte 1"},{"location":"projs/proj01/#requisitos-parte-1","text":"Imprimir el nombre de la instrucci\u00f3n. Si la instrucci\u00f3n tiene argumentos, impriman un tab ( \\t ). Imprimir todos los argumentos, siguiendo el orden y formato dado en la columna de INSTRUCCI\u00d3N de las tablas mostradas anteriormente. Los argumentos son generalmente separados por coma ( lw / sw , usan tambi\u00e9n par\u00e9ntesis), pero no est\u00e1n separados por espacios. Ustedes encontrar\u00e1n de ayuda revisar el archivo utils.h . Los registros que son argumentos de la instrucci\u00f3n son impresos con una x seguido del n\u00famero de registro, en decimal. (e.g. x0 o x31 ) Todos los inmediatos deben mostrarse como un n\u00famero decimal con signo. Los corrimientos (e.g. para slli ) se imprimen como n\u00fameros decimales sin signo (e.g. 0 a 31). Imprimir un salto de l\u00ednea ( \\n ) al final de cada instrucci\u00f3n. Se estar\u00e1 utilizando un autograder para calificar esta tarea. Si su output difiere del nuestro debido a errores de formato, no obtendr\u00e1n nota. Nosotros les proveemos ciertas pruebas. Sin embargo, dado que estas pruebas s\u00f3lo cubren un subconjunto de todos los escenarios posibles, pasar estas pruebas no significa que su c\u00f3digo est\u00e9 libre de errores. Ustedes deber\u00e1n identificar todos los casos y probarlos. Para completar la funcionalidad de la parte 1, deben de completar lo siguiente: La funci\u00f3n decode_instrucction() en part1.c . Los diferentes writes en part1.c . Los diferentes prints en part1.c . Los diferentes gets en utils.c . La funci\u00f3n bitSigner en utils.c . Ustedes deben de correr el test brindado para su proyecto escribiendo el siguiente comando. Si ustedes pasan el test, ver\u00e1n en su consola el siguiente output. make part1 gcc -g -Wall -Werror -Wfatal-errors -O2 -o riscv utils.c part1.c part2.c riscv.c simple_disasm TEST PASSED! multiply_disasm TEST PASSED! random_disasm TEST PASSED! ---------Disassembly Tests Complete---------","title":"Requisitos Parte 1"},{"location":"projs/proj01/#probando-la-parte-1","text":"Los tests que se les dieron no eval\u00faan todas las posibilidades, por eso mismo ustedes pueden ( deben ) crear sus propios archivos de prueba para comprobar su funcionamiento. Si ustedes desean correr un test en espec\u00edfico, pueden usar el siguiente comando para ello: make [test_name]_disasm Para crear sus propios archivos de prueba, primero necesitar\u00e1n crear c\u00f3digo de m\u00e1quina. Para ello pueden ayudarse de V-Sim o hacerlo a mano. Si utilizan V-Sim tienen que crear un archivo .s y hacer un dump del c\u00f3digo de m\u00e1quina utilizando la bandera -code en la terminal: vsim <archivo>.s -code <test_name>.input Ustedes deben de poner las instrucciones en c\u00f3digo de m\u00e1quina en un archivo llamado [test_name].input y colocar el archivo dentro de la carpeta riscvcode/code . Despu\u00e9s, deben crear el archivo [test_name].solution el cual contendr\u00e1 las instrucciones que se espera obtener; y colocar el archivo en la carpeta riscvcode/ref . Vean las pruebas proporcionadas como ejemplos de este tipo de archivos. Para integrar sus pruebas en el comando make , ustedes deben de modificar el archivo Makefile . En la l\u00ednea 4 del archivo Makefile , donde dice ASM_TESTS , agregar [test_name] a la lista con espacios entre cada nombre de archivo: SOURCES := utils.c part1.c part2.c riscv.c HEADERS := types.h utils.h riscv.h ASM_TESTS := simple multiply random test_name Si su instrucci\u00f3n desensamblada no es igual a la esperada, ustedes obtendr\u00e1n la diferencia entre el output esperado y el output que devolvieron. Aseg\u00farense de al menos pasar esta prueba antes de enviar la parte 1 al autograder . # Output Esperado < 00001014 : lui x8, 1048575 --- # Output Devuelto > 00001014 : Invalid Instruction: 0xfffff437","title":"Probando la Parte 1"},{"location":"projs/proj01/#calificacion-parte-1","text":"Recuerden que para la primera parte, s\u00f3lo deben modificar los archivos part1.c y utils.c , esto representa el 50% de su nota as\u00ed que pueden enviar sus archivos al autograder para verificar su nota de esta parte haciendo: ./submit <TOKEN> Si est\u00e1n trabajando en pareja, AMBOS miembros del grupo tienen que hacer el submit con su respectivo TOKEN .","title":"Calificaci\u00f3n Parte 1"},{"location":"projs/proj01/#parte-2","text":"Su segunda tarea es completar el emulador implementando los m\u00e9todos execute_instruction() . execute() 's, store() y load() del archivo part2.c .","title":"Parte 2"},{"location":"projs/proj01/#requisitos","text":"Esta parte consistir\u00e1 en implementar la funcionalidad de cada instrucci\u00f3n. Por favor implementen las funciones descritas a continuaci\u00f3n (todas en part2.c ): execute_instruction() : Ejecuta la instrucci\u00f3n proporcionada como par\u00e1metro. Esta deber\u00eda modificar los registros apropiados, realizar las llamadas a memoria necesarias y actualizar el program counter para apuntar a la siguiente instrucci\u00f3n a ejecutar. execute() 's: Varias funciones de ayuda para ser llamadas en ciertas condiciones para ciertas instrucciones. Es su decisi\u00f3n usar estas funciones, pero estas les ayudar\u00e1n de gran manera a organizar el c\u00f3digo. store() : Toma una direcci\u00f3n, un tama\u00f1o, un valor y almacena los primeros (tama\u00f1o) bytes del valor dado en la direcci\u00f3n dada. Cuando el par\u00e1metro check_align sea 1 se validar\u00e1n las restricciones de alineaci\u00f3n. Se incluy\u00f3 este par\u00e1metro para obligar a las instrucciones a estar alineadas por palabras de memoria (word-aligned). Cuando implementen el store y load , este par\u00e1metro debe ser 0 dado que RISC-V no hace cumplir las restricciones de alineaci\u00f3n. load() : Toma una direcci\u00f3n y un tama\u00f1o, y retorna los siguientes (tama\u00f1o) bytes empezando en la direcci\u00f3n dada. El check_align funciona de la misma forma que en store() .","title":"Requisitos"},{"location":"projs/proj01/#probando-la-parte-2","text":"Les hemos adjuntado un self-checking assembly test que prueba varias de las instruciones, sin embargo este test no es exhaustivo y no prueba todas las instrucciones. A continuaci\u00f3n, se ejemplifica c\u00f3mo ejecutar los test (el output es de una soluci\u00f3n correcta). make part2 gcc -Wall -Werror -Wfatal-errors -O2 -o riscv utils.c part1.c part2.c riscv.c simple_execute TEST PASSED! multiply_execute TEST PASSED! random_execute TEST PASSED! -----------Execute Tests Complete----------- Lo m\u00e1s probable es que ustedes tenga errores al empezar a realizar la parte 2, entonces prueben el modo de rastreo ( trace ) descrito en Opciones en la l\u00ednea de Comandos . Les hemos dado unos cuantos tests m\u00e1s, adem\u00e1s de la posibilidad de escribir test propios. Como en la parte 1, ustedes tendr\u00e1n que crear archivos .input . Sin embargo, para la parte 2, ustedes deber\u00e1n nombrar su archivo soluci\u00f3n con una extensi\u00f3n .trace . Creen el nuevo archivo de ensamblador en el directorio riscvcode (utilicen riscvcode/simple.input como plantilla). Agreguen el nombre base del test a la lista de ASM_TESTS en el Makefile . Para realizar esto s\u00f3lo agreguen [test_name] al final de la l\u00ednea 4. Ahora compilen su test de ensamblador y ejec\u00fatenlo escribiendo el siguiente comando: make [ test_name ] _execute Ustedes pueden, y en efecto deben, escribir sus propios test para probar instrucciones espec\u00edficas y todos los posibles casos. Adem\u00e1s, ustedes deben compilar y probar su c\u00f3digo despu\u00e9s de cada grupo de instrucciones implementadas. De lo contrario ser\u00e1 muy dif\u00edcil probar su proyecto si esperan hasta el final.","title":"Probando la Parte 2"},{"location":"projs/proj01/#calificacion-parte-2","text":"Al completar esta parte ustedes s\u00f3lo deber\u00edan haber modificado los archivos part1.c , part2.c y utils.c , deben realizar commit de todos los cambios realizados y enviar el link de su repositorio por medio del GES. Para obtener su nota completa tienen que hacer: ./submit <TOKEN> Si est\u00e1n trabajando en pareja, AMBOS miembros del grupo tienen que hacer el submit con su respectivo TOKEN .","title":"Calificaci\u00f3n Parte 2"},{"location":"projs/proj01/#preguntas-frecuentes","text":"","title":"Preguntas Frecuentes"},{"location":"projs/proj01/#1-como-puedo-empezar","text":"Lo mejor es revisar types.h y analizar la estructura Instruction para empezar a trabajar en la parte1.c , por ejemplo como acceder a cada campo de cada diferente tipo de instrucci\u00f3n y al opcode tambi\u00e9n. Por ejemplo, para acceder al opcode pueden utilizar: instruction . opcode siendo instruction una variable que representa una \"instancia\" de la estructura Instruction . Luego de esto, pueden ver c\u00f3mo accediendo a estos campos pueden decodificar la instrucci\u00f3n y as\u00ed lograr imprimirla.","title":"1. \u00bfC\u00f3mo puedo empezar?"},{"location":"projs/proj01/#2-en-mi-maquina-local-saco-100-y-en-el-autograder-0-por-que","text":"Al trabajar con uniones y estructuras de C y al utilizar la bandera -O2 pueden pasar cosas muy raras, una de ellas es el strict aliasing , por eso les recomendamos probar su c\u00f3digo en la m\u00e1quina virtual que les proporcionamos, as\u00ed est\u00e1n totalmente seguros de que c\u00f3digo funciona correctamente.","title":"2. En mi m\u00e1quina local saco 100% y en el autograder 0, \u00bfpor qu\u00e9?"},{"location":"projs/proj01/#3-me-da-floating-point-exception-core-dumped-al-hacer-algunas-operaciones-aritmeticas-por-que","text":"Generalmente esto se da porque se divide por 0 o hay overflow utilizando variables enteras con signo. Por ejemplo: Division por 0 int x = 10 ; int y = 0 ; int z = x / y ; Overflow int32_t x = 0x80000000 ; int32_t y = 0xffffffff ; int32_t z = x / y ; La soluci\u00f3n para la divisi\u00f3n por 0 es simplemente tienen que devolver -1 como dice la especificaci\u00f3n de RISC-V y para el residuo devolver el primer argumento de la operaci\u00f3n. En el caso de overflow devolvemos rs1 para la division y 0 para el residuo. Division // division if ( rs2 == 0 ) { rd = - 1 ; // division entre cero } else if ( rs1 == 0x80000000 && rs2 == 0xffffffff ) { rd = rs1 ; // overflow } else { rd = rs1 / rs2 ; } Residuo // residuo if ( rs2 == 0 ) { rd = rs1 ; // residuo entre cero } else if ( rs1 == 0x80000000 && rs2 == 0xffffffff ) { rd = 0 ; // overflow } else { rd = rs1 % rs2 ; }","title":"3. Me da Floating-point Exception (core dumped) al hacer algunas operaciones aritm\u00e9ticas, \u00bfpor qu\u00e9?"},{"location":"projs/proj01/#4-en-la-parte-1-el-formato-nunca-es-el-esperado-por-las-pruebas-por-que","text":"Seguramente no est\u00e1n utilizando el formato correcto, les recomendamos que utilicen las siguientes macros para imprimir las instrucciones que se encuentran en el archivo utils.h : #define RTYPE_FORMAT \"%s\\tx%d, x%d, x%d\\n\" #define ITYPE_FORMAT \"%s\\tx%d, x%d, %d\\n\" #define JALR_FORMAT \"jalr\\tx%d, x%d, %d\\n\" #define MEM_FORMAT \"%s\\tx%d, %d(x%d)\\n\" #define AUIPC_FORMAT \"auipc\\tx%d, %d\\n\" #define LUI_FORMAT \"lui\\tx%d, %d\\n\" #define JAL_FORMAT \"jal\\tx%d, %d\\n\" #define BRANCH_FORMAT \"%s\\tx%d, x%d, %d\\n\" #define ECALL_FORMAT \"ecall\\n\"","title":"4. En la parte 1 el formato nunca es el esperado por las pruebas, \u00bfpor qu\u00e9?"},{"location":"projs/proj01/#5-puedo-crear-mis-propias-funciones","text":"S\u00ed, siempre y cuando estas est\u00e9n declaradas, ya sea en part1.c , part2.c o utils.c , ya que son los \u00fanicos archivos que se env\u00edan al autograder. Sin embargo, NO est\u00e1 permitido renombrar o eliminar las siguientes funciones : /* archivo part1.c */ void decode_instruction ( Instruction i ); /* archivo part2.c */ void execute_instruction ( Instruction instruction , Processor * processor , Byte * memory ); void store ( Byte * memory , Address address , Alignment alignment , Word value , int ); Word load ( Byte * memory , Address address , Alignment alignment , int ); Ya que el simulador riscv.c espera que estas est\u00e9n definidas.","title":"5. \u00bfPuedo crear mis propias funciones?"},{"location":"projs/proj02/","text":"Proyecto 2: CPU \u00b6 Introducci\u00f3n \u00b6 En este proyecto utilizaremos Logisim para implementar un procesador de 32-bits, cuyo ISA es un subset de las instrucciones de RISC-V. Algunos componentes del proyecto ser\u00e1n m\u00e1s sencillos que los componentes de hardware verdaderos para evitar realizar trabajo repetitivo. Nuestro ISA utiliza 32 registros de 32 bits cada uno y una memoria, cuyas direcciones son de 32 bits. A continuaci\u00f3n, algunos detalles importantes que debemos leer antes de iniciar. Pueden utilizar cualquier bloque ya existente en Logisim para el proyecto. Guarden constantemente. Realicen commits y hagan push al menos una vez por cada d\u00eda que trabajen. Logisim es un excelente simulador pero ocasionalmente tiene errores, entonces hagamos caso a la indicaci\u00f3n anterior. Guarden constantemente... Trabajemos de la misma forma que en un proyecto de software: Construyamos el proyecto pieza por pieza y realicemos pruebas antes de unir un bloque con otros. Podemos construir todos los subcircuitos adicionales que necesitemos, siempre y cuando sigamos las reglas espec\u00edficas que cada parte impone (m\u00e1s de esto a continuaci\u00f3n). Se incluyen algunos tests. S\u00f3lo se debe correr el script ./check (esto seguramente tendr\u00e1n que hacerlo en Linux, se requiere Python 3.X instalado). \u00a1Necesitaremos m\u00e1s tests! Cada equipo deber\u00eda hacer sus propios tests adicionales. En la secci\u00f3n de Testing hay algunas indicaciones de c\u00f3mo hacer pruebas adicionales. Finalmente, las dos indicaciones m\u00e1s importantes: Se les dar\u00e1n algunos armazones (harnesses) a los cuales sus circuitos se conectar\u00e1n. ASEGURENSE QUE S\u00cd SE ADAPTAN DE FORMA CORRECTA, TODOS LOS TESTS FALLAR\u00c1N SI NO LO HACEN. En el camino nos hemos encontrado con algunos problemas de git merge si ambos miembros del equipo estaban trabajando en el mismo archivo; a veces git los resolv\u00eda autom\u00e1ticamente y a veces no. En Logisim es garantizado que git NO RESOLVER\u00c1 ESTO DE FORMA CORRECTA, entonces si trabajamos en equipo NO DEBEMOS MODIFICAR EL MISMO ARCHIVO AL MISMO TIEMPO Preparaci\u00f3n \u00b6 Antes de comenzar, aseg\u00farense de que hayan le\u00eddo y comprendido todas las instrucciones del proyecto de principio a fin . Si tienen alguna pregunta, por favor dir\u00edjanse a Slack y pregunten en los canales correspondientes. Para comenzar con el proyecto, primero tienen que tener todos los archivos base, estos se encuentran aqu\u00ed . Tienen permitido trabajar en parejas o de forma individual, por lo que al aceptar la asignaci\u00f3n les preguntar\u00e1 si desean crear un grupo nuevo o unirse a uno ya existente. Si crean un grupo nuevo, ingresen un nombre que represente lo represente y que no haya sido tomado por otro. Si desean unirse a un grupo ya creado, tienen que buscar el nombre del grupo y pulsar el bot\u00f3n que dice join Tienen que tener mucho cuidado al unirse a un grupo ya existente, ya que esto no se puede cambiar despu\u00e9s, adem\u00e1s, lo consideraremos como PLAGIO si lo realizan de manera incorrecta, ya que, al hacer esto, pueden tener acceso al repositorio del otro miembro del grupo. Ya sea que se unan o creen un nuevo grupo, al finalizar el proceso les crear\u00e1 autom\u00e1ticamente un repositorio con una extensi\u00f3n que termina con su nombre de grupo. Ya habiendo hecho todo eso, pueden ejecutar los siguientes comandos abriendo una terminal ( CTRL + T ): git clone <link del repositorio> Parte 1: Register File \u00b6 Como aprendimos en clase, RISC-V tiene 32 registros. En el proyecto s\u00f3lo implementaremos 9 (abajo se indica cuales) para evitar realizar trabajo repetitivo. Todas nuestras se\u00f1ales (rs1, rs2, rd) siguen siendo de 5-bits, pero s\u00f3lo se estar\u00e1n usando los registros indicados. El register file debe poder leer y escribir a los registros que se especifiquen seg\u00fan la instrucci\u00f3n, sin afectar o modificar a cualquier otro registro. Existe una excepci\u00f3n: El registro cero est\u00e1 alambrado a tierra y su valor no puede ser cambiado por ning\u00fan motivo. Los registros que utilizaremos son los siguientes: Registro por n\u00famero Registro por nombre x0 zero x1 ra x2 sp x5 t0 x6 t1 x8 s0 x9 s1 x10 a0 x11 a1 En el archivo regfile.circ se encuentra el esqueleto de un register file. Este tiene seis entradas: Nombre Ancho en bits Descripci\u00f3n Clock 1 Se\u00f1al de reloj. Aqu\u00ed se recibir\u00e1 una se\u00f1al de reloj \"non gated\", es decir, se recibe la se\u00f1al directa sin ser afectada por ANDs, NOTs o cualquier compuerta. Write Enable 1 Indica si se deber\u00eda escribir a un registro en el siguiente flanco de subida del reloj. Read Register 1 5 Registro a leer y cuyo valor ser\u00e1 enviado a Read Data 1. Read Register 2 5 Registro a leer y cuyo valor ser\u00e1 enviado a Read Data 2. Write Register 5 Determina cu\u00e1l registro ser\u00e1 modificado en el siguiente flanco de subida (asumiendo que Write Enable = 1). Write Data 32 Los 32 bits de datos a guardarse en el registro, en el siguiente flanco de subida (asumiendo que Write Enable = 1). El register file tiene las siguientes salidas: Nombre Ancho en bits Descripci\u00f3n Read Data 1 32 Datos que se est\u00e1n leyendo, seg\u00fan el registro que Read Register 1 pidi\u00f3. Read Data 2 32 Datos que se est\u00e1n leyendo, seg\u00fan el registro que Read Register 2 pidi\u00f3. s0 Value 32 Valor de s0 (salida para DEBUG/TEST). s1 Value 32 Valor de s1 (salida para DEBUG/TEST). t0 Value 32 Valor de t0 (salida para DEBUG/TEST). t1 Value 32 Valor de t1 (salida para DEBUG/TEST). a0 Value 32 Valor de a0 (salida para DEBUG/TEST). ra Value 32 Valor de ra (salida para DEBUG/TEST). sp Value 32 Valor de sp (salida para DEBUG/TEST). Las salidas para DEBUG/TEST est\u00e1n presentes porque son registros de uso frecuente (por ejemplo, tienen un trabajo importante en las llamadas a funciones). Se utilizar\u00e1n s\u00f3lo para pruebas del autograder. En un register file de verdad estas salidas no existir\u00edan. Para el proyecto deben estar presentes y funcionar bien para facilitar la calificaci\u00f3n. Pueden modificar regfile.circ como deseen, pero las salidas deben cumplir con el comportamiento que se indica. Deben ser cuidadosos de no modificar (mover, reemplazar, cortar, pegar, eliminar, etc) los pines de entrada o salida. Si necesitan m\u00e1s espacio, pueden moverlos mientras sean cuidadosos de mantener el posicionamiento relativo que estos tienen. Para verificar que nuestros cambios no \"rompan\" nada, podemos abrir regfile-harness.circ y revisar que no existan errores all\u00ed y que todo funcione bien. HINTS: (1) Cuidado con los muxes. Si estos tienen un enable ese deber\u00eda estar activo (o mejor a\u00fan, buscamos en la ayuda de Logisim c\u00f3mo quitar esa funcionalidad). (2) \u00bfTri-estado? Three-state? En CC3 no debemos pensar en estados de alta impedancia (qu'est-ce que c'est?) entonces lo mejor es deshabilitar el uso de three-state. Parte 2: ALU \u00b6 Su segunda tarea es crear un ALU que soporte todas las operaciones que necesitan las instrucciones de nuestro ISA (se detallan m\u00e1s adelante). Van a estar trabajando en el archivo alu.circ . Este tiene tres entradas: Nombre de Entrada Ancho en Bits Descripci\u00f3n A 32 Datos para usar por A en la operaci\u00f3n del ALU B 32 Datos para usar por B en la operaci\u00f3n del ALU ALU Op 4 Selecciona la operaci\u00f3n que el ALU debe de efectuar ...y cuatro salidas: Nombre de Entrada Ancho en Bits Descripci\u00f3n Out 32 Resultado de la operaci\u00f3n efectuada por el ALU Equal 1 1 si A y B son iguales; 0 de lo contrario LT 1 1 si A es menor que B (signed); 0 de lo contrario LTU 1 1 si A es menor que B (unsigned); 0 de lo contrario Esta es la lista de operaciones que necesitan implementar. Ustedes tienen que utilizar los componentes de logisim que ya efect\u00faan estas operaciones, por favor no las implementen desde cero, ser\u00eda muy tardado y no es el objetivo del proyecto. Valor de ALU Op Instrucci\u00f3n 0 sll: Out = A << B[4:0] 1 srl: Out = (unsigned) A >> B[4:0] 2 add: Out = A + B 3 and: Out = A & B 4 or: Out = A | B 5 xor: Out = A ^ B 6 slt: Out = (A < B) ? 1 : 0 Signed 7 mul: Out = (X * Y)[31:0] 8 mulh: Out = (A * B)[63:32] 9 div: Out =(unsigned) A / B 10 rem: Out = A % B 11 sub: Out = A - B Algunas cosas adicionales que tienen que tener en mente: La salidas Equal , LT , LTU siempre tienen que sacar el valor correcto de comparaci\u00f3n sin importar el valor de ALU Op . Nuevamente, tienen que tener cuidado con los inputs y output pins, no los modifiquen por ning\u00fan motivo. Su ALU deber\u00eda de encajar con el harness alu_harness.circ . Sigan las mismas instrucciones que en el register file. En particular, ustedes deber\u00edan de asegurar que su ALU es cargado correctamente por el harness antes de que hagan submit. Parte 3: CPU \u00b6 Se les provee un esqueleto del procesador en cpu.circ . Su procesador tendr\u00e1 una instancia de su ALU y Register File, as\u00ed como una unidad de memoria que ya se les provee. Ustedes son los responsables de construir el datapath y control completos, desde cero. Su procesador debe implementar el ISA que se detalla m\u00e1s abajo. Su procesador obtendr\u00e1 su programa del armaz\u00f3n (harness) riscv.circ . Su procesador tendr\u00e1 un output llamado FETCH_ADDRESS que indica cu\u00e1l instrucci\u00f3n queremos, esta direcci\u00f3n ser\u00e1 entregada al harness y este nos dar\u00e1 una instrucci\u00f3n. La instrucci\u00f3n ser\u00e1 recibida por el procesador y ser\u00e1 ejecutada. Revisen riscv.circ para ver exactamente qu\u00e9 sucede. El procesador tiene dos inputs que vienen del harness: Input Name Bit Width Descripci\u00f3n INSTRUCTION 32 Aqu\u00ed se recibe la instrucci\u00f3n que se obtuvo en la direcci\u00f3n identificada por FETCH_ADDRESS. CLOCK 1 Input del reloj. Puede ser necesario estar enviando esta se\u00f1al a varios subcircuitos. Esta se\u00f1al no debe pasar por ninguna compuerta (NOT, AND, etc). El procesador debe tener los siguientes outputs, que entregar\u00e1 al harness: Output Name Bit Width Descripci\u00f3n s0 32 Contenido de s0, s\u00f3lo para pruebas. s1 32 Contenido de s1, s\u00f3lo para pruebas. t0 32 Contenido de t0, s\u00f3lo para pruebas. t1 32 Contenido de t1, s\u00f3lo para pruebas. a0 32 Contenido de a0, s\u00f3lo para pruebas. ra 32 Contenido de ra, s\u00f3lo para pruebas. sp 32 Contenido de sp, s\u00f3lo para pruebas. FETCH_ADDRESS 32 Direcci\u00f3n que indica qu\u00e9 instrucci\u00f3n queremos obtener del harness. En respuesta a esto, el harness enviar\u00e1 alguna instrucci\u00f3n a trav\u00e9s de INSTRUCTION. Como en la parte 1, tengan cuidado al mover componentes y aseg\u00farense que los pines de input y output coincidan con el harness. Memoria \u00b6 Se les provee una memoria ya implementada. :D Un resumen de sus inputs y outputs. Nombre Tipo Bit Width Descripci\u00f3n ADDRESS input 32 Direcci\u00f3n a leer o escribir en la memoria. WRITE DATA input 32 Valor a escribirse en la memoria. WRITE ENABLE input 1 En = 1 en las instrucciones que escriben; En = 0 en las dem\u00e1s. Clk input 1 Se\u00f1al de reloj que viene desde cpu.circ. READ DATA output 32 Datos le\u00eddos en la direcci\u00f3n especificada. Control \u00b6 Las se\u00f1ales de control tienen un papel muy importante en el proyecto. Se sugiere volver a leer el cap\u00edtulo 4 del libro para darse cuenta d\u00f3nde podemos necesitar un MUX y, por lo tanto, alguna se\u00f1al de control. Existen varias formas de implementar las se\u00f1ales de control. Por ejemplo, pueden construir una palabra de control y guardarla en una memoria ROM (micro-codigo) o pueden construir un circuito que elija qu\u00e9 acci\u00f3n tomar bas\u00e1ndose en algunos bits del opcode, func3 y func7. Es obligatorio que sus componentes est\u00e9n unidos y las se\u00f1ales de control necesarias est\u00e9n implementadas. Si en la calificaci\u00f3n del proyecto s\u00f3lo tiene componentes sueltos (como el ALU y Reg File de la primera fase) y estos no se comunican entre s\u00ed, su nota ser\u00e1 cero. Consejo final: \u00a1Modularicen! Creen los subcircuitos que sean necesarios y dis\u00e9\u00f1enlos bien antes de empezar a construirlos. ISA \u00b6 Las instrucciones a implementar son las siguientes: Instruction Type Opcode Funct3 Funct7/IMM Operation add rd, rs1, rs2 R 0x33 0x0 0x00 R[rd] \u2190 R[rs1] + R[rs2] mul rd, rs1, rs2 R 0x33 0x0 0x01 R[rd] \u2190 (R[rs1] * R[rs2])[31:0] sub rd, rs1, rs2 R 0x33 0x0 0x20 R[rd] \u2190 R[rs1] - R[rs2] sll rd, rs1, rs2 R 0x33 0x1 0x00 R[rd] \u2190 R[rs1] << R[rs2 mulh rd, rs1, rs2 R 0x33 0x1 0x01 R[rd] \u2190 (R[rs1] * R[rs2])[63:32] slt rd, rs1, rs2 R 0x33 0x2 0x00 R[rd] \u2190 (R[rs1] < R[rs2]) ? 1 : 0 (signed) xor rd, rs1, rs2 R 0x33 0x4 0x00 R[rd] \u2190 R[rs1] ^ R[rs2] div rd, rs1, rs2 R 0x33 0x4 0x01 R[rd] \u2190 R[rs1] / R[rs2] srl rd, rs1, rs2 R 0x33 0x5 0x00 R[rd] \u2190 R[rs1] >> R[rs2] or rd, rs1, rs2 R 0x33 0x6 0x00 R[rd] \u2190 R[rs1] | R[rs2] rem rd, rs1, rs2 R 0x33 0x6 0x01 R[rd] \u2190 (R[rs1] % R[rs2] and rd, rs1, rs2 R 0x33 0x7 0x00 R[rd] \u2190 R[rs1] & R[rs2] lb rd, offset(rs1) I 0x03 0x0 R[rd] \u2190 SignExt(Mem(R[rs1] + offset, byte)) lh rd, offset(rs1) I 0x03 0x1 R[rd] \u2190 SignExt(Mem(R[rs1] + offset, half)) lw rd, offset(rs1) I 0x03 0x2 R[rd] \u2190 Mem(R[rs1] + offset, word) addi rd, rs1, imm I 0x13 0x0 R[rd] \u2190 R[rs1] + imm slli rd, rs1, imm I 0x13 0x1 0x00 R[rd] \u2190 R[rs1] << imm slti rd, rs1, imm I 0x13 0x2 R[rd] \u2190 (R[rs1] < imm) ? 1 : 0 xori rd, rs1, imm I 0x13 0x4 R[rd] \u2190 R[rs1] ^ imm srli rd, rs1, imm I 0x13 0x5 0x00 R[rd] \u2190 R[rs1] >> imm ori rd, rs1, imm I 0x13 0x6 R[rd] \u2190 R[rs1] | imm andi rd, rs1, imm I 0x13 0x7 R[rd] \u2190 R[rs1] & imm sw rs2, offset(rs1) S 0x23 0x2 Mem(R[rs1] + offset) \u2190 R[rs2] beq rs1, rs2, offset SB 0x63 0x0 if(R[rs1] == R[rs2]) then {PC \u2190 PC + {offset, 1b'0}} blt rs1, rs2, offset SB 0x63 0x4 if(R[rs1] less than R[rs2] (signed)) then {PC \u2190 PC + {offset, 1b'0}} bltu rs1, rs2, offset SB 0x63 0x6 if(R[rs1] less than R[rs2] (unsigned)) then {PC \u2190 PC + {offset, 1b'0}} lui rd, offset U 0x37 R[rd] \u2190 {offset, 12b'0} jal rd, imm UJ 0x6f R[rd] \u2190 PC + 4, PC \u2190 PC + {imm, 1b'0} jalr rd,rs, imm I 0x67 0x0 R[rd] \u2190 PC + 4, PC \u2190 R[rs] + {imm} Testing \u00b6 Para la parte 1 y 2, con el check local es suficiente y si lo pasan significa que esas partes ya las tienen funcionando al 100%. Para la parte 2, el check local tambi\u00e9n es bastante completo, pero ustedes pueden hacer m\u00e1s pruebas si lo desean. Como no podemos probar cada componente que ustedes vayan implementando, la mejor opci\u00f3n es escribir programas de RISC-V peque\u00f1os e ir revisando su datapath de diferentes maneras. Una vez que hayan escrito su programa de RISC-V, lo van a tener que cargar en la ROM que est\u00e1 en riscv.circ y empezar la ejecuci\u00f3n. Para eso, primero, abran riscv.circ y localicen la memoria ROM. Hagan click a la memoria y, despu\u00e9s, en la barra de herramientas de la izquierda, hagan click en \"(click here to edit)\", esto va a abrir un di\u00e1logo en donde ustedes pueden cargar su archivo con el c\u00f3digo de RISC-V y este ensamblar\u00e1 y generar\u00e1 c\u00f3digo de m\u00e1quina por ustedes que va a ser la salida de la memoria ROM. Notas sobre Logisim \u00b6 Si Logisim les da alg\u00fan problema extra\u00f1o, REINICIEN LOGISIM Y VUELVAN A CARGAR SU CIRCUITO. No pierdan tiempo buscando errores si no han hecho esto. Si reiniciar no ha resuelto el problema, all\u00ed s\u00ed ya les corresponde revisar su circuito. Logisim tiene un \"Reference\", en la pesta\u00f1a \"Help\", y les dice las especificaciones de cada componente. Do NOT gate the clock! (esto no tiene una traducci\u00f3n directa). Los clocks tienen que llegar directo a los circuitos, ni en CC3 ni en un curso donde usen hardware deber\u00edan colocar compuertas antes que la se\u00f1al de reloj entre al componente. Si est\u00e1n usando varias ventanas de Logisim tengan mucho cuidado cuando hagan copy-paste de una ventana a otra. Aseg\u00farense que s\u00ed se copi\u00f3 el circuito completo que quer\u00edan y que funcione bien despu\u00e9s de pegarlo. Cuando importen otro archivo (Project -> Load Library -> Logisim Library...), este aparecer\u00e1 como un folder en el panel de la izquierda. Los archivos esqueleto deber\u00edan de tener importado todo lo necesario. Cambiar los atributos antes de colocar un componente cambia el default. Si quieren colocar varios pines de 32 bits (por ejemplo), habr\u00eda que cambiarlo antes de colocar el primero. Si s\u00f3lo quieren cambiar alg\u00fan valor para un componente, primero lo colocan y, luego, lo cambian. Cuando cambian los inputs y outputs de un subcircuito que ya colocaron en main, Logisim autom\u00e1ticamente a\u00f1ade o remueve puertos seg\u00fan los cambios que hagan. Esto, muchas veces, afecta el tama\u00f1o o posici\u00f3n del subcircuito. Si ya hab\u00edan cables conectados, Logisim intentar\u00e1 moverlos, pero no siempre lo hace bien. Se recomienda que si van a cambiar los inputs y outputs de un circuito, primero desconecten todos los cables que este pueda tener en main o lo eliminen del main y lo vuelvan a colocar despu\u00e9s de cambiarlo. Recuerden que s\u00f3lo pueden hacer esto para los subcircuitos que USTEDES agregan . Los cables rojos significan que algo est\u00e1 mal conectado. Algunos casos pueden no ser tan obvios, revisen bien todas las conexiones cercanas. Logisim tiene algunas herramientas de an\u00e1lisis combinacional (nos puede construir mapas de Karnaugh o circuitos completos con s\u00f3lo darle una tabla :D). Esta herramienta les puede ser \u00fatil en alg\u00fan momento de sus vidas, pero la recomendaci\u00f3n es no usarla en CC3. Recuerden que durante los ex\u00e1menes tendr\u00e1n que hacer mapas o circuitos a mano, sin acceso a su computadora. Calificaci\u00f3n \u00b6 Ustedes pueden verificar que cada parte funcione correctamente utilizando el autograder local, corriendo el siguiente comando en la terminal: ./check Si las tres partes del proyecto est\u00e1n correctas les saldr\u00e1 algo como esto: ___ __ __ / _ | __ __/ /____ ___ _______ ____/ /__ ____ / __ / // / __/ _ \\/ _ \\/ __/ _ \\/ _ / -_ ) __/ /_/ | _ \\_ ,_/ \\_ _/ \\_ __/ \\_ , /_/ \\_ ,_/ \\_ ,_/ \\_ _/_/ /___/ Machine Structures Great Ideas in Computer Architecture Project 2 : CPU Exercise Grade Message ---------------- ------- --------- 1 . ALU 25 passed 2 . Register File 25 passed 3 . CPU 50 passed = > Score: 100 /100 Pueden subir su proyecto para calificaci\u00f3n utilizando: ./submit <TOKEN>","title":"2: Procesador"},{"location":"projs/proj02/#proyecto-2-cpu","text":"","title":"Proyecto 2: CPU"},{"location":"projs/proj02/#introduccion","text":"En este proyecto utilizaremos Logisim para implementar un procesador de 32-bits, cuyo ISA es un subset de las instrucciones de RISC-V. Algunos componentes del proyecto ser\u00e1n m\u00e1s sencillos que los componentes de hardware verdaderos para evitar realizar trabajo repetitivo. Nuestro ISA utiliza 32 registros de 32 bits cada uno y una memoria, cuyas direcciones son de 32 bits. A continuaci\u00f3n, algunos detalles importantes que debemos leer antes de iniciar. Pueden utilizar cualquier bloque ya existente en Logisim para el proyecto. Guarden constantemente. Realicen commits y hagan push al menos una vez por cada d\u00eda que trabajen. Logisim es un excelente simulador pero ocasionalmente tiene errores, entonces hagamos caso a la indicaci\u00f3n anterior. Guarden constantemente... Trabajemos de la misma forma que en un proyecto de software: Construyamos el proyecto pieza por pieza y realicemos pruebas antes de unir un bloque con otros. Podemos construir todos los subcircuitos adicionales que necesitemos, siempre y cuando sigamos las reglas espec\u00edficas que cada parte impone (m\u00e1s de esto a continuaci\u00f3n). Se incluyen algunos tests. S\u00f3lo se debe correr el script ./check (esto seguramente tendr\u00e1n que hacerlo en Linux, se requiere Python 3.X instalado). \u00a1Necesitaremos m\u00e1s tests! Cada equipo deber\u00eda hacer sus propios tests adicionales. En la secci\u00f3n de Testing hay algunas indicaciones de c\u00f3mo hacer pruebas adicionales. Finalmente, las dos indicaciones m\u00e1s importantes: Se les dar\u00e1n algunos armazones (harnesses) a los cuales sus circuitos se conectar\u00e1n. ASEGURENSE QUE S\u00cd SE ADAPTAN DE FORMA CORRECTA, TODOS LOS TESTS FALLAR\u00c1N SI NO LO HACEN. En el camino nos hemos encontrado con algunos problemas de git merge si ambos miembros del equipo estaban trabajando en el mismo archivo; a veces git los resolv\u00eda autom\u00e1ticamente y a veces no. En Logisim es garantizado que git NO RESOLVER\u00c1 ESTO DE FORMA CORRECTA, entonces si trabajamos en equipo NO DEBEMOS MODIFICAR EL MISMO ARCHIVO AL MISMO TIEMPO","title":"Introducci\u00f3n"},{"location":"projs/proj02/#preparacion","text":"Antes de comenzar, aseg\u00farense de que hayan le\u00eddo y comprendido todas las instrucciones del proyecto de principio a fin . Si tienen alguna pregunta, por favor dir\u00edjanse a Slack y pregunten en los canales correspondientes. Para comenzar con el proyecto, primero tienen que tener todos los archivos base, estos se encuentran aqu\u00ed . Tienen permitido trabajar en parejas o de forma individual, por lo que al aceptar la asignaci\u00f3n les preguntar\u00e1 si desean crear un grupo nuevo o unirse a uno ya existente. Si crean un grupo nuevo, ingresen un nombre que represente lo represente y que no haya sido tomado por otro. Si desean unirse a un grupo ya creado, tienen que buscar el nombre del grupo y pulsar el bot\u00f3n que dice join Tienen que tener mucho cuidado al unirse a un grupo ya existente, ya que esto no se puede cambiar despu\u00e9s, adem\u00e1s, lo consideraremos como PLAGIO si lo realizan de manera incorrecta, ya que, al hacer esto, pueden tener acceso al repositorio del otro miembro del grupo. Ya sea que se unan o creen un nuevo grupo, al finalizar el proceso les crear\u00e1 autom\u00e1ticamente un repositorio con una extensi\u00f3n que termina con su nombre de grupo. Ya habiendo hecho todo eso, pueden ejecutar los siguientes comandos abriendo una terminal ( CTRL + T ): git clone <link del repositorio>","title":"Preparaci\u00f3n"},{"location":"projs/proj02/#parte-1-register-file","text":"Como aprendimos en clase, RISC-V tiene 32 registros. En el proyecto s\u00f3lo implementaremos 9 (abajo se indica cuales) para evitar realizar trabajo repetitivo. Todas nuestras se\u00f1ales (rs1, rs2, rd) siguen siendo de 5-bits, pero s\u00f3lo se estar\u00e1n usando los registros indicados. El register file debe poder leer y escribir a los registros que se especifiquen seg\u00fan la instrucci\u00f3n, sin afectar o modificar a cualquier otro registro. Existe una excepci\u00f3n: El registro cero est\u00e1 alambrado a tierra y su valor no puede ser cambiado por ning\u00fan motivo. Los registros que utilizaremos son los siguientes: Registro por n\u00famero Registro por nombre x0 zero x1 ra x2 sp x5 t0 x6 t1 x8 s0 x9 s1 x10 a0 x11 a1 En el archivo regfile.circ se encuentra el esqueleto de un register file. Este tiene seis entradas: Nombre Ancho en bits Descripci\u00f3n Clock 1 Se\u00f1al de reloj. Aqu\u00ed se recibir\u00e1 una se\u00f1al de reloj \"non gated\", es decir, se recibe la se\u00f1al directa sin ser afectada por ANDs, NOTs o cualquier compuerta. Write Enable 1 Indica si se deber\u00eda escribir a un registro en el siguiente flanco de subida del reloj. Read Register 1 5 Registro a leer y cuyo valor ser\u00e1 enviado a Read Data 1. Read Register 2 5 Registro a leer y cuyo valor ser\u00e1 enviado a Read Data 2. Write Register 5 Determina cu\u00e1l registro ser\u00e1 modificado en el siguiente flanco de subida (asumiendo que Write Enable = 1). Write Data 32 Los 32 bits de datos a guardarse en el registro, en el siguiente flanco de subida (asumiendo que Write Enable = 1). El register file tiene las siguientes salidas: Nombre Ancho en bits Descripci\u00f3n Read Data 1 32 Datos que se est\u00e1n leyendo, seg\u00fan el registro que Read Register 1 pidi\u00f3. Read Data 2 32 Datos que se est\u00e1n leyendo, seg\u00fan el registro que Read Register 2 pidi\u00f3. s0 Value 32 Valor de s0 (salida para DEBUG/TEST). s1 Value 32 Valor de s1 (salida para DEBUG/TEST). t0 Value 32 Valor de t0 (salida para DEBUG/TEST). t1 Value 32 Valor de t1 (salida para DEBUG/TEST). a0 Value 32 Valor de a0 (salida para DEBUG/TEST). ra Value 32 Valor de ra (salida para DEBUG/TEST). sp Value 32 Valor de sp (salida para DEBUG/TEST). Las salidas para DEBUG/TEST est\u00e1n presentes porque son registros de uso frecuente (por ejemplo, tienen un trabajo importante en las llamadas a funciones). Se utilizar\u00e1n s\u00f3lo para pruebas del autograder. En un register file de verdad estas salidas no existir\u00edan. Para el proyecto deben estar presentes y funcionar bien para facilitar la calificaci\u00f3n. Pueden modificar regfile.circ como deseen, pero las salidas deben cumplir con el comportamiento que se indica. Deben ser cuidadosos de no modificar (mover, reemplazar, cortar, pegar, eliminar, etc) los pines de entrada o salida. Si necesitan m\u00e1s espacio, pueden moverlos mientras sean cuidadosos de mantener el posicionamiento relativo que estos tienen. Para verificar que nuestros cambios no \"rompan\" nada, podemos abrir regfile-harness.circ y revisar que no existan errores all\u00ed y que todo funcione bien. HINTS: (1) Cuidado con los muxes. Si estos tienen un enable ese deber\u00eda estar activo (o mejor a\u00fan, buscamos en la ayuda de Logisim c\u00f3mo quitar esa funcionalidad). (2) \u00bfTri-estado? Three-state? En CC3 no debemos pensar en estados de alta impedancia (qu'est-ce que c'est?) entonces lo mejor es deshabilitar el uso de three-state.","title":"Parte 1: Register File"},{"location":"projs/proj02/#parte-2-alu","text":"Su segunda tarea es crear un ALU que soporte todas las operaciones que necesitan las instrucciones de nuestro ISA (se detallan m\u00e1s adelante). Van a estar trabajando en el archivo alu.circ . Este tiene tres entradas: Nombre de Entrada Ancho en Bits Descripci\u00f3n A 32 Datos para usar por A en la operaci\u00f3n del ALU B 32 Datos para usar por B en la operaci\u00f3n del ALU ALU Op 4 Selecciona la operaci\u00f3n que el ALU debe de efectuar ...y cuatro salidas: Nombre de Entrada Ancho en Bits Descripci\u00f3n Out 32 Resultado de la operaci\u00f3n efectuada por el ALU Equal 1 1 si A y B son iguales; 0 de lo contrario LT 1 1 si A es menor que B (signed); 0 de lo contrario LTU 1 1 si A es menor que B (unsigned); 0 de lo contrario Esta es la lista de operaciones que necesitan implementar. Ustedes tienen que utilizar los componentes de logisim que ya efect\u00faan estas operaciones, por favor no las implementen desde cero, ser\u00eda muy tardado y no es el objetivo del proyecto. Valor de ALU Op Instrucci\u00f3n 0 sll: Out = A << B[4:0] 1 srl: Out = (unsigned) A >> B[4:0] 2 add: Out = A + B 3 and: Out = A & B 4 or: Out = A | B 5 xor: Out = A ^ B 6 slt: Out = (A < B) ? 1 : 0 Signed 7 mul: Out = (X * Y)[31:0] 8 mulh: Out = (A * B)[63:32] 9 div: Out =(unsigned) A / B 10 rem: Out = A % B 11 sub: Out = A - B Algunas cosas adicionales que tienen que tener en mente: La salidas Equal , LT , LTU siempre tienen que sacar el valor correcto de comparaci\u00f3n sin importar el valor de ALU Op . Nuevamente, tienen que tener cuidado con los inputs y output pins, no los modifiquen por ning\u00fan motivo. Su ALU deber\u00eda de encajar con el harness alu_harness.circ . Sigan las mismas instrucciones que en el register file. En particular, ustedes deber\u00edan de asegurar que su ALU es cargado correctamente por el harness antes de que hagan submit.","title":"Parte 2: ALU"},{"location":"projs/proj02/#parte-3-cpu","text":"Se les provee un esqueleto del procesador en cpu.circ . Su procesador tendr\u00e1 una instancia de su ALU y Register File, as\u00ed como una unidad de memoria que ya se les provee. Ustedes son los responsables de construir el datapath y control completos, desde cero. Su procesador debe implementar el ISA que se detalla m\u00e1s abajo. Su procesador obtendr\u00e1 su programa del armaz\u00f3n (harness) riscv.circ . Su procesador tendr\u00e1 un output llamado FETCH_ADDRESS que indica cu\u00e1l instrucci\u00f3n queremos, esta direcci\u00f3n ser\u00e1 entregada al harness y este nos dar\u00e1 una instrucci\u00f3n. La instrucci\u00f3n ser\u00e1 recibida por el procesador y ser\u00e1 ejecutada. Revisen riscv.circ para ver exactamente qu\u00e9 sucede. El procesador tiene dos inputs que vienen del harness: Input Name Bit Width Descripci\u00f3n INSTRUCTION 32 Aqu\u00ed se recibe la instrucci\u00f3n que se obtuvo en la direcci\u00f3n identificada por FETCH_ADDRESS. CLOCK 1 Input del reloj. Puede ser necesario estar enviando esta se\u00f1al a varios subcircuitos. Esta se\u00f1al no debe pasar por ninguna compuerta (NOT, AND, etc). El procesador debe tener los siguientes outputs, que entregar\u00e1 al harness: Output Name Bit Width Descripci\u00f3n s0 32 Contenido de s0, s\u00f3lo para pruebas. s1 32 Contenido de s1, s\u00f3lo para pruebas. t0 32 Contenido de t0, s\u00f3lo para pruebas. t1 32 Contenido de t1, s\u00f3lo para pruebas. a0 32 Contenido de a0, s\u00f3lo para pruebas. ra 32 Contenido de ra, s\u00f3lo para pruebas. sp 32 Contenido de sp, s\u00f3lo para pruebas. FETCH_ADDRESS 32 Direcci\u00f3n que indica qu\u00e9 instrucci\u00f3n queremos obtener del harness. En respuesta a esto, el harness enviar\u00e1 alguna instrucci\u00f3n a trav\u00e9s de INSTRUCTION. Como en la parte 1, tengan cuidado al mover componentes y aseg\u00farense que los pines de input y output coincidan con el harness.","title":"Parte 3: CPU"},{"location":"projs/proj02/#memoria","text":"Se les provee una memoria ya implementada. :D Un resumen de sus inputs y outputs. Nombre Tipo Bit Width Descripci\u00f3n ADDRESS input 32 Direcci\u00f3n a leer o escribir en la memoria. WRITE DATA input 32 Valor a escribirse en la memoria. WRITE ENABLE input 1 En = 1 en las instrucciones que escriben; En = 0 en las dem\u00e1s. Clk input 1 Se\u00f1al de reloj que viene desde cpu.circ. READ DATA output 32 Datos le\u00eddos en la direcci\u00f3n especificada.","title":"Memoria"},{"location":"projs/proj02/#control","text":"Las se\u00f1ales de control tienen un papel muy importante en el proyecto. Se sugiere volver a leer el cap\u00edtulo 4 del libro para darse cuenta d\u00f3nde podemos necesitar un MUX y, por lo tanto, alguna se\u00f1al de control. Existen varias formas de implementar las se\u00f1ales de control. Por ejemplo, pueden construir una palabra de control y guardarla en una memoria ROM (micro-codigo) o pueden construir un circuito que elija qu\u00e9 acci\u00f3n tomar bas\u00e1ndose en algunos bits del opcode, func3 y func7. Es obligatorio que sus componentes est\u00e9n unidos y las se\u00f1ales de control necesarias est\u00e9n implementadas. Si en la calificaci\u00f3n del proyecto s\u00f3lo tiene componentes sueltos (como el ALU y Reg File de la primera fase) y estos no se comunican entre s\u00ed, su nota ser\u00e1 cero. Consejo final: \u00a1Modularicen! Creen los subcircuitos que sean necesarios y dis\u00e9\u00f1enlos bien antes de empezar a construirlos.","title":"Control"},{"location":"projs/proj02/#isa","text":"Las instrucciones a implementar son las siguientes: Instruction Type Opcode Funct3 Funct7/IMM Operation add rd, rs1, rs2 R 0x33 0x0 0x00 R[rd] \u2190 R[rs1] + R[rs2] mul rd, rs1, rs2 R 0x33 0x0 0x01 R[rd] \u2190 (R[rs1] * R[rs2])[31:0] sub rd, rs1, rs2 R 0x33 0x0 0x20 R[rd] \u2190 R[rs1] - R[rs2] sll rd, rs1, rs2 R 0x33 0x1 0x00 R[rd] \u2190 R[rs1] << R[rs2 mulh rd, rs1, rs2 R 0x33 0x1 0x01 R[rd] \u2190 (R[rs1] * R[rs2])[63:32] slt rd, rs1, rs2 R 0x33 0x2 0x00 R[rd] \u2190 (R[rs1] < R[rs2]) ? 1 : 0 (signed) xor rd, rs1, rs2 R 0x33 0x4 0x00 R[rd] \u2190 R[rs1] ^ R[rs2] div rd, rs1, rs2 R 0x33 0x4 0x01 R[rd] \u2190 R[rs1] / R[rs2] srl rd, rs1, rs2 R 0x33 0x5 0x00 R[rd] \u2190 R[rs1] >> R[rs2] or rd, rs1, rs2 R 0x33 0x6 0x00 R[rd] \u2190 R[rs1] | R[rs2] rem rd, rs1, rs2 R 0x33 0x6 0x01 R[rd] \u2190 (R[rs1] % R[rs2] and rd, rs1, rs2 R 0x33 0x7 0x00 R[rd] \u2190 R[rs1] & R[rs2] lb rd, offset(rs1) I 0x03 0x0 R[rd] \u2190 SignExt(Mem(R[rs1] + offset, byte)) lh rd, offset(rs1) I 0x03 0x1 R[rd] \u2190 SignExt(Mem(R[rs1] + offset, half)) lw rd, offset(rs1) I 0x03 0x2 R[rd] \u2190 Mem(R[rs1] + offset, word) addi rd, rs1, imm I 0x13 0x0 R[rd] \u2190 R[rs1] + imm slli rd, rs1, imm I 0x13 0x1 0x00 R[rd] \u2190 R[rs1] << imm slti rd, rs1, imm I 0x13 0x2 R[rd] \u2190 (R[rs1] < imm) ? 1 : 0 xori rd, rs1, imm I 0x13 0x4 R[rd] \u2190 R[rs1] ^ imm srli rd, rs1, imm I 0x13 0x5 0x00 R[rd] \u2190 R[rs1] >> imm ori rd, rs1, imm I 0x13 0x6 R[rd] \u2190 R[rs1] | imm andi rd, rs1, imm I 0x13 0x7 R[rd] \u2190 R[rs1] & imm sw rs2, offset(rs1) S 0x23 0x2 Mem(R[rs1] + offset) \u2190 R[rs2] beq rs1, rs2, offset SB 0x63 0x0 if(R[rs1] == R[rs2]) then {PC \u2190 PC + {offset, 1b'0}} blt rs1, rs2, offset SB 0x63 0x4 if(R[rs1] less than R[rs2] (signed)) then {PC \u2190 PC + {offset, 1b'0}} bltu rs1, rs2, offset SB 0x63 0x6 if(R[rs1] less than R[rs2] (unsigned)) then {PC \u2190 PC + {offset, 1b'0}} lui rd, offset U 0x37 R[rd] \u2190 {offset, 12b'0} jal rd, imm UJ 0x6f R[rd] \u2190 PC + 4, PC \u2190 PC + {imm, 1b'0} jalr rd,rs, imm I 0x67 0x0 R[rd] \u2190 PC + 4, PC \u2190 R[rs] + {imm}","title":"ISA"},{"location":"projs/proj02/#testing","text":"Para la parte 1 y 2, con el check local es suficiente y si lo pasan significa que esas partes ya las tienen funcionando al 100%. Para la parte 2, el check local tambi\u00e9n es bastante completo, pero ustedes pueden hacer m\u00e1s pruebas si lo desean. Como no podemos probar cada componente que ustedes vayan implementando, la mejor opci\u00f3n es escribir programas de RISC-V peque\u00f1os e ir revisando su datapath de diferentes maneras. Una vez que hayan escrito su programa de RISC-V, lo van a tener que cargar en la ROM que est\u00e1 en riscv.circ y empezar la ejecuci\u00f3n. Para eso, primero, abran riscv.circ y localicen la memoria ROM. Hagan click a la memoria y, despu\u00e9s, en la barra de herramientas de la izquierda, hagan click en \"(click here to edit)\", esto va a abrir un di\u00e1logo en donde ustedes pueden cargar su archivo con el c\u00f3digo de RISC-V y este ensamblar\u00e1 y generar\u00e1 c\u00f3digo de m\u00e1quina por ustedes que va a ser la salida de la memoria ROM.","title":"Testing"},{"location":"projs/proj02/#notas-sobre-logisim","text":"Si Logisim les da alg\u00fan problema extra\u00f1o, REINICIEN LOGISIM Y VUELVAN A CARGAR SU CIRCUITO. No pierdan tiempo buscando errores si no han hecho esto. Si reiniciar no ha resuelto el problema, all\u00ed s\u00ed ya les corresponde revisar su circuito. Logisim tiene un \"Reference\", en la pesta\u00f1a \"Help\", y les dice las especificaciones de cada componente. Do NOT gate the clock! (esto no tiene una traducci\u00f3n directa). Los clocks tienen que llegar directo a los circuitos, ni en CC3 ni en un curso donde usen hardware deber\u00edan colocar compuertas antes que la se\u00f1al de reloj entre al componente. Si est\u00e1n usando varias ventanas de Logisim tengan mucho cuidado cuando hagan copy-paste de una ventana a otra. Aseg\u00farense que s\u00ed se copi\u00f3 el circuito completo que quer\u00edan y que funcione bien despu\u00e9s de pegarlo. Cuando importen otro archivo (Project -> Load Library -> Logisim Library...), este aparecer\u00e1 como un folder en el panel de la izquierda. Los archivos esqueleto deber\u00edan de tener importado todo lo necesario. Cambiar los atributos antes de colocar un componente cambia el default. Si quieren colocar varios pines de 32 bits (por ejemplo), habr\u00eda que cambiarlo antes de colocar el primero. Si s\u00f3lo quieren cambiar alg\u00fan valor para un componente, primero lo colocan y, luego, lo cambian. Cuando cambian los inputs y outputs de un subcircuito que ya colocaron en main, Logisim autom\u00e1ticamente a\u00f1ade o remueve puertos seg\u00fan los cambios que hagan. Esto, muchas veces, afecta el tama\u00f1o o posici\u00f3n del subcircuito. Si ya hab\u00edan cables conectados, Logisim intentar\u00e1 moverlos, pero no siempre lo hace bien. Se recomienda que si van a cambiar los inputs y outputs de un circuito, primero desconecten todos los cables que este pueda tener en main o lo eliminen del main y lo vuelvan a colocar despu\u00e9s de cambiarlo. Recuerden que s\u00f3lo pueden hacer esto para los subcircuitos que USTEDES agregan . Los cables rojos significan que algo est\u00e1 mal conectado. Algunos casos pueden no ser tan obvios, revisen bien todas las conexiones cercanas. Logisim tiene algunas herramientas de an\u00e1lisis combinacional (nos puede construir mapas de Karnaugh o circuitos completos con s\u00f3lo darle una tabla :D). Esta herramienta les puede ser \u00fatil en alg\u00fan momento de sus vidas, pero la recomendaci\u00f3n es no usarla en CC3. Recuerden que durante los ex\u00e1menes tendr\u00e1n que hacer mapas o circuitos a mano, sin acceso a su computadora.","title":"Notas sobre Logisim"},{"location":"projs/proj02/#calificacion","text":"Ustedes pueden verificar que cada parte funcione correctamente utilizando el autograder local, corriendo el siguiente comando en la terminal: ./check Si las tres partes del proyecto est\u00e1n correctas les saldr\u00e1 algo como esto: ___ __ __ / _ | __ __/ /____ ___ _______ ____/ /__ ____ / __ / // / __/ _ \\/ _ \\/ __/ _ \\/ _ / -_ ) __/ /_/ | _ \\_ ,_/ \\_ _/ \\_ __/ \\_ , /_/ \\_ ,_/ \\_ ,_/ \\_ _/_/ /___/ Machine Structures Great Ideas in Computer Architecture Project 2 : CPU Exercise Grade Message ---------------- ------- --------- 1 . ALU 25 passed 2 . Register File 25 passed 3 . CPU 50 passed = > Score: 100 /100 Pueden subir su proyecto para calificaci\u00f3n utilizando: ./submit <TOKEN>","title":"Calificaci\u00f3n"},{"location":"projs/proj03/","text":"Proyecto 3: Optimizaciones \u00b6 Objetivos \u00b6 Utilizar t\u00e9cnicas de programaci\u00f3n de optimizaci\u00f3n aprendidas en clase para acelerar tareas de reconocimiento de im\u00e1genes. Aplicar la ley de Amdahl para conocer las partes del programa en donde se deber\u00edan aplicar optimizaciones. Enfocarse en las optimizaciones mayores antes de tratar de hacer micro optimizaciones. Preparaci\u00f3n \u00b6 Antes de comenzar, aseg\u00farense de que hayan le\u00eddo y comprendido todas las instrucciones del proyecto de principio a fin . Si tienen alguna pregunta, por favor dir\u00edjanse a Slack y pregunten en los canales correspondientes. Para comenzar con el proyecto, primero tienen que tener todos los archivos base, estos se encuentran aqu\u00ed . Tienen permitido trabajar en parejas o de forma individual, por lo que al aceptar la asignaci\u00f3n les preguntar\u00e1 si desean crear un grupo nuevo o unirse a uno ya existente. Si crean un grupo nuevo, ingresen un nombre que los represente (seguramente un nombre raro como siempre ...) y que no haya sido tomado por otro. Si desean unirse a un grupo ya creado, tienen que buscar el nombre del grupo y pulsar el bot\u00f3n que dice join : Tienen que tener mucho cuidado al unirse a un grupo ya existente, ya que esto no se puede cambiar despu\u00e9s, adem\u00e1s, lo consideraremos como PLAGIO si lo realizan de manera incorrecta, ya que, al hacer esto, pueden tener acceso al repositorio del otro miembro del grupo y leer su c\u00f3digo. Ya sea que se unan o creen un nuevo grupo, al finalizar el proceso les crear\u00e1 autom\u00e1ticamente un repositorio con una extensi\u00f3n que termina con su nombre de grupo. Ya habiendo hecho todo eso, pueden ejecutar los siguientes comandos abriendo una terminal ( CTRL + T ): git clone <link del repositorio> Introducci\u00f3n \u00b6 En este proyecto, ustedes van a aplicar algunas t\u00e9cnicas de optimizaciones que han aprendido en clase a un problema de la vida real de clasificaci\u00f3n de im\u00e1genes utilizando una red neural convolucional (Convolutional Neural Network CNN). *Esta red neural est\u00e1 corriendo en vivo en su navegador. Cr\u00e9ditos: CS231N Las siguientes secciones los van a introducir un poco a lo que son las redes neurales convolucionales CNNs, una idea a muy alto nivel para saber que est\u00e1 pasando. No se preocupen en absoluto si ustedes no conocen mucho sobre redes neurales, este proyecto se puede terminar inspeccionando el c\u00f3digo base y, as\u00ed, encontrar patrones que se pueden beneficiar bastante de las optimizaciones. \u00bfC\u00f3mo una computadora reconoce im\u00e1genes? \u00b6 La clasificaci\u00f3n de im\u00e1genes describe un problema en donde a una computadora se le da una imagen y esta, de alguna manera, tiene que ver que hacer para saber qu\u00e9 representa (de un set posible de categor\u00edas). Antes del famoso t\u00e9rmino Deep Learning , la clasificaci\u00f3n de im\u00e1genes involucraba seleccionar un set de caracter\u00edsticas a mano, es decir, un humano experto ten\u00eda que reconocer y extraer de la imagen las caracter\u00edsticas de inter\u00e9s para poder efectuar la clasificaci\u00f3n. Actualmente, las redes convolucionales se han vuelto bastante populares para realizar esta tarea. Las CNNs existen desde los 90's pero desde el 2012, gracias a la cantidad masiva de datos y el poder computacional que nos dan las tarjetas de video, son la mejor opci\u00f3n y ya han superado al humano en esta tarea, teniendo un error de clasificaci\u00f3n menor al 5% (el error humano al clasificar im\u00e1genes del ILSVRC )... En general, las redes neurales asumen que existe cierta funci\u00f3n de la entrada (las im\u00e1genes) a la salida (un set de categor\u00edas). Los algoritmos cl\u00e1sicos tratan de codificar percepci\u00f3n del mundo real en sus funciones, mientras que las CNNs aprenden esta funci\u00f3n din\u00e1micamente de un set de im\u00e1genes etiquetadas, a este proceso se le conoce como entrenamiento o \"traning\". Una vez que ya se tiene una funci\u00f3n (m\u00e1s bien, una aproximaci\u00f3n a esta), se puede aplicar la funci\u00f3n a im\u00e1genes que el algoritmo nunca ha visto antes. Figura 1: Benchmark competencia ILSVRC Ref: https://arxiv.org/pdf/1409.0575.pdf \u00bfQu\u00e9 hacen las CNNs? \u00b6 Para este proyecto, nosotros no requerimos que ustedes entiendan c\u00f3mo funcionan las CNNs a detalle. Sin embargo, queremos darles suficiente informaci\u00f3n para que tengan conocimiento de los conceptos a alto nivel. Si ustedes quieren aprender m\u00e1s, los alentamos para que tomen alg\u00fan curso en l\u00ednea relacionado con Machine Learning o Computer Vision , hay una buena cantidad de informaci\u00f3n en internet, no desaprovechen ese recurso. A alto nivel, una CNN consiste de m\u00faltiples capas. Cada capa toma un arreglo multi-dimensional de n\u00fameros como entrada y produce otro arreglo multi-dimensional de n\u00fameros como salida (que posteriormente se vuelve la entrada de otra capa). Cuando se est\u00e1 clasificando im\u00e1genes, la entrada a la primera capa es la imagen de entrada (es decir 32x32x3 n\u00fameros para im\u00e1genes de 32x32 pixeles y 3 canales de color), mientras que la salida de la capa final es un set de probabilidades de diferentes categor\u00edas (es decir, 1x1x10 n\u00fameros si es que hay 10 categor\u00edas). Figura 2: Arquitectura general que usamos para este proyecto Cada capa tiene un set de pesos asociados, estos pesos son los que la CNN \"aprende\" cuando es entrenada con los datos que se le presentan. Dependiendo de la capa, los pesos tienen diferentes interpretaciones, pero el prop\u00f3sito de este proyecto, es suficiente con que sepan que cada capa toma la entrada, realiza algunas operaciones en ella en dependencia de estos pesos y, finalmente, produce una salida. A este paso se le conoce como el \" forward pass \": tomamos una entrada, la pasamos a trav\u00e9s de la red, produciendo el resultado deseado como salida. El forward pass es todo lo que se necesita para clasificar im\u00e1genes si la CNN ya ha sido entrenada anteriormente (como en este proyecto). En la pr\u00e1ctica, una red neural realmente resulta ser una simple composici\u00f3n de funciones que reconoce patrones (con una remarcada capacidad limitada), pero puede ser bastante bizarro lo que utiliza para hacer el reconocimiento. Por ejemplo, alguien podr\u00eda entrenar una red neural para reconocer las diferencias entre \"perros\" y \"lobos\". Y puede funcionar bastante bien... ya que esta mira la nieve y los \u00e1rboles en los bosques en el fondo de las im\u00e1genes que contienen lobos. Su tarea \u00b6 Hay mucha investigaci\u00f3n en diferentes arquitecturas de redes neurales y m\u00e9todos de entrenamiento. Un aspecto crucial de las redes neurales es que, dada una red entrenada, esta pueda clasificar im\u00e1genes de una forma r\u00e1pida y precisa. Para este proyecto, se les estar\u00e1 dando una red pre-entrenada que puede clasificar im\u00e1genes RGB de 32x32 en 10 categor\u00edas o clases diferentes. Las im\u00e1genes a utilizar fueron tomadas del dataset famoso CIFAR-10 . La red va a tener los pesos ya entrenados y el algoritmo para calcular el forward pass de la red neural tambi\u00e9n se les da. Ustedes van invertir su tiempo en acelerar el forward pass, de tal manera que la red pueda clasificar im\u00e1genes a una tasa m\u00e1s elevada. Paso 1: Entendiendo el C\u00f3digo \u00b6 Por favor lean esta secci\u00f3n antes de tratar de implementar cualquier cosa. Hay una cantidad considerable de c\u00f3digo en este proyecto, as\u00ed que es crucial que ustedes tengan un conocimiento general de cada archivo. Este proyecto es m\u00e1s abierto que los proyectos anteriores, ustedes pueden acelerar la aplicaci\u00f3n en cualquier n\u00famero de formas, siempre que este siga teniendo un resultado correcto. \u00a1Que esto no los intimide! Es posible obtener la aceleraci\u00f3n requerida sin aplicar cada optimizaci\u00f3n existente. Estructura del Directorio \u00b6 Cuando obtienen los archivos base de GitHub classroom, el directorio principal tiene una estructura como la siguiente: check data/ LICENSE Makefile README.md snapshot/ src/ submit test/ Para este proyecto, los \u00fanicos archivos que deber\u00edan de modificar (y por consecuencia los \u00fanicos que se subir\u00e1n al autograder) son : src/optimized/layers.c src/optimized/network.c src/optimized/volume.c Esto implica que, mientras ustedes son libres de escribir sus propias funciones de ayuda en cualquiera de estos archivos, el uso de estas estar\u00e1 restringido al archivo donde las definieron, ya que ustedes no pueden editar ni modificar los archivos .h . Por conveniencia, les hemos prove\u00eddo los archivos src/baseline/layers.c , src/baseline/network.c , src/baseline/volume.c . Los archivos que est\u00e1n en src/baseline no deber\u00edan de ser modificados cuando est\u00e9n escribiendo su c\u00f3digo optimizado, est\u00e1n \u00fanicamente para que ustedes puedan: Medir la aceleraci\u00f3n con respecto a una implementaci\u00f3n b\u00e1sica. Hacer referencia a una implementaci\u00f3n correcta (pero lenta). Visi\u00f3n general del C\u00f3digo \u00b6 Hay un n\u00famero de datatypes que son utilizados en este proyecto. Por datatype , nos referimos a estructuras de C con nombres significativos, gracias a typedef . Nosotros los alentamos bastante a que miren los archivos .h que est\u00e1n en src/include para ver los campos que cada datatype tiene. Los archivos .h es donde ustedes van a encontrar, tambi\u00e9n, una descripci\u00f3n a alto nivel de lo que hace cada funci\u00f3n. Para la implementaci\u00f3n en src/baseline/layers.c , tambi\u00e9n hay comentarios con explicaciones detalladas de lo que el c\u00f3digo est\u00e1 haciendo. El primer datatype que vamos a considerar es el tipo volume_t , que contiene un arreglo 3D (o volumen) de n\u00fameros en precisi\u00f3n doble. Estos son utilizados para representar los resultados de cada capa, as\u00ed como los pesos asociados a algunas de las capas. Despu\u00e9s, tenemos un n\u00famero diferente de tipos de capas: conv , relu , pool , fc y softmax . Ustedes no tienen que entender qu\u00e9 hacen estas diferentes capas, pero cada una de ellas tiene: Una estructura de datos que tiene una descripci\u00f3n de los par\u00e1metros de la capa. Noten que cada capa tiene un set fijo de par\u00e1metros que no pueden cambiar durante la ejecuci\u00f3n. Estos determinan (por ejemplo) el tama\u00f1o de los vol\u00famenes de su entrada y salida y estos son puestos cuando se define la CNN. Por ejemplo, la CNN que estamos utilizando tiene 3 capas conv , cada con par\u00e1metros un poco diferentes. Una funci\u00f3n _forward que calcula la operaci\u00f3n principal de la capa. Estas funciones, toman la estructura de la capa, as\u00ed como un arreglo de punteros hacia los vol\u00famenes de entrada y salida de la capa. Tambi\u00e9n, aceptan los \u00edndices start y end del arreglo. Esto le permite a cada capa procesar un \"batch\" de entradas a la vez. Por ejemplo, ustedes podr\u00edan tener un arreglo con punteros a vol\u00famenes de entrada y hacer que start = 5 y end = 9 para procesar las entradas 5, 6, 7, 8 y 9 al mismo tiempo y escribir los resultados en las posiciones correspondientes del arreglo de salida. Dos funciones: make_ y _load . La primera genera una capa con un set de par\u00e1metros espec\u00edficos; la segunda carga los pesos para esta capa desde el \"file system\". La \u00faltima estructura importante es network_t , que contiene toda la informaci\u00f3n que describe una CNN. Esto incluye todas las capas y una instancia de cada uno de los diferentes vol\u00famenes intermedios. Noten que estos vol\u00famenes no son usados para almacenar datos (esto es hecho por los batches que vamos a describir m\u00e1s adelante). Estan all\u00ed para que las dimensiones de cada diferente volumen est\u00e9n disponibles de manera f\u00e1cil en un solo lugar. Todos los datos intermedios son representados por batches . Ustedes pueden pensar de ellos como un set de datos intermedios asociados a un set de im\u00e1genes de entrada. Mientras que su tipo se mira complicado ( batch_t es equivalente a volume_t*** ), estos son solamente arreglos 2D de punteros hacia vol\u00famenes. La primera dimensi\u00f3n les dice a qu\u00e9 capa pertenece el volumen (V0, V1, etc., en la Figura 2 de arriba) y la segunda dimensi\u00f3n, les dice qu\u00e9 entrada est\u00e1n viendo. En el c\u00f3digo base que les hemos dado, nosotros solo utilizamos batches de tama\u00f1o 1 (es decir que solo procesamos una imagen a la vez), pero ustedes van a tener que modificar su programa para considerar batches m\u00e1s largos, de tal manera que se pueda paralelizar la tarea. Los batches pueden ser reservados utilizando la funci\u00f3n make_batch y pueden ser liberados utilizando la funci\u00f3n free_batch . Finalmente, la funci\u00f3n net_forward toma un batch (as\u00ed como los \u00edndices start / end ) y aplica la CNN a cada entrada desde start a end , llamando a las funciones forward para cada capa. Esta funci\u00f3n es utilizada en net_classify para tomar un set de im\u00e1genes de entrada, ponerlas en el volumen V0 como un batch y, entonces, correr la red neural en ese batch de im\u00e1genes. Nostros guardamos las probabilidades (es decir los valores en la \u00faltima capa de la red) en una matriz 2D de n\u00fameros de precisi\u00f3n doble, de tal manera que podamos ver c\u00f3mo la red clasifica una imagen. Tengan cuidado con estas funciones: son llamadas por el c\u00f3digo de benchmarking, as\u00ed que la firma y su salida no deber\u00edan de ser modificadas por sus optimizaciones. Conclusi\u00f3n \u00b6 Nosotros reconocemos que es mucha informaci\u00f3n para digerir y que la informaci\u00f3n de arriba no es suficiente para entender totalmente cada detalle del c\u00f3digo. Afortunadamente, ustedes no necesitan hacerlo para hacer que corra de manera m\u00e1s r\u00e1pida: mirando la estructura del c\u00f3digo, ustedes deber\u00edan de ver las potenciales fuentes de paralelismo y otras formas de optimizar su c\u00f3digo. M\u00e1s abajo, les daremos los primeros pasos (algunos) para comenzar y, tambi\u00e9n, les vamos a dar un n\u00famero de propuestas que pueden intentar. A partir de all\u00ed, ustedes deber\u00edan de experimentar diferentes t\u00e9cnicas y ver si funcionan bien. Paso 2: Perfilamiento y Ley de Amdahl \u00b6 Siempre que ustedes empiecen a optimizar alg\u00fan c\u00f3digo dado, primero, tienen que determinar en d\u00f3nde es que se gasta la mayor parte del tiempo. Por ejemplo, acelerar una parte que \u00fanicamente toma 5% del tiempo total les va a dar como m\u00e1ximo una aceleraci\u00f3n del 5% y es probable que no valga su tiempo y esfuerzo. En clase, ustedes oyeron acerca de la ley de Amdahl, que es una manera genial para estimar el impacto del performance esperado de una optimizaci\u00f3n. Como vimos en clase, para aplicar la ley de Amdahl, primero tenemos que encontrar que fracci\u00f3n del tiempo se gastan en diferentes partes del programa. Utilizando Gprof \u00b6 Antes de hacer cualquier cosa primero tienen que descargar el dataset que vamos a estar utilizando: cd data ./download cd .. Gprof es una herramienta que vamos a estar utilizando para perfilar el c\u00f3digo base para ver que funciones se pueden beneficiar de alguna optimizaci\u00f3n. Para correr Gprof, ustedes tienen que compilar el c\u00f3digo base utilizando la bandera \" -pg \": make clean make baseline CFLAGS = \"-Wall -Isrc/include -Wno-unused-result -march=haswell -std=c99 -fopenmp -pg -O0\" Despu\u00e9s, tenemos que correr el c\u00f3digo base. Dado que Gprof est\u00e1 recolectando estad\u00edsticas acerca del programa, va a tomar un poco m\u00e1s de tiempo que lo usual (a nosotros nos tom\u00f3 alrededor de dos minutos para que terminara). ./baseline benchmark Finalmente, necesitamos ver los resultados de Gprof. gprof baseline | less Este comando que acabamos de ejecutar deber\u00eda de mostrar una cantidad de texto. Para este proyecto, estamos interesados en la tabla de arriba que tiene los siguientes headers: % cumulative self self total time seconds seconds calls s/call s/call name Las columnas de m\u00e1s inter\u00e9s son: % time : La cantidad de tiempo que gastamos en una funci\u00f3n. calls : El n\u00famero de veces que llamamos a una funci\u00f3n. name : El nombre de la funci\u00f3n. Interpretando los Resultados \u00b6 Primero, lista el top 10 de funciones utilizando el porcentaje de tiempo que nuestro programa gasta en cada una de ellas. La ley de Amdahl nos dice que funciones se pueden beneficiar m\u00e1s de las optimizaciones, as\u00ed que recomendamos que ustedes pongan su atenci\u00f3n a estas funciones. Noten que algunas funciones que son relativamente sencillas pueden estar en este top 10 porque estas son llamadas muchas veces (en el orden de los millones para algunas, comparado con miles para otras). Mientras que, optimizar estas, pueden acelerar su programa, estas funciones pueden ser tan cortas que podr\u00eda ser muy dif\u00edcil de optimizar. Tengan en cuenta esto si quieren optimizar estas. Perfilamiento Intermedio \u00b6 Si ustedes alguna vez quieren perfilar su c\u00f3digo optimizado para seguir viendo d\u00f3nde enfocarse despu\u00e9s, pueden correr los siguientes comandos: make clean make optimized CFLAGS = \"-Wall -Isrc/include -Wno-unused-result -march=haswell -std=c99 -fopenmp -pg -O0\" ./optimized benchmark gprof optimized | less Estos tiempos no van a ser completamente confiables dado que Gprof hace lenta la ejecuci\u00f3n, pero les van a dar una idea general de qu\u00e9 fracci\u00f3n del tiempo usa cada funci\u00f3n. Paso 3: Loop Unrolling y otras optimizaciones \u00b6 En el paso 2, encontramos las funciones que val\u00edan la pena optimizar. Ustedes deber\u00edan de optimizar estas aplicando t\u00e9cnicas convencionales de optimizaci\u00f3n (sin SIMD o m\u00faltiples threads). Nosotros no les vamos a decir los pasos exactos a seguir, pero aqu\u00ed hay algunas propuestas que les van a ayudar a empezar: A veces pueden reemplazar una funci\u00f3n por m\u00faltiples funciones especializadas que realizan la misma cosa pero est\u00e1n optimizadas para valores de entrada espec\u00edficos. Ustedes, despu\u00e9s, deber\u00edan de llamar a estas funciones especializadas desde la funci\u00f3n original, cuando ustedes piensen que aplique. \u00bfHay algunos lugares en el programa donde una variable siempre tiene el mismo valor, pero es cargado de la memoria todo el tiempo? \u00bfHay algunos lugares donde ustedes podr\u00edan hacer manualmente el loop unrolling?. \u00bfPueden clasificar m\u00faltiples ejemplos a la vez, en vez de clasificar uno despu\u00e9s de otro? \u00bfHay alg\u00fan orden mejor para los diferentes loops? Noten que todas las propuestas de arriba est\u00e1n relacionadas en pr\u00e1cticas generales de optimizaci\u00f3n. Ustedes no necesariamente necesitan hacer todas estas para poder alcanzar un buen \"performance\". Una vez hayan mejorado el performance utilizando estas optimizaciones, ustedes pueden empezar a aplicar vectorizaci\u00f3n y paralelismo para hacer el programa a\u00fan m\u00e1s r\u00e1pido. Noten que ustedes tienen libertad de aplicar cualquiera de estas optimizaciones y que hay m\u00e1s de una soluci\u00f3n correcta. Traten de experimentar con diferentes aproximaciones y vean cu\u00e1l de todas les da el mejor performance. Paso 4: Instrucciones SIMD \u00b6 En el lab 10, ustedes aprendieron como aplicar instrucciones SIMD para mejorar el performance de un programa. El procesador de las instancias de Amazon soporta la extensi\u00f3n AVX, que les deja hacer operaciones SIMD en valores de 256 bits (no solo 128 bits, como vimos en el laboratorio). Ustedes deber\u00edan de utilizar estas extensiones para calcular cuatro operaciones en paralelo (ya que todos los valores de punto flotante son en precisi\u00f3n doble, que son 64 bits). Como un recordatorio, ustedes pueden utilizar la Gu\u00eda de Intel de Intrinsics como referencia para ver las instrucciones relevantes. Ustedes tienen que utilizar el tipo de dato __m256d para almacenar 4 valores double en un registro YMM y, despu\u00e9s, utilizar instrucciones _mm256_* intrinsics para operar. Paso 5: OpenMP \u00b6 Finalmente, ustedes deber\u00edan de utilizar OpenMP para paralelizar el c\u00f3mputo. Noten que la forma m\u00e1s f\u00e1cil de paralelizar la clasificaci\u00f3n de un gran n\u00famero de im\u00e1genes es clasificar batches de ellas en paralelo (dado que estos batches son independientes). Noten que ustedes van a necesitar asegurarse que ninguno de los diferentes threads sobreescriban los datos de otro. Solo utilizando #pragma omp parallel for puede causar errores, o tal vez no si lo hacen de manera correcta. Noten que las instancias de Amazon que van a utilizar tienen ocho cores con un thread por cada core. Esto quiere decir que ustedes deber\u00edan de esperar una aceleraci\u00f3n aprox de ~8x. Pruebas de Funcionamiento Correcto \u00b6 Primero, tienen que descargar el dataset, si es que todav\u00eda no lo han hecho: cd data ./download cd .. Luego, tienen que compilar el c\u00f3digo de la siguiente manera: make clean && make Benchmark regular \u00b6 Ustedes pueden correr ./optimized benchmark Para probar qu\u00e9 tan r\u00e1pido corre su c\u00f3digo en un subset de 1200 im\u00e1genes. El c\u00f3digo base toma alrededor de trece segundos en terminar en las instancias de Amazon que vamos a utilizar para calificar. Si ustedes corren este programa sin arguments adicionales, van a poder observar la siguiente salida: RUNNING BENCHMARK ON 1200 PICTURES... Making network... Loading batches... Loading input batch 0 ... Running classification... 78 .250000% accuracy _________ microseconds Su salida va a tener un n\u00famero que representa qu\u00e9 tanto tiempo le tom\u00f3 a la red clasificar esas im\u00e1genes. Noten que solo estamos midiendo el tiempo de clasificaci\u00f3n de su red. El tiempo que le toma para cargar las im\u00e1genes, ponerlas en memoria y otras tareas no son incluidas. La l\u00ednea de accuracy es una referencia r\u00e1pida para asegur\u00e1rse de que su implementaci\u00f3n es correcta. Si el accuracy es diferente (no igual a 78.25%), eso significa que hay alg\u00fan problema con su implementaci\u00f3n. Para una vista m\u00e1s detallada de lo que est\u00e1 mal con su c\u00f3digo, pueden correr ./check simple o ./check huge para verificar las capas que pueden tener alg\u00fan error. Si el test toma demasiado tiempo, pueden correr el test con un n\u00famero menor de im\u00e1genes: ./optimized benchmark n Donde n es un entero que representa la cantidad de im\u00e1genes que quieren correr en el benchmark. Noten que, en este caso, el accuracy puede no ser el mismo, o igual a 78.25%, dado que estamos probando en un subset diferente de im\u00e1genes. Para asegurarse de que su implementaci\u00f3n est\u00e9 correcta, pueden correr los siguientes comandos: ./baseline benchmark n Ahora, pueden comparar los accuracies que sacaron estos dos comandos y, si estos no son los mismos, esto significa que definitivamente hay alg\u00fan bug en su implementaci\u00f3n. Sin embargo, incluso si son las mismas, ustedes siempre deber\u00edan utilizar estos dos siguientes m\u00e9todos para verificar completamente que su implementaci\u00f3n est\u00e1 correcta. 1. ./check simple \u00b6 Este script corre su red con veinte im\u00e1genes y saca los valores exactos de cada capa de la red; compara estos valores con otros valores de referencia que nosotros generamos con el c\u00f3digo no optimizado y verifica si estos valores son los mismos o no (hasta cierto grado de error, debido a errores de punto flotante). Tambi\u00e9n, corre su c\u00f3digo en subsets de im\u00e1genes grandes para tomar en cuenta los errores de paralelismo. Para estas pruebas, nosotros solo comparamos la salida de la \u00faltima capa de su red con la versi\u00f3n no optimizada. Esta es una prueba m\u00e1s detallada que solamente correr ./optimized benchmark , ya que se asegura que su red est\u00e9 computando virtualmente las mismas operaciones como el c\u00f3digo base. Les recomendamos utilizar esta prueba despu\u00e9s de hacer cualquier tipo de modificaci\u00f3n mayor a su c\u00f3digo para asegurarse de que no afecte la validez del c\u00f3digo. 2. ./check huge \u00b6 Este script es lo mismo que el anterior, solamente que corre el c\u00f3digo en subsets de im\u00e1genes bastante largos. Ustedes no deber\u00edan de utilizar este script muy seguido (ya que toma una cantidad de tiempo considerable en ejecutarse), pero les recomendamos que, aunque sea, lo ejecuten una vez antes de subir su proyecto al autograder. Debugging \u00b6 Nosotros recomendamos que utilicen CGDB y Valgrind para encontrar bugs en su proyecto. Para usar CGDB, necesitamos utilizar la bandera \" -g \" en la variable CFLAGS para que los s\u00edmbolos de depuraci\u00f3n se generen. Podemos lograr esto haciendo lo siguiente: make CFLAGS=\"-Wall -Isrc/include -Wno-unused-result -march=haswell -std=c99 -fopenmp -g -O0\" cgdb ./optimized Luego, en CGDB, ustedes pueden poner breakpoints y ejecutar run optimized Para comenzar a depurar. Si ustedes encuentran alg\u00fan segmentation fault , Valgrind es una buena herramienta para encontrar d\u00f3nde est\u00e1 occurriendo. Un comando ejemplo que podr\u00edan ejecutar es: valgrind --leak-check = full --show-leak-kinds = all ./optimized benchmark Noten que su programa puede tomar m\u00e1s tiempo en ejecutarse al utilizar Valgrind. Si no tienen Valgrind instalado pueden utilizar el siguiente comando para instalarlo: sudo apt install valgrind R\u00fabrica de Calificaci\u00f3n \u00b6 En este proyecto su calificaci\u00f3n va a ser determinada basada en qu\u00e9 tan r\u00e1pido su c\u00f3digo corre relativamente a la soluci\u00f3n b\u00e1sica que les damos (speedup). Noten que si su implementaci\u00f3n no pasa ./check simple , van a recibir un 0 en el autograder. Vamos a utilizar la siguiente funci\u00f3n para determinar su nota: grade ( speedup ): if 0 <= speedup < 1 : 0 if 1 <= speedup <= 16 : 1 - ( speedup - 16 ) ^ 2 / 225 if speedup > 16 : 1 Para referencia, aqu\u00ed est\u00e1n las notas para algunos de los valores de speedup: Speedup Nota 16X 100% 14X ~98% 12X ~93% 10X ~84% 8X ~72% 6X ~56% 4X ~36% 2X ~13% Su speedup va a ser basado en qu\u00e9 tan r\u00e1pido es su c\u00f3digo en nuestras pruebas utilizando AWS. ./check speedup es un buen estimado de que tan r\u00e1pido es su c\u00f3digo a comparaci\u00f3n del que les damos. Calificaci\u00f3n \u00b6 Por favor empiecen lo antes posible, porque vamos a utilizar instancias de Amazon para el autograder y este solo puede procesar 4 submits al mismo tiempo (esto por lo general toma bastante tiempo en completarse). Para este proyecto vamos a limitar la cantidad de veces que ustedes pueden hacer submit, a 20 por persona debido a cuestiones de cr\u00e9ditos. S\u00ed, si ustedes van en pareja, en teor\u00eda tendr\u00edan 40 submits. De esta manera, tal vez motivamos la colaboraci\u00f3n. Les recomendamos que prueben en una computadora con un procesador intel con extensi\u00f3n AVX habilitada antes de gastar sus cr\u00e9ditos. Pueden ir al laboratorio para esto si no tienen una. Las medidas no van a ser exactas, pero les dar\u00e1n una idea. Para ver su speedup aproximado pueden ejecutar los siguientes comandos: make clean && make ./check speedup Para ver el speedup real pueden subir su implementaci\u00f3n al autograder, haciendo lo siguiente: ./submit <TOKEN> lo que va a resultar en algo parecido a esto: ___ __ __ / _ | __ __/ /____ ___ _______ ____/ /__ ____ / __ / // / __/ _ \\/ _ \\/ __/ _ \\/ _ / -_ ) __/ /_/ | _ \\_ ,_/ \\_ _/ \\_ __/ \\_ , /_/ \\_ ,_/ \\_ ,_/ \\_ _/_/ /___/ Machine Structures Great Ideas in Computer Architecture Repo: proj3_optimizations Best Score: 100 /100 Last Output: Exercise Grade Message -------------------------- ------- -------------------- 1 . Performance Programming 100 passed: speedup: 16X En su p\u00e1gina de Dashboard hay un nuevo link llamado Project 3 Race , si le dan click van a ver algo parecido a lo siguiente: Este es un tablero de posiciones, donde pueden ver los speedups alcanzados por sus otros compa\u00f1eros de todas las secciones, si ustedes quedan dentro de los primeros 3 lugares y con un speedup mayor a 12X pueden recibir cierta cantidad de puntos extra , m\u00e1s adelante les diremos cu\u00e1nto exactamente... Como es un tablero donde aparecen los nombres de forma individual y no los grupos, si el primer y segundo lugar (por ejemplo) pertenecen al mismo grupo, el grupo recibir\u00e1 los puntos del primer lugar, y entonces el tercer lugar ser\u00eda el segundo lugar realmente. Esto es al estilo \"ANSI C Race\", para motivarlos a hacer su mejor esfuerzo y el mejor trabajo posible. Los auxiliares de este curso har\u00e1n el proyecto tambi\u00e9n, si alguno de ustedes supera el speedup de un auxiliar, ustedes pueden obtener otra bonificaci\u00f3n.","title":"Proyecto 3: Optimizaciones"},{"location":"projs/proj03/#proyecto-3-optimizaciones","text":"","title":"Proyecto 3: Optimizaciones"},{"location":"projs/proj03/#objetivos","text":"Utilizar t\u00e9cnicas de programaci\u00f3n de optimizaci\u00f3n aprendidas en clase para acelerar tareas de reconocimiento de im\u00e1genes. Aplicar la ley de Amdahl para conocer las partes del programa en donde se deber\u00edan aplicar optimizaciones. Enfocarse en las optimizaciones mayores antes de tratar de hacer micro optimizaciones.","title":"Objetivos"},{"location":"projs/proj03/#preparacion","text":"Antes de comenzar, aseg\u00farense de que hayan le\u00eddo y comprendido todas las instrucciones del proyecto de principio a fin . Si tienen alguna pregunta, por favor dir\u00edjanse a Slack y pregunten en los canales correspondientes. Para comenzar con el proyecto, primero tienen que tener todos los archivos base, estos se encuentran aqu\u00ed . Tienen permitido trabajar en parejas o de forma individual, por lo que al aceptar la asignaci\u00f3n les preguntar\u00e1 si desean crear un grupo nuevo o unirse a uno ya existente. Si crean un grupo nuevo, ingresen un nombre que los represente (seguramente un nombre raro como siempre ...) y que no haya sido tomado por otro. Si desean unirse a un grupo ya creado, tienen que buscar el nombre del grupo y pulsar el bot\u00f3n que dice join : Tienen que tener mucho cuidado al unirse a un grupo ya existente, ya que esto no se puede cambiar despu\u00e9s, adem\u00e1s, lo consideraremos como PLAGIO si lo realizan de manera incorrecta, ya que, al hacer esto, pueden tener acceso al repositorio del otro miembro del grupo y leer su c\u00f3digo. Ya sea que se unan o creen un nuevo grupo, al finalizar el proceso les crear\u00e1 autom\u00e1ticamente un repositorio con una extensi\u00f3n que termina con su nombre de grupo. Ya habiendo hecho todo eso, pueden ejecutar los siguientes comandos abriendo una terminal ( CTRL + T ): git clone <link del repositorio>","title":"Preparaci\u00f3n"},{"location":"projs/proj03/#introduccion","text":"En este proyecto, ustedes van a aplicar algunas t\u00e9cnicas de optimizaciones que han aprendido en clase a un problema de la vida real de clasificaci\u00f3n de im\u00e1genes utilizando una red neural convolucional (Convolutional Neural Network CNN). *Esta red neural est\u00e1 corriendo en vivo en su navegador. Cr\u00e9ditos: CS231N Las siguientes secciones los van a introducir un poco a lo que son las redes neurales convolucionales CNNs, una idea a muy alto nivel para saber que est\u00e1 pasando. No se preocupen en absoluto si ustedes no conocen mucho sobre redes neurales, este proyecto se puede terminar inspeccionando el c\u00f3digo base y, as\u00ed, encontrar patrones que se pueden beneficiar bastante de las optimizaciones.","title":"Introducci\u00f3n"},{"location":"projs/proj03/#como-una-computadora-reconoce-imagenes","text":"La clasificaci\u00f3n de im\u00e1genes describe un problema en donde a una computadora se le da una imagen y esta, de alguna manera, tiene que ver que hacer para saber qu\u00e9 representa (de un set posible de categor\u00edas). Antes del famoso t\u00e9rmino Deep Learning , la clasificaci\u00f3n de im\u00e1genes involucraba seleccionar un set de caracter\u00edsticas a mano, es decir, un humano experto ten\u00eda que reconocer y extraer de la imagen las caracter\u00edsticas de inter\u00e9s para poder efectuar la clasificaci\u00f3n. Actualmente, las redes convolucionales se han vuelto bastante populares para realizar esta tarea. Las CNNs existen desde los 90's pero desde el 2012, gracias a la cantidad masiva de datos y el poder computacional que nos dan las tarjetas de video, son la mejor opci\u00f3n y ya han superado al humano en esta tarea, teniendo un error de clasificaci\u00f3n menor al 5% (el error humano al clasificar im\u00e1genes del ILSVRC )... En general, las redes neurales asumen que existe cierta funci\u00f3n de la entrada (las im\u00e1genes) a la salida (un set de categor\u00edas). Los algoritmos cl\u00e1sicos tratan de codificar percepci\u00f3n del mundo real en sus funciones, mientras que las CNNs aprenden esta funci\u00f3n din\u00e1micamente de un set de im\u00e1genes etiquetadas, a este proceso se le conoce como entrenamiento o \"traning\". Una vez que ya se tiene una funci\u00f3n (m\u00e1s bien, una aproximaci\u00f3n a esta), se puede aplicar la funci\u00f3n a im\u00e1genes que el algoritmo nunca ha visto antes. Figura 1: Benchmark competencia ILSVRC Ref: https://arxiv.org/pdf/1409.0575.pdf","title":"\u00bfC\u00f3mo una computadora reconoce im\u00e1genes?"},{"location":"projs/proj03/#que-hacen-las-cnns","text":"Para este proyecto, nosotros no requerimos que ustedes entiendan c\u00f3mo funcionan las CNNs a detalle. Sin embargo, queremos darles suficiente informaci\u00f3n para que tengan conocimiento de los conceptos a alto nivel. Si ustedes quieren aprender m\u00e1s, los alentamos para que tomen alg\u00fan curso en l\u00ednea relacionado con Machine Learning o Computer Vision , hay una buena cantidad de informaci\u00f3n en internet, no desaprovechen ese recurso. A alto nivel, una CNN consiste de m\u00faltiples capas. Cada capa toma un arreglo multi-dimensional de n\u00fameros como entrada y produce otro arreglo multi-dimensional de n\u00fameros como salida (que posteriormente se vuelve la entrada de otra capa). Cuando se est\u00e1 clasificando im\u00e1genes, la entrada a la primera capa es la imagen de entrada (es decir 32x32x3 n\u00fameros para im\u00e1genes de 32x32 pixeles y 3 canales de color), mientras que la salida de la capa final es un set de probabilidades de diferentes categor\u00edas (es decir, 1x1x10 n\u00fameros si es que hay 10 categor\u00edas). Figura 2: Arquitectura general que usamos para este proyecto Cada capa tiene un set de pesos asociados, estos pesos son los que la CNN \"aprende\" cuando es entrenada con los datos que se le presentan. Dependiendo de la capa, los pesos tienen diferentes interpretaciones, pero el prop\u00f3sito de este proyecto, es suficiente con que sepan que cada capa toma la entrada, realiza algunas operaciones en ella en dependencia de estos pesos y, finalmente, produce una salida. A este paso se le conoce como el \" forward pass \": tomamos una entrada, la pasamos a trav\u00e9s de la red, produciendo el resultado deseado como salida. El forward pass es todo lo que se necesita para clasificar im\u00e1genes si la CNN ya ha sido entrenada anteriormente (como en este proyecto). En la pr\u00e1ctica, una red neural realmente resulta ser una simple composici\u00f3n de funciones que reconoce patrones (con una remarcada capacidad limitada), pero puede ser bastante bizarro lo que utiliza para hacer el reconocimiento. Por ejemplo, alguien podr\u00eda entrenar una red neural para reconocer las diferencias entre \"perros\" y \"lobos\". Y puede funcionar bastante bien... ya que esta mira la nieve y los \u00e1rboles en los bosques en el fondo de las im\u00e1genes que contienen lobos.","title":"\u00bfQu\u00e9 hacen las CNNs?"},{"location":"projs/proj03/#su-tarea","text":"Hay mucha investigaci\u00f3n en diferentes arquitecturas de redes neurales y m\u00e9todos de entrenamiento. Un aspecto crucial de las redes neurales es que, dada una red entrenada, esta pueda clasificar im\u00e1genes de una forma r\u00e1pida y precisa. Para este proyecto, se les estar\u00e1 dando una red pre-entrenada que puede clasificar im\u00e1genes RGB de 32x32 en 10 categor\u00edas o clases diferentes. Las im\u00e1genes a utilizar fueron tomadas del dataset famoso CIFAR-10 . La red va a tener los pesos ya entrenados y el algoritmo para calcular el forward pass de la red neural tambi\u00e9n se les da. Ustedes van invertir su tiempo en acelerar el forward pass, de tal manera que la red pueda clasificar im\u00e1genes a una tasa m\u00e1s elevada.","title":"Su tarea"},{"location":"projs/proj03/#paso-1-entendiendo-el-codigo","text":"Por favor lean esta secci\u00f3n antes de tratar de implementar cualquier cosa. Hay una cantidad considerable de c\u00f3digo en este proyecto, as\u00ed que es crucial que ustedes tengan un conocimiento general de cada archivo. Este proyecto es m\u00e1s abierto que los proyectos anteriores, ustedes pueden acelerar la aplicaci\u00f3n en cualquier n\u00famero de formas, siempre que este siga teniendo un resultado correcto. \u00a1Que esto no los intimide! Es posible obtener la aceleraci\u00f3n requerida sin aplicar cada optimizaci\u00f3n existente.","title":"Paso 1: Entendiendo el C\u00f3digo"},{"location":"projs/proj03/#estructura-del-directorio","text":"Cuando obtienen los archivos base de GitHub classroom, el directorio principal tiene una estructura como la siguiente: check data/ LICENSE Makefile README.md snapshot/ src/ submit test/ Para este proyecto, los \u00fanicos archivos que deber\u00edan de modificar (y por consecuencia los \u00fanicos que se subir\u00e1n al autograder) son : src/optimized/layers.c src/optimized/network.c src/optimized/volume.c Esto implica que, mientras ustedes son libres de escribir sus propias funciones de ayuda en cualquiera de estos archivos, el uso de estas estar\u00e1 restringido al archivo donde las definieron, ya que ustedes no pueden editar ni modificar los archivos .h . Por conveniencia, les hemos prove\u00eddo los archivos src/baseline/layers.c , src/baseline/network.c , src/baseline/volume.c . Los archivos que est\u00e1n en src/baseline no deber\u00edan de ser modificados cuando est\u00e9n escribiendo su c\u00f3digo optimizado, est\u00e1n \u00fanicamente para que ustedes puedan: Medir la aceleraci\u00f3n con respecto a una implementaci\u00f3n b\u00e1sica. Hacer referencia a una implementaci\u00f3n correcta (pero lenta).","title":"Estructura del Directorio"},{"location":"projs/proj03/#vision-general-del-codigo","text":"Hay un n\u00famero de datatypes que son utilizados en este proyecto. Por datatype , nos referimos a estructuras de C con nombres significativos, gracias a typedef . Nosotros los alentamos bastante a que miren los archivos .h que est\u00e1n en src/include para ver los campos que cada datatype tiene. Los archivos .h es donde ustedes van a encontrar, tambi\u00e9n, una descripci\u00f3n a alto nivel de lo que hace cada funci\u00f3n. Para la implementaci\u00f3n en src/baseline/layers.c , tambi\u00e9n hay comentarios con explicaciones detalladas de lo que el c\u00f3digo est\u00e1 haciendo. El primer datatype que vamos a considerar es el tipo volume_t , que contiene un arreglo 3D (o volumen) de n\u00fameros en precisi\u00f3n doble. Estos son utilizados para representar los resultados de cada capa, as\u00ed como los pesos asociados a algunas de las capas. Despu\u00e9s, tenemos un n\u00famero diferente de tipos de capas: conv , relu , pool , fc y softmax . Ustedes no tienen que entender qu\u00e9 hacen estas diferentes capas, pero cada una de ellas tiene: Una estructura de datos que tiene una descripci\u00f3n de los par\u00e1metros de la capa. Noten que cada capa tiene un set fijo de par\u00e1metros que no pueden cambiar durante la ejecuci\u00f3n. Estos determinan (por ejemplo) el tama\u00f1o de los vol\u00famenes de su entrada y salida y estos son puestos cuando se define la CNN. Por ejemplo, la CNN que estamos utilizando tiene 3 capas conv , cada con par\u00e1metros un poco diferentes. Una funci\u00f3n _forward que calcula la operaci\u00f3n principal de la capa. Estas funciones, toman la estructura de la capa, as\u00ed como un arreglo de punteros hacia los vol\u00famenes de entrada y salida de la capa. Tambi\u00e9n, aceptan los \u00edndices start y end del arreglo. Esto le permite a cada capa procesar un \"batch\" de entradas a la vez. Por ejemplo, ustedes podr\u00edan tener un arreglo con punteros a vol\u00famenes de entrada y hacer que start = 5 y end = 9 para procesar las entradas 5, 6, 7, 8 y 9 al mismo tiempo y escribir los resultados en las posiciones correspondientes del arreglo de salida. Dos funciones: make_ y _load . La primera genera una capa con un set de par\u00e1metros espec\u00edficos; la segunda carga los pesos para esta capa desde el \"file system\". La \u00faltima estructura importante es network_t , que contiene toda la informaci\u00f3n que describe una CNN. Esto incluye todas las capas y una instancia de cada uno de los diferentes vol\u00famenes intermedios. Noten que estos vol\u00famenes no son usados para almacenar datos (esto es hecho por los batches que vamos a describir m\u00e1s adelante). Estan all\u00ed para que las dimensiones de cada diferente volumen est\u00e9n disponibles de manera f\u00e1cil en un solo lugar. Todos los datos intermedios son representados por batches . Ustedes pueden pensar de ellos como un set de datos intermedios asociados a un set de im\u00e1genes de entrada. Mientras que su tipo se mira complicado ( batch_t es equivalente a volume_t*** ), estos son solamente arreglos 2D de punteros hacia vol\u00famenes. La primera dimensi\u00f3n les dice a qu\u00e9 capa pertenece el volumen (V0, V1, etc., en la Figura 2 de arriba) y la segunda dimensi\u00f3n, les dice qu\u00e9 entrada est\u00e1n viendo. En el c\u00f3digo base que les hemos dado, nosotros solo utilizamos batches de tama\u00f1o 1 (es decir que solo procesamos una imagen a la vez), pero ustedes van a tener que modificar su programa para considerar batches m\u00e1s largos, de tal manera que se pueda paralelizar la tarea. Los batches pueden ser reservados utilizando la funci\u00f3n make_batch y pueden ser liberados utilizando la funci\u00f3n free_batch . Finalmente, la funci\u00f3n net_forward toma un batch (as\u00ed como los \u00edndices start / end ) y aplica la CNN a cada entrada desde start a end , llamando a las funciones forward para cada capa. Esta funci\u00f3n es utilizada en net_classify para tomar un set de im\u00e1genes de entrada, ponerlas en el volumen V0 como un batch y, entonces, correr la red neural en ese batch de im\u00e1genes. Nostros guardamos las probabilidades (es decir los valores en la \u00faltima capa de la red) en una matriz 2D de n\u00fameros de precisi\u00f3n doble, de tal manera que podamos ver c\u00f3mo la red clasifica una imagen. Tengan cuidado con estas funciones: son llamadas por el c\u00f3digo de benchmarking, as\u00ed que la firma y su salida no deber\u00edan de ser modificadas por sus optimizaciones.","title":"Visi\u00f3n general del C\u00f3digo"},{"location":"projs/proj03/#conclusion","text":"Nosotros reconocemos que es mucha informaci\u00f3n para digerir y que la informaci\u00f3n de arriba no es suficiente para entender totalmente cada detalle del c\u00f3digo. Afortunadamente, ustedes no necesitan hacerlo para hacer que corra de manera m\u00e1s r\u00e1pida: mirando la estructura del c\u00f3digo, ustedes deber\u00edan de ver las potenciales fuentes de paralelismo y otras formas de optimizar su c\u00f3digo. M\u00e1s abajo, les daremos los primeros pasos (algunos) para comenzar y, tambi\u00e9n, les vamos a dar un n\u00famero de propuestas que pueden intentar. A partir de all\u00ed, ustedes deber\u00edan de experimentar diferentes t\u00e9cnicas y ver si funcionan bien.","title":"Conclusi\u00f3n"},{"location":"projs/proj03/#paso-2-perfilamiento-y-ley-de-amdahl","text":"Siempre que ustedes empiecen a optimizar alg\u00fan c\u00f3digo dado, primero, tienen que determinar en d\u00f3nde es que se gasta la mayor parte del tiempo. Por ejemplo, acelerar una parte que \u00fanicamente toma 5% del tiempo total les va a dar como m\u00e1ximo una aceleraci\u00f3n del 5% y es probable que no valga su tiempo y esfuerzo. En clase, ustedes oyeron acerca de la ley de Amdahl, que es una manera genial para estimar el impacto del performance esperado de una optimizaci\u00f3n. Como vimos en clase, para aplicar la ley de Amdahl, primero tenemos que encontrar que fracci\u00f3n del tiempo se gastan en diferentes partes del programa.","title":"Paso 2: Perfilamiento y Ley de Amdahl"},{"location":"projs/proj03/#utilizando-gprof","text":"Antes de hacer cualquier cosa primero tienen que descargar el dataset que vamos a estar utilizando: cd data ./download cd .. Gprof es una herramienta que vamos a estar utilizando para perfilar el c\u00f3digo base para ver que funciones se pueden beneficiar de alguna optimizaci\u00f3n. Para correr Gprof, ustedes tienen que compilar el c\u00f3digo base utilizando la bandera \" -pg \": make clean make baseline CFLAGS = \"-Wall -Isrc/include -Wno-unused-result -march=haswell -std=c99 -fopenmp -pg -O0\" Despu\u00e9s, tenemos que correr el c\u00f3digo base. Dado que Gprof est\u00e1 recolectando estad\u00edsticas acerca del programa, va a tomar un poco m\u00e1s de tiempo que lo usual (a nosotros nos tom\u00f3 alrededor de dos minutos para que terminara). ./baseline benchmark Finalmente, necesitamos ver los resultados de Gprof. gprof baseline | less Este comando que acabamos de ejecutar deber\u00eda de mostrar una cantidad de texto. Para este proyecto, estamos interesados en la tabla de arriba que tiene los siguientes headers: % cumulative self self total time seconds seconds calls s/call s/call name Las columnas de m\u00e1s inter\u00e9s son: % time : La cantidad de tiempo que gastamos en una funci\u00f3n. calls : El n\u00famero de veces que llamamos a una funci\u00f3n. name : El nombre de la funci\u00f3n.","title":"Utilizando Gprof"},{"location":"projs/proj03/#interpretando-los-resultados","text":"Primero, lista el top 10 de funciones utilizando el porcentaje de tiempo que nuestro programa gasta en cada una de ellas. La ley de Amdahl nos dice que funciones se pueden beneficiar m\u00e1s de las optimizaciones, as\u00ed que recomendamos que ustedes pongan su atenci\u00f3n a estas funciones. Noten que algunas funciones que son relativamente sencillas pueden estar en este top 10 porque estas son llamadas muchas veces (en el orden de los millones para algunas, comparado con miles para otras). Mientras que, optimizar estas, pueden acelerar su programa, estas funciones pueden ser tan cortas que podr\u00eda ser muy dif\u00edcil de optimizar. Tengan en cuenta esto si quieren optimizar estas.","title":"Interpretando los Resultados"},{"location":"projs/proj03/#perfilamiento-intermedio","text":"Si ustedes alguna vez quieren perfilar su c\u00f3digo optimizado para seguir viendo d\u00f3nde enfocarse despu\u00e9s, pueden correr los siguientes comandos: make clean make optimized CFLAGS = \"-Wall -Isrc/include -Wno-unused-result -march=haswell -std=c99 -fopenmp -pg -O0\" ./optimized benchmark gprof optimized | less Estos tiempos no van a ser completamente confiables dado que Gprof hace lenta la ejecuci\u00f3n, pero les van a dar una idea general de qu\u00e9 fracci\u00f3n del tiempo usa cada funci\u00f3n.","title":"Perfilamiento Intermedio"},{"location":"projs/proj03/#paso-3-loop-unrolling-y-otras-optimizaciones","text":"En el paso 2, encontramos las funciones que val\u00edan la pena optimizar. Ustedes deber\u00edan de optimizar estas aplicando t\u00e9cnicas convencionales de optimizaci\u00f3n (sin SIMD o m\u00faltiples threads). Nosotros no les vamos a decir los pasos exactos a seguir, pero aqu\u00ed hay algunas propuestas que les van a ayudar a empezar: A veces pueden reemplazar una funci\u00f3n por m\u00faltiples funciones especializadas que realizan la misma cosa pero est\u00e1n optimizadas para valores de entrada espec\u00edficos. Ustedes, despu\u00e9s, deber\u00edan de llamar a estas funciones especializadas desde la funci\u00f3n original, cuando ustedes piensen que aplique. \u00bfHay algunos lugares en el programa donde una variable siempre tiene el mismo valor, pero es cargado de la memoria todo el tiempo? \u00bfHay algunos lugares donde ustedes podr\u00edan hacer manualmente el loop unrolling?. \u00bfPueden clasificar m\u00faltiples ejemplos a la vez, en vez de clasificar uno despu\u00e9s de otro? \u00bfHay alg\u00fan orden mejor para los diferentes loops? Noten que todas las propuestas de arriba est\u00e1n relacionadas en pr\u00e1cticas generales de optimizaci\u00f3n. Ustedes no necesariamente necesitan hacer todas estas para poder alcanzar un buen \"performance\". Una vez hayan mejorado el performance utilizando estas optimizaciones, ustedes pueden empezar a aplicar vectorizaci\u00f3n y paralelismo para hacer el programa a\u00fan m\u00e1s r\u00e1pido. Noten que ustedes tienen libertad de aplicar cualquiera de estas optimizaciones y que hay m\u00e1s de una soluci\u00f3n correcta. Traten de experimentar con diferentes aproximaciones y vean cu\u00e1l de todas les da el mejor performance.","title":"Paso 3: Loop Unrolling y otras optimizaciones"},{"location":"projs/proj03/#paso-4-instrucciones-simd","text":"En el lab 10, ustedes aprendieron como aplicar instrucciones SIMD para mejorar el performance de un programa. El procesador de las instancias de Amazon soporta la extensi\u00f3n AVX, que les deja hacer operaciones SIMD en valores de 256 bits (no solo 128 bits, como vimos en el laboratorio). Ustedes deber\u00edan de utilizar estas extensiones para calcular cuatro operaciones en paralelo (ya que todos los valores de punto flotante son en precisi\u00f3n doble, que son 64 bits). Como un recordatorio, ustedes pueden utilizar la Gu\u00eda de Intel de Intrinsics como referencia para ver las instrucciones relevantes. Ustedes tienen que utilizar el tipo de dato __m256d para almacenar 4 valores double en un registro YMM y, despu\u00e9s, utilizar instrucciones _mm256_* intrinsics para operar.","title":"Paso 4: Instrucciones SIMD"},{"location":"projs/proj03/#paso-5-openmp","text":"Finalmente, ustedes deber\u00edan de utilizar OpenMP para paralelizar el c\u00f3mputo. Noten que la forma m\u00e1s f\u00e1cil de paralelizar la clasificaci\u00f3n de un gran n\u00famero de im\u00e1genes es clasificar batches de ellas en paralelo (dado que estos batches son independientes). Noten que ustedes van a necesitar asegurarse que ninguno de los diferentes threads sobreescriban los datos de otro. Solo utilizando #pragma omp parallel for puede causar errores, o tal vez no si lo hacen de manera correcta. Noten que las instancias de Amazon que van a utilizar tienen ocho cores con un thread por cada core. Esto quiere decir que ustedes deber\u00edan de esperar una aceleraci\u00f3n aprox de ~8x.","title":"Paso 5: OpenMP"},{"location":"projs/proj03/#pruebas-de-funcionamiento-correcto","text":"Primero, tienen que descargar el dataset, si es que todav\u00eda no lo han hecho: cd data ./download cd .. Luego, tienen que compilar el c\u00f3digo de la siguiente manera: make clean && make","title":"Pruebas de Funcionamiento Correcto"},{"location":"projs/proj03/#benchmark-regular","text":"Ustedes pueden correr ./optimized benchmark Para probar qu\u00e9 tan r\u00e1pido corre su c\u00f3digo en un subset de 1200 im\u00e1genes. El c\u00f3digo base toma alrededor de trece segundos en terminar en las instancias de Amazon que vamos a utilizar para calificar. Si ustedes corren este programa sin arguments adicionales, van a poder observar la siguiente salida: RUNNING BENCHMARK ON 1200 PICTURES... Making network... Loading batches... Loading input batch 0 ... Running classification... 78 .250000% accuracy _________ microseconds Su salida va a tener un n\u00famero que representa qu\u00e9 tanto tiempo le tom\u00f3 a la red clasificar esas im\u00e1genes. Noten que solo estamos midiendo el tiempo de clasificaci\u00f3n de su red. El tiempo que le toma para cargar las im\u00e1genes, ponerlas en memoria y otras tareas no son incluidas. La l\u00ednea de accuracy es una referencia r\u00e1pida para asegur\u00e1rse de que su implementaci\u00f3n es correcta. Si el accuracy es diferente (no igual a 78.25%), eso significa que hay alg\u00fan problema con su implementaci\u00f3n. Para una vista m\u00e1s detallada de lo que est\u00e1 mal con su c\u00f3digo, pueden correr ./check simple o ./check huge para verificar las capas que pueden tener alg\u00fan error. Si el test toma demasiado tiempo, pueden correr el test con un n\u00famero menor de im\u00e1genes: ./optimized benchmark n Donde n es un entero que representa la cantidad de im\u00e1genes que quieren correr en el benchmark. Noten que, en este caso, el accuracy puede no ser el mismo, o igual a 78.25%, dado que estamos probando en un subset diferente de im\u00e1genes. Para asegurarse de que su implementaci\u00f3n est\u00e9 correcta, pueden correr los siguientes comandos: ./baseline benchmark n Ahora, pueden comparar los accuracies que sacaron estos dos comandos y, si estos no son los mismos, esto significa que definitivamente hay alg\u00fan bug en su implementaci\u00f3n. Sin embargo, incluso si son las mismas, ustedes siempre deber\u00edan utilizar estos dos siguientes m\u00e9todos para verificar completamente que su implementaci\u00f3n est\u00e1 correcta.","title":"Benchmark regular"},{"location":"projs/proj03/#1-check-simple","text":"Este script corre su red con veinte im\u00e1genes y saca los valores exactos de cada capa de la red; compara estos valores con otros valores de referencia que nosotros generamos con el c\u00f3digo no optimizado y verifica si estos valores son los mismos o no (hasta cierto grado de error, debido a errores de punto flotante). Tambi\u00e9n, corre su c\u00f3digo en subsets de im\u00e1genes grandes para tomar en cuenta los errores de paralelismo. Para estas pruebas, nosotros solo comparamos la salida de la \u00faltima capa de su red con la versi\u00f3n no optimizada. Esta es una prueba m\u00e1s detallada que solamente correr ./optimized benchmark , ya que se asegura que su red est\u00e9 computando virtualmente las mismas operaciones como el c\u00f3digo base. Les recomendamos utilizar esta prueba despu\u00e9s de hacer cualquier tipo de modificaci\u00f3n mayor a su c\u00f3digo para asegurarse de que no afecte la validez del c\u00f3digo.","title":"1. ./check simple"},{"location":"projs/proj03/#2-check-huge","text":"Este script es lo mismo que el anterior, solamente que corre el c\u00f3digo en subsets de im\u00e1genes bastante largos. Ustedes no deber\u00edan de utilizar este script muy seguido (ya que toma una cantidad de tiempo considerable en ejecutarse), pero les recomendamos que, aunque sea, lo ejecuten una vez antes de subir su proyecto al autograder.","title":"2. ./check huge"},{"location":"projs/proj03/#debugging","text":"Nosotros recomendamos que utilicen CGDB y Valgrind para encontrar bugs en su proyecto. Para usar CGDB, necesitamos utilizar la bandera \" -g \" en la variable CFLAGS para que los s\u00edmbolos de depuraci\u00f3n se generen. Podemos lograr esto haciendo lo siguiente: make CFLAGS=\"-Wall -Isrc/include -Wno-unused-result -march=haswell -std=c99 -fopenmp -g -O0\" cgdb ./optimized Luego, en CGDB, ustedes pueden poner breakpoints y ejecutar run optimized Para comenzar a depurar. Si ustedes encuentran alg\u00fan segmentation fault , Valgrind es una buena herramienta para encontrar d\u00f3nde est\u00e1 occurriendo. Un comando ejemplo que podr\u00edan ejecutar es: valgrind --leak-check = full --show-leak-kinds = all ./optimized benchmark Noten que su programa puede tomar m\u00e1s tiempo en ejecutarse al utilizar Valgrind. Si no tienen Valgrind instalado pueden utilizar el siguiente comando para instalarlo: sudo apt install valgrind","title":"Debugging"},{"location":"projs/proj03/#rubrica-de-calificacion","text":"En este proyecto su calificaci\u00f3n va a ser determinada basada en qu\u00e9 tan r\u00e1pido su c\u00f3digo corre relativamente a la soluci\u00f3n b\u00e1sica que les damos (speedup). Noten que si su implementaci\u00f3n no pasa ./check simple , van a recibir un 0 en el autograder. Vamos a utilizar la siguiente funci\u00f3n para determinar su nota: grade ( speedup ): if 0 <= speedup < 1 : 0 if 1 <= speedup <= 16 : 1 - ( speedup - 16 ) ^ 2 / 225 if speedup > 16 : 1 Para referencia, aqu\u00ed est\u00e1n las notas para algunos de los valores de speedup: Speedup Nota 16X 100% 14X ~98% 12X ~93% 10X ~84% 8X ~72% 6X ~56% 4X ~36% 2X ~13% Su speedup va a ser basado en qu\u00e9 tan r\u00e1pido es su c\u00f3digo en nuestras pruebas utilizando AWS. ./check speedup es un buen estimado de que tan r\u00e1pido es su c\u00f3digo a comparaci\u00f3n del que les damos.","title":"R\u00fabrica de Calificaci\u00f3n"},{"location":"projs/proj03/#calificacion","text":"Por favor empiecen lo antes posible, porque vamos a utilizar instancias de Amazon para el autograder y este solo puede procesar 4 submits al mismo tiempo (esto por lo general toma bastante tiempo en completarse). Para este proyecto vamos a limitar la cantidad de veces que ustedes pueden hacer submit, a 20 por persona debido a cuestiones de cr\u00e9ditos. S\u00ed, si ustedes van en pareja, en teor\u00eda tendr\u00edan 40 submits. De esta manera, tal vez motivamos la colaboraci\u00f3n. Les recomendamos que prueben en una computadora con un procesador intel con extensi\u00f3n AVX habilitada antes de gastar sus cr\u00e9ditos. Pueden ir al laboratorio para esto si no tienen una. Las medidas no van a ser exactas, pero les dar\u00e1n una idea. Para ver su speedup aproximado pueden ejecutar los siguientes comandos: make clean && make ./check speedup Para ver el speedup real pueden subir su implementaci\u00f3n al autograder, haciendo lo siguiente: ./submit <TOKEN> lo que va a resultar en algo parecido a esto: ___ __ __ / _ | __ __/ /____ ___ _______ ____/ /__ ____ / __ / // / __/ _ \\/ _ \\/ __/ _ \\/ _ / -_ ) __/ /_/ | _ \\_ ,_/ \\_ _/ \\_ __/ \\_ , /_/ \\_ ,_/ \\_ ,_/ \\_ _/_/ /___/ Machine Structures Great Ideas in Computer Architecture Repo: proj3_optimizations Best Score: 100 /100 Last Output: Exercise Grade Message -------------------------- ------- -------------------- 1 . Performance Programming 100 passed: speedup: 16X En su p\u00e1gina de Dashboard hay un nuevo link llamado Project 3 Race , si le dan click van a ver algo parecido a lo siguiente: Este es un tablero de posiciones, donde pueden ver los speedups alcanzados por sus otros compa\u00f1eros de todas las secciones, si ustedes quedan dentro de los primeros 3 lugares y con un speedup mayor a 12X pueden recibir cierta cantidad de puntos extra , m\u00e1s adelante les diremos cu\u00e1nto exactamente... Como es un tablero donde aparecen los nombres de forma individual y no los grupos, si el primer y segundo lugar (por ejemplo) pertenecen al mismo grupo, el grupo recibir\u00e1 los puntos del primer lugar, y entonces el tercer lugar ser\u00eda el segundo lugar realmente. Esto es al estilo \"ANSI C Race\", para motivarlos a hacer su mejor esfuerzo y el mejor trabajo posible. Los auxiliares de este curso har\u00e1n el proyecto tambi\u00e9n, si alguno de ustedes supera el speedup de un auxiliar, ustedes pueden obtener otra bonificaci\u00f3n.","title":"Calificaci\u00f3n"},{"location":"projs/proj04/","text":"Proyecto 4: MapReduce \u00b6 Objetivos \u00b6 Familiarizarse con el modelo de programaci\u00f3n MapReduce utilizando Apache Spark. Aplicar t\u00e9cnicas de paralelismo a nivel de datos para resolver un problema grande. Paralelizar un clasificador simple en Spark para predecir ratings de reviews. Preparaci\u00f3n \u00b6 Antes de comenzar, aseg\u00farense de que hayan le\u00eddo y comprendido todas las instrucciones del proyecto de principio a fin . Si tienen alguna pregunta, por favor dir\u00edjanse a Slack y pregunten en los canales correspondientes. Tambi\u00e9n les recomendamos seguir el Tutorial de Python para que tengan las bases del lenguaje y asegurarse de que tengan instalado Anaconda Python. Para comenzar con el proyecto, primero tienen que tener todos los archivos base, estos se encuentran aqu\u00ed . Tienen permitido trabajar en parejas o de forma individual, por lo que al aceptar la asignaci\u00f3n les preguntar\u00e1 si desean crear un grupo nuevo o unirse a uno ya existente. Si crean un grupo nuevo, ingresen un nombre que los represente (seguramente un nombre raro como siempre ...) y que no haya sido tomado por otro. Si desean unirse a un grupo ya creado, tienen que buscar el nombre del grupo y pulsar el bot\u00f3n que dice join : Tienen que tener mucho cuidado al unirse a un grupo ya existente, ya que esto no se puede cambiar despu\u00e9s, adem\u00e1s, lo consideraremos como PLAGIO si lo realizan de manera incorrecta, ya que, al hacer esto, pueden tener acceso al repositorio del otro miembro del grupo y leer su c\u00f3digo. Ya sea que se unan o creen un nuevo grupo, al finalizar el proceso, se crear\u00e1 autom\u00e1ticamente un repositorio con una extensi\u00f3n que termina con su nombre de grupo. Habiendo hecho todo esto, pueden ejecutar los siguientes comandos abriendo una terminal ( CTRL + T ): git clone <link del repositorio> Tambi\u00e9n, tienen que instalar el entorno de Python para este proyecto. Para hacer esto, ejecuten lo siguiente: conda env create -f environment.yml Respondan al mensaje de instalar paquetes con \"y\" (sin comillas). Despu\u00e9s de la instalaci\u00f3n, corran el siguiente comando para activar el entorno virtual: conda activate proj4 Cuando hayan terminado con el proyecto pueden desactivar el entorno con: conda deactivate Introducci\u00f3n \u00b6 En este proyecto, vamos a estar clasificando y prediciendo las estrellas ( ratings ) de dos datasets bastante grandes. Los datasets contienen mucha informaci\u00f3n de reviews ( rese\u00f1as ), pero ustedes van a estar enfocados en clasificar el texto del review en cierta cantidad de estrellas. El dataset original contiene reviews con ratings de 0-5, pero para este proyecto ustedes solo van a clasificar los reviews en 3 categor\u00edas diferentes o cantidad de estrellas diferentes: 1 , 3 , 5 . Para simplificar el proceso de clasificaci\u00f3n y para que mejore la precisi\u00f3n, nosotros hemos tomado el dataset original y agrupado los reviews en estas 3 categor\u00edas. Para hacer esto, nosotros tomamos el rating original que se le dio a un review, y lo agrupamos conforme a las siguientes reglas: [4, 5) estrellas -> 5 estrellas [2, 4) estrellas -> 3 estrellas [0, 2) estrellas -> 1 estrella Esta, definitivamente, no es la mejor manera de agrupar los datos, pero elegimos esto por simplicidad. Tambi\u00e9n, hay muchos modelos y t\u00e9cnicas de Machine Learning para clasificar texto, sin embargo, el m\u00e1s simple (y bastante efectivo) es el clasificador Naive Bayes con un modelo de Bag of Words (BoW) para el texto. Entrenamiento \u00b6 Primero, vamos a calcular la probabilidad ( likelihoods ) de que una palabra ocurra en reviews con cada posible n\u00famero de estrellas: $$P(w | s) = \\dfrac{1 + num(w, s) }{1 + total(s)}$$ Siendo $num(w, s)$ la cantidad de veces que una palabra $w$ aparece en reviews que tienen $s$ estrellas y $total(s)$ el n\u00famero de palabras total en reviews que tienen $s$ estrellas. Van a hacer esto para cada palabra que aparezca en el grupo de reviews con $s$ estrellas, para cada posible n\u00famero de estrellas. Despu\u00e9s, van a calcular la probabilidad a priori ( priors ) de un review con $s$ n\u00famero de estrellas, para todos los posibles n\u00fameros de estrellas: $$P(s) = \\dfrac{N}{size}$$ siendo $N$ el n\u00famero de reviews con $s$ estrellas y $size$ el n\u00famero total de reviews. Clasificaci\u00f3n \u00b6 Dado un review separado en palabras $(w_1, w_2, w_3, w_4, ...)$, para todos los posibles n\u00fameros de estrellas, van a calcular la probabilidad conjunta: $$P(s|w_1, w_2, w_3, w_4, ...) = P(s)P(w_1|s)P(w_2|s)P(w_3|s)P(w_4|s)...$$ Su predicci\u00f3n final ser\u00e1 el n\u00famero de estrellas $s$ para el review, de tal manera que $s$ tenga la mayor probabilidad conjunta. Bag of Words (BoW) \u00b6 Cuando se piensa en la relaci\u00f3n de las palabras en una oraci\u00f3n con su sentimiento o significado, la secuencia de las palabras parece ser un factor importante. Sin embargo, el modelo de texto Bag of Words ignora el orden de las palabras y en su lugar considera cada palabra de forma independiente. Una palabra en un documento (o en un review en nuestro caso) est\u00e1 representada solo por el n\u00famero de veces que aparece en el documento y nada m\u00e1s (no se considera el orden o las partes de la oraci\u00f3n). Por ejemplo, si tuvieramos un review \" This restaurant is amazing! The best. The food is never bad. \", entonces utilizando BoW se representar\u00eda de la siguiente manera: Palabra Conteo this 1 restaurant 1 is 2 amazing 1 the 2 best 1 food 1 never 1 bad 1 Naive Bayes \u00b6 Ahora vamos a explicar el clasificador que van a utilizar para esta tarea. Dado alg\u00fan conjunto de datos $X$, Naive Bayes va a tratar de predecir la probabilidad $P(Y|X)$ de que esos datos tienen una etiqueta, o categor\u00eda, $Y$, es decir la probabilidad a posteriori . (En nuestro caso, dado el texto de un review, ustedes van a tratar de predecir el n\u00famero de estrellas que el review podr\u00eda tener). Para poder calcular la probabilidad a posteriori, la regla de Bayes se tiene que aplicar: $$P(Y|X) = \\dfrac{P(X|Y)P(Y)}{P(X)}$$ Sin embargo, en la pr\u00e1ctica, a pesar de que la probabilidad a posteriori es la deseada, esta es realmente proporcional a la probabilidad conjunta $P(Y|X)$, que es m\u00e1s f\u00e1cil de calcular, de esta manera Naive Bayes , finalmente, trata de estimar: $$P(Y|X) = P(X|Y)P(Y)$$ Con el objetivo de estimar $P(Y|X)$, el clasificador trata de estimar $P(X|Y)$ y $P(Y)$ dado un set de datos de entrenamiento y sus etiquetas. En nuestro caso, nuestro clasificador Naive Bayes, va a recibir un set de datos de entrenamiento, que son las palabras en un review (datos), y el n\u00famero de estrellas para ese review (etiqueta) y, despu\u00e9s, estimar $P(X| Y)$ y $P(Y)$. Por ejemplo $P(\\text{awesome} | 5)$ y $P(5)$. Para entrenar el clasificador, van a estimar $P(X|Y)$ de la siguiente manera: $$P(w | s) = \\dfrac{1 + num(w, s) }{1 + total(s)}$$ y para estimar $P(Y)$: $$P(s) = \\dfrac{N}{size}$$ Como se explica m\u00e1s arriba en las instrucciones. Ejemplo \u00b6 Si tuvieramos solo 4 reviews para entrenar: Review Numero de estrellas I hate the food. 1 The food is good. 3 Service is good. 3 I love the good food. 5 Dado que hay dos reviews con 3 estrellas y cuatro reviews en total, la probabilidad a priori de que un review sea de 3 estrellas es: $$P(3) = \\dfrac{2}{4}$$ Los mismos c\u00e1lculos deber\u00edan de hacerse para 1 estrella y 5 estrellas, de tal manera que tengamos una tabla que traduzca de n\u00famero de estrellas a su probabilidad a priori: N\u00famero de estrellas Probabilidad a Priori 1 $\\dfrac{1}{4}$ 3 $\\dfrac{2}{4}$ 5 $\\dfrac{1}{4}$ Para estimar las probabilidades $P(X|Y)$ (likelihoods), vamos a tomar como ejemplo la estimaci\u00f3n de la probabilidad de \"good\": $$P(\\text{good}|3) = \\dfrac{1 + num(\\text{good}, 3) }{1 + total(3)} = \\dfrac{1 + 2}{1 + 7} = \\dfrac{3}{8}$$ Ya que \"good\" aparece en 2 reviews con 3 estrellas (The food is good, Service is good) y hay 7 palabras en total en reviews con 3 estrellas (The, food, is, good, Service, is, good). Este c\u00e1lculo se tiene que repetir para cada palabra que aparece, al menos, una vez en un review con 3 estrellas y, de igual forma, para las palabras con reviews de 1 y 5 estrellas. Al final, van a tener una tabla con las probabilidades (likelihoods) para cada posible n\u00famero de estrellas, donde cada fila traduce una palabra a su probabilidad dado el n\u00famero de estrellas: $W$ $P(W|1)$ $P(W|3)$ $P(W|5)$ I $\\dfrac{2}{5}$ $\\dfrac{1}{8}$ $\\dfrac{2}{6}$ hate $\\dfrac{2}{5}$ $\\dfrac{1}{8}$ $\\dfrac{1}{6}$ the $\\dfrac{2}{5}$ $\\dfrac{2}{8}$ $\\dfrac{2}{6}$ food $\\dfrac{2}{5}$ $\\dfrac{2}{8}$ $\\dfrac{2}{6}$ is $\\dfrac{1}{5}$ $\\dfrac{3}{8}$ $\\dfrac{1}{6}$ good $\\dfrac{1}{5}$ $\\dfrac{3}{8}$ $\\dfrac{2}{6}$ service $\\dfrac{1}{5}$ $\\dfrac{2}{8}$ $\\dfrac{1}{6}$ love $\\dfrac{1}{5}$ $\\dfrac{1}{8}$ $\\dfrac{2}{6}$ Ya entrenado el modelo, se procede al proceso de clasificaci\u00f3n. Si se utiliza el clasificador Naive Bayes con un dato sin etiqueta, $X$, entonces para todas las posibles etiquetas o categor\u00edas, $Y = y_1, y_2, y_3...$, las probabilidades conjuntas $P(Y=y_1, X)$, $P(Y=y_2, X)$, $P(Y=y_3, X)$... son calculadas y, despu\u00e9s, el dato es clasificado con la etiqueta que tiene la mayor probabilidad conjunta. En este caso, la probabilidad conjunta es calculada como: $$P(Y=y, X) = P(Y=y)P(x_1 | Y=y)P(x_2 | Y=y) P(x_3 | Y=y)...$$ Donde Naive Bayes hace la suposici\u00f3n de que las probabilidades de cada $x_i$ son independientes dada la etiqueta $y$. En nuestro caso, las etiquetas son 1, 3, y 5 estrellas y cada dato es un review $x_i$. M\u00e1s concretamente, supongan que tenemos los mismos cuatro reviews anteriores para entrenar y ustedes quieren, ahora, predecir el n\u00famero de estrellas correspondientes al review \"Good food!\". Para cada posible n\u00famero de estrellas, ustedes calcular\u00edan la probabilidad para ese n\u00famero de estrellas, dado este review, como: $$P(s| \\text{good}, {food}) = P(s)P({good} | s)P(\\text{food} | s)$$ Para cada diferente n\u00famero de estrellas: $P(1| \\text{good}, \\text{food}) = (\\dfrac{1}{4})(\\dfrac{1}{5})(\\dfrac{2}{5}) = \\dfrac{2}{100}$ $P(3| \\text{good}, \\text{food}) = (\\dfrac{2}{4})(\\dfrac{3}{8})(\\dfrac{2}{8}) = \\dfrac{12}{256}$ $P(5| \\text{good}, \\text{food}) = (\\dfrac{1}{4})(\\dfrac{2}{6})(\\dfrac{2}{6}) = \\dfrac{4}{144}$ Dada la probabilidad conjunta del review \"Good food\", siendo 3 estrellas es la m\u00e1s alta, Naive Bayes va a clasificar este review como 3 estrellas. Por \u00faltimo, multiplicar muchos n\u00fameros de punto flotante puede resultar en problemas de precisi\u00f3n (\u00bfse recuerdan por qu\u00e9?). Para resolver este problema, su implementaci\u00f3n para la clasificaci\u00f3n va a calcular el logaritmo natural de las probabilidades (likelihoods) y las probabilidades a priori y, luego, sumarlas (en vez de multiplicar los likelihoods por las probabilidades a priori): $P(1| \\text{good}, \\text{food}) = log(\\dfrac{1}{4}) + log(\\dfrac{1}{5}) + log(\\dfrac{2}{5})$ $P(3| \\text{good}, \\text{food}) = log(\\dfrac{2}{4}) + log(\\dfrac{3}{8}) + log(\\dfrac{2}{8})$ $P(5| \\text{good}, \\text{food}) = log(\\dfrac{1}{4}) + log(\\dfrac{2}{6}) + log(\\dfrac{2}{6})$ Su Tarea \u00b6 Su tarea va a ser terminar el clasificador Naive Bayes. Todo el c\u00f3digo para el clasificador Naive Bayes va estar en classifier.py . Las partes que ustedes tienen que completar est\u00e1n claramente indicadas. Tomen un poco tiempo para entender los comentarios en el archivo. Ustedes son libres de implementar las funciones correspondientes de cualquier forma (utilizando MapReduce y Spark, obviamente). Sin embargo, solo vamos a aceptar c\u00f3digo que est\u00e9 en classifier.py . Si su c\u00f3digo tiene otras dependencias y/o no funciona junto con run.py , no va a funcionar y tendr\u00e1n una nota de 0 puntos. El archivo que corre el clasificador es run.py . Si\u00e9ntanse libres de modificar este archivo para depurar, pero recuerden que ninguno de sus cambios a este archivo se van a utilizar para la calificaci\u00f3n final. En general, las funciones que se tienen que implementar son: def calculate_priors ( self , rdd , size ): def calculate_words_per_num_stars ( self , rdd ): def calculate_likelihoods ( self , rdd ): def predict ( self , rdd ): Pruebas \u00b6 Dataset \u00b6 Primero tienen que descargar el dataset con el que vamos a estar trabajando haciendo lo siguiente: cd data python preprocess.py cd .. Esto va a descargar el dataset, procesarlo y generar los siguientes archivos: reviews-train-sample.txt reviews-test-sample.txt reviews-labels-sample.txt reviews-train-small.txt reviews-test-small.txt reviews-labels-small.txt reviews-train-medium.txt reviews-test-medium.txt reviews-labels-medium.txt reviews-train-large.txt reviews-test-large.txt reviews-labels-large.txt Estos archivos son cargados por run.py en un RDD de Spark, donde cada l\u00ednea de los archivos de entrenamiento (train) representa un diccionario de Python con la siguiente estructura: { 'id' : review_id , 'text' : review_text , 'stars' : review_stars } Cada l\u00ednea de los archivos de prueba (test) representa un diccionario de Python con la siguiente estructura: { 'id' : review_id , 'text' : review_text } Noten que el n\u00famero de estrellas no est\u00e1 presente en estos archivos, ya que es tarea del clasificador predecir ese n\u00famero. De todas maneras las etiquetas correctas est\u00e1n en los archivos de etiquetas (labels) que se utilizan para verificar el porcentaje de acierto, estos tienen la siguiente estructura: { 'id' : review_id , 'stars' : review_stars } Recuerden que review_stars solo puede considerar 1 , 3 o 5 , y que el texto es \"texto crudo\" ( raw text ), que no est\u00e1 separado por palabras. Tokenizar texto en palabras \u00b6 Ya que hay diferentes maneras en Python de tokenizar un texto en palabras, ustedes tienen que utilizar lo siguiente para realizar esta tarea: # texto a tokenizar text = 'Hello World!!' # remueve la puntuacion text2 = text . translate ( str . maketrans ( '' , '' , string . punctuation )) . strip () # genera un arreglo de palabras en minuscula words = [ w . lower () for w in text2 . split ( ' ' )] print ( words ) Run Clear De esta forma su resultado ser\u00e1 igual al esperado por el autograder si por alguna raz\u00f3n no llegan al tiempo esperado. Depuraci\u00f3n \u00b6 Para este proyecto no hay autograder local. Pero vamos a dejar el output del staff para un dataset de ejemplo. Este dataset de ejemplo contiene 10 reviews para entrenamiento y 5 reviews para clasificaci\u00f3n. Si\u00e9ntanse libres de utilizarlo para depurar su salida de cada parte de su implementaci\u00f3n. Cuando ustedes corran el dataset de ejemplo, run.py va a generar autom\u00e1ticamente un archivo llamado debug_diffs.txt en el directorio out/ , que va a contener las diferencias de su implementaci\u00f3n con respecto a las del staff (si es que hay alguna) o indicar que todo est\u00e1 correcto. Noten que como es un dataset demasiado peque\u00f1o, no se tienen que preocupar del porcentaje de acierto si es bajo o 0. Pueden correr el dataset de ejemplo utilizando: ./check sample Si todo esta correcto les tiene que salir algo similar a esto: [PRIORS] OK [\u2713] [WORDS PER # STARS] OK [\u2713] [LIKELIHOODS] OK [\u2713] [PREDICTION] OK [\u2713] De lo contrario contendr\u00e1 las diferencias de cada una de las partes, por ejemplo: [PRIORS] prior for 1 stars, P(1), should be 0.100000 instead of -1.000000 prior for 3 stars, P(3), should be 0.100000 instead of -1.000000 prior for 5 stars, P(5), should be 0.800000 instead of -1.000000 [WORDS PER # STARS] words per 1 stars should be 22 instead of -1 words per 3 stars should be 722 instead of -1 words per 5 stars should be 905 instead of -1 ... Benchmark \u00b6 Una vez hayan implementado todas las partes faltantes, hay tres datasets para que ustedes prueben y as\u00ed ver el porcentaje de acierto y el tiempo que se toma en ejecutar su programa. Pueden probar su c\u00f3digo de Spark en cada uno de estos datasets utilizando el comando: ./check ( small | medium | large ) El cual generar\u00e1 un archivo .txt con el nombre del dataset utilizado que contendr\u00e1 la informaci\u00f3n mencionada, por ejemplo si utilizan ./check large , esto generar\u00eda un archivo llamado out/large.txt con la siguiente informaci\u00f3n: time: 32.44 seconds accuracy: 75.23 Cada dataset est\u00e1 estructurado de la siguiente forma: Dataset # reviews para entrenamiento # reviews para test % acierto Staff Tiempo Staff small 3750 1250 38.24 ~5 segundos medium 37500 12500 65.36 ~10 segundos large 375000 125000 75.23 ~30 segundos El dataset peque\u00f1o deber\u00eda de correr bastante r\u00e1pido, as\u00ed que deber\u00edan de utilizar este para probar su implementaci\u00f3n y asegurarse de que corresponden con los benchmarks del staff. Si su implementaci\u00f3n es mejor, y logra m\u00e1s porcentaje de acierto que el nuestro, \u00a1genial!, sin embargo, por favor noten que vamos a poner l\u00edmites de tiempo. Es decir, si su porcentaje de acierto es igual o mejor que el del staff, pero es significativamente m\u00e1s lento que nuestra implementaci\u00f3n, no van a obtener una buena nota en el autograder. Ya que es el \u00faltimo proyecto, la calificaci\u00f3n va a ser bastante simple. Vamos a correr su implementaci\u00f3n en un dataset m\u00e1s grande (2 millones de reviews). Si es igual o mejor que el porcentaje de acierto que el staff, y no toma mucho tiempo para correr, ustedes van a obtener la nota completa. Si ustedes lograron el benchmark para los tres datasets que les damos, pueden estar 100% seguros que van a lograrlo en el autograder. De todas maneras, se van a dar cr\u00e9ditos parciales de la siguiente manera: 20% si su implementaci\u00f3n corre sin errores 20% si obtienen un porcentaje de acierto diferente de 0 10% si calculan correctamente calculate_priors 10% si calculan correctamente calculate_words_per_num_stars 20% si calculan correctamente calculate_likelihoods 20% si calculan correctamente predict Para los 4 \u00faltimos puntos, vamos a probar estas funciones aisladas para darles los cr\u00e9ditos parciales. Calificaci\u00f3n \u00b6 Por favor empiecen lo antes posible, porque vamos a utilizar instancias de Amazon para el autograder y este solo puede procesar 4 submits al mismo tiempo (esto por lo general toma bastante tiempo en completarse). Para este proyecto vamos a limitar la cantidad de veces que ustedes pueden hacer submit, a 5 por persona . S\u00ed, si ustedes van en pareja, en teor\u00eda tendr\u00edan 10 submits. De esta manera, tal vez, motivamos la colaboraci\u00f3n. Les recomendamos que prueben en las computadoras de los laboratorios antes de desperdiciar cr\u00e9ditos, si es que en su computadora no pueden lograr los tiempos del staff. Las medidas no van a ser exactas, pero les dar\u00e1n una idea. Pueden subir su implementaci\u00f3n al autograder, haciendo lo siguiente: ./submit <TOKEN> lo que va a resultar en algo parecido a esto: ___ __ __ / _ | __ __/ /____ ___ _______ ____/ /__ ____ / __ / // / __/ _ \\/ _ \\/ __/ _ \\/ _ / -_ ) __/ /_/ | _ \\_ ,_/ \\_ _/ \\_ __/ \\_ , /_/ \\_ ,_/ \\_ ,_/ \\_ _/_/ /___/ Machine Structures Great Ideas in Computer Architecture Repo: proj4_spark Best Score: 100 /100 Last Output: Exercise Grade Message ---------------------------------------- ----- ------- 1 . Compiling implementation 20 passed 2 . Non-zero accuracy 20 passed 3 . Correct calculate_priors 10 passed 4 . Correct calculate_words_per_num_stars 10 passed 5 . Correct calculate_likelihoods 20 passed 6 . Correct predict 20 passed Esperamos que hayan disfrutado el curso, muchos \u00e9xitos en lo que viene.","title":"Proyecto 4: MapReduce"},{"location":"projs/proj04/#proyecto-4-mapreduce","text":"","title":"Proyecto 4: MapReduce"},{"location":"projs/proj04/#objetivos","text":"Familiarizarse con el modelo de programaci\u00f3n MapReduce utilizando Apache Spark. Aplicar t\u00e9cnicas de paralelismo a nivel de datos para resolver un problema grande. Paralelizar un clasificador simple en Spark para predecir ratings de reviews.","title":"Objetivos"},{"location":"projs/proj04/#preparacion","text":"Antes de comenzar, aseg\u00farense de que hayan le\u00eddo y comprendido todas las instrucciones del proyecto de principio a fin . Si tienen alguna pregunta, por favor dir\u00edjanse a Slack y pregunten en los canales correspondientes. Tambi\u00e9n les recomendamos seguir el Tutorial de Python para que tengan las bases del lenguaje y asegurarse de que tengan instalado Anaconda Python. Para comenzar con el proyecto, primero tienen que tener todos los archivos base, estos se encuentran aqu\u00ed . Tienen permitido trabajar en parejas o de forma individual, por lo que al aceptar la asignaci\u00f3n les preguntar\u00e1 si desean crear un grupo nuevo o unirse a uno ya existente. Si crean un grupo nuevo, ingresen un nombre que los represente (seguramente un nombre raro como siempre ...) y que no haya sido tomado por otro. Si desean unirse a un grupo ya creado, tienen que buscar el nombre del grupo y pulsar el bot\u00f3n que dice join : Tienen que tener mucho cuidado al unirse a un grupo ya existente, ya que esto no se puede cambiar despu\u00e9s, adem\u00e1s, lo consideraremos como PLAGIO si lo realizan de manera incorrecta, ya que, al hacer esto, pueden tener acceso al repositorio del otro miembro del grupo y leer su c\u00f3digo. Ya sea que se unan o creen un nuevo grupo, al finalizar el proceso, se crear\u00e1 autom\u00e1ticamente un repositorio con una extensi\u00f3n que termina con su nombre de grupo. Habiendo hecho todo esto, pueden ejecutar los siguientes comandos abriendo una terminal ( CTRL + T ): git clone <link del repositorio> Tambi\u00e9n, tienen que instalar el entorno de Python para este proyecto. Para hacer esto, ejecuten lo siguiente: conda env create -f environment.yml Respondan al mensaje de instalar paquetes con \"y\" (sin comillas). Despu\u00e9s de la instalaci\u00f3n, corran el siguiente comando para activar el entorno virtual: conda activate proj4 Cuando hayan terminado con el proyecto pueden desactivar el entorno con: conda deactivate","title":"Preparaci\u00f3n"},{"location":"projs/proj04/#introduccion","text":"En este proyecto, vamos a estar clasificando y prediciendo las estrellas ( ratings ) de dos datasets bastante grandes. Los datasets contienen mucha informaci\u00f3n de reviews ( rese\u00f1as ), pero ustedes van a estar enfocados en clasificar el texto del review en cierta cantidad de estrellas. El dataset original contiene reviews con ratings de 0-5, pero para este proyecto ustedes solo van a clasificar los reviews en 3 categor\u00edas diferentes o cantidad de estrellas diferentes: 1 , 3 , 5 . Para simplificar el proceso de clasificaci\u00f3n y para que mejore la precisi\u00f3n, nosotros hemos tomado el dataset original y agrupado los reviews en estas 3 categor\u00edas. Para hacer esto, nosotros tomamos el rating original que se le dio a un review, y lo agrupamos conforme a las siguientes reglas: [4, 5) estrellas -> 5 estrellas [2, 4) estrellas -> 3 estrellas [0, 2) estrellas -> 1 estrella Esta, definitivamente, no es la mejor manera de agrupar los datos, pero elegimos esto por simplicidad. Tambi\u00e9n, hay muchos modelos y t\u00e9cnicas de Machine Learning para clasificar texto, sin embargo, el m\u00e1s simple (y bastante efectivo) es el clasificador Naive Bayes con un modelo de Bag of Words (BoW) para el texto.","title":"Introducci\u00f3n"},{"location":"projs/proj04/#entrenamiento","text":"Primero, vamos a calcular la probabilidad ( likelihoods ) de que una palabra ocurra en reviews con cada posible n\u00famero de estrellas: $$P(w | s) = \\dfrac{1 + num(w, s) }{1 + total(s)}$$ Siendo $num(w, s)$ la cantidad de veces que una palabra $w$ aparece en reviews que tienen $s$ estrellas y $total(s)$ el n\u00famero de palabras total en reviews que tienen $s$ estrellas. Van a hacer esto para cada palabra que aparezca en el grupo de reviews con $s$ estrellas, para cada posible n\u00famero de estrellas. Despu\u00e9s, van a calcular la probabilidad a priori ( priors ) de un review con $s$ n\u00famero de estrellas, para todos los posibles n\u00fameros de estrellas: $$P(s) = \\dfrac{N}{size}$$ siendo $N$ el n\u00famero de reviews con $s$ estrellas y $size$ el n\u00famero total de reviews.","title":"Entrenamiento"},{"location":"projs/proj04/#clasificacion","text":"Dado un review separado en palabras $(w_1, w_2, w_3, w_4, ...)$, para todos los posibles n\u00fameros de estrellas, van a calcular la probabilidad conjunta: $$P(s|w_1, w_2, w_3, w_4, ...) = P(s)P(w_1|s)P(w_2|s)P(w_3|s)P(w_4|s)...$$ Su predicci\u00f3n final ser\u00e1 el n\u00famero de estrellas $s$ para el review, de tal manera que $s$ tenga la mayor probabilidad conjunta.","title":"Clasificaci\u00f3n"},{"location":"projs/proj04/#bag-of-words-bow","text":"Cuando se piensa en la relaci\u00f3n de las palabras en una oraci\u00f3n con su sentimiento o significado, la secuencia de las palabras parece ser un factor importante. Sin embargo, el modelo de texto Bag of Words ignora el orden de las palabras y en su lugar considera cada palabra de forma independiente. Una palabra en un documento (o en un review en nuestro caso) est\u00e1 representada solo por el n\u00famero de veces que aparece en el documento y nada m\u00e1s (no se considera el orden o las partes de la oraci\u00f3n). Por ejemplo, si tuvieramos un review \" This restaurant is amazing! The best. The food is never bad. \", entonces utilizando BoW se representar\u00eda de la siguiente manera: Palabra Conteo this 1 restaurant 1 is 2 amazing 1 the 2 best 1 food 1 never 1 bad 1","title":"Bag of Words (BoW)"},{"location":"projs/proj04/#naive-bayes","text":"Ahora vamos a explicar el clasificador que van a utilizar para esta tarea. Dado alg\u00fan conjunto de datos $X$, Naive Bayes va a tratar de predecir la probabilidad $P(Y|X)$ de que esos datos tienen una etiqueta, o categor\u00eda, $Y$, es decir la probabilidad a posteriori . (En nuestro caso, dado el texto de un review, ustedes van a tratar de predecir el n\u00famero de estrellas que el review podr\u00eda tener). Para poder calcular la probabilidad a posteriori, la regla de Bayes se tiene que aplicar: $$P(Y|X) = \\dfrac{P(X|Y)P(Y)}{P(X)}$$ Sin embargo, en la pr\u00e1ctica, a pesar de que la probabilidad a posteriori es la deseada, esta es realmente proporcional a la probabilidad conjunta $P(Y|X)$, que es m\u00e1s f\u00e1cil de calcular, de esta manera Naive Bayes , finalmente, trata de estimar: $$P(Y|X) = P(X|Y)P(Y)$$ Con el objetivo de estimar $P(Y|X)$, el clasificador trata de estimar $P(X|Y)$ y $P(Y)$ dado un set de datos de entrenamiento y sus etiquetas. En nuestro caso, nuestro clasificador Naive Bayes, va a recibir un set de datos de entrenamiento, que son las palabras en un review (datos), y el n\u00famero de estrellas para ese review (etiqueta) y, despu\u00e9s, estimar $P(X| Y)$ y $P(Y)$. Por ejemplo $P(\\text{awesome} | 5)$ y $P(5)$. Para entrenar el clasificador, van a estimar $P(X|Y)$ de la siguiente manera: $$P(w | s) = \\dfrac{1 + num(w, s) }{1 + total(s)}$$ y para estimar $P(Y)$: $$P(s) = \\dfrac{N}{size}$$ Como se explica m\u00e1s arriba en las instrucciones.","title":"Naive Bayes"},{"location":"projs/proj04/#ejemplo","text":"Si tuvieramos solo 4 reviews para entrenar: Review Numero de estrellas I hate the food. 1 The food is good. 3 Service is good. 3 I love the good food. 5 Dado que hay dos reviews con 3 estrellas y cuatro reviews en total, la probabilidad a priori de que un review sea de 3 estrellas es: $$P(3) = \\dfrac{2}{4}$$ Los mismos c\u00e1lculos deber\u00edan de hacerse para 1 estrella y 5 estrellas, de tal manera que tengamos una tabla que traduzca de n\u00famero de estrellas a su probabilidad a priori: N\u00famero de estrellas Probabilidad a Priori 1 $\\dfrac{1}{4}$ 3 $\\dfrac{2}{4}$ 5 $\\dfrac{1}{4}$ Para estimar las probabilidades $P(X|Y)$ (likelihoods), vamos a tomar como ejemplo la estimaci\u00f3n de la probabilidad de \"good\": $$P(\\text{good}|3) = \\dfrac{1 + num(\\text{good}, 3) }{1 + total(3)} = \\dfrac{1 + 2}{1 + 7} = \\dfrac{3}{8}$$ Ya que \"good\" aparece en 2 reviews con 3 estrellas (The food is good, Service is good) y hay 7 palabras en total en reviews con 3 estrellas (The, food, is, good, Service, is, good). Este c\u00e1lculo se tiene que repetir para cada palabra que aparece, al menos, una vez en un review con 3 estrellas y, de igual forma, para las palabras con reviews de 1 y 5 estrellas. Al final, van a tener una tabla con las probabilidades (likelihoods) para cada posible n\u00famero de estrellas, donde cada fila traduce una palabra a su probabilidad dado el n\u00famero de estrellas: $W$ $P(W|1)$ $P(W|3)$ $P(W|5)$ I $\\dfrac{2}{5}$ $\\dfrac{1}{8}$ $\\dfrac{2}{6}$ hate $\\dfrac{2}{5}$ $\\dfrac{1}{8}$ $\\dfrac{1}{6}$ the $\\dfrac{2}{5}$ $\\dfrac{2}{8}$ $\\dfrac{2}{6}$ food $\\dfrac{2}{5}$ $\\dfrac{2}{8}$ $\\dfrac{2}{6}$ is $\\dfrac{1}{5}$ $\\dfrac{3}{8}$ $\\dfrac{1}{6}$ good $\\dfrac{1}{5}$ $\\dfrac{3}{8}$ $\\dfrac{2}{6}$ service $\\dfrac{1}{5}$ $\\dfrac{2}{8}$ $\\dfrac{1}{6}$ love $\\dfrac{1}{5}$ $\\dfrac{1}{8}$ $\\dfrac{2}{6}$ Ya entrenado el modelo, se procede al proceso de clasificaci\u00f3n. Si se utiliza el clasificador Naive Bayes con un dato sin etiqueta, $X$, entonces para todas las posibles etiquetas o categor\u00edas, $Y = y_1, y_2, y_3...$, las probabilidades conjuntas $P(Y=y_1, X)$, $P(Y=y_2, X)$, $P(Y=y_3, X)$... son calculadas y, despu\u00e9s, el dato es clasificado con la etiqueta que tiene la mayor probabilidad conjunta. En este caso, la probabilidad conjunta es calculada como: $$P(Y=y, X) = P(Y=y)P(x_1 | Y=y)P(x_2 | Y=y) P(x_3 | Y=y)...$$ Donde Naive Bayes hace la suposici\u00f3n de que las probabilidades de cada $x_i$ son independientes dada la etiqueta $y$. En nuestro caso, las etiquetas son 1, 3, y 5 estrellas y cada dato es un review $x_i$. M\u00e1s concretamente, supongan que tenemos los mismos cuatro reviews anteriores para entrenar y ustedes quieren, ahora, predecir el n\u00famero de estrellas correspondientes al review \"Good food!\". Para cada posible n\u00famero de estrellas, ustedes calcular\u00edan la probabilidad para ese n\u00famero de estrellas, dado este review, como: $$P(s| \\text{good}, {food}) = P(s)P({good} | s)P(\\text{food} | s)$$ Para cada diferente n\u00famero de estrellas: $P(1| \\text{good}, \\text{food}) = (\\dfrac{1}{4})(\\dfrac{1}{5})(\\dfrac{2}{5}) = \\dfrac{2}{100}$ $P(3| \\text{good}, \\text{food}) = (\\dfrac{2}{4})(\\dfrac{3}{8})(\\dfrac{2}{8}) = \\dfrac{12}{256}$ $P(5| \\text{good}, \\text{food}) = (\\dfrac{1}{4})(\\dfrac{2}{6})(\\dfrac{2}{6}) = \\dfrac{4}{144}$ Dada la probabilidad conjunta del review \"Good food\", siendo 3 estrellas es la m\u00e1s alta, Naive Bayes va a clasificar este review como 3 estrellas. Por \u00faltimo, multiplicar muchos n\u00fameros de punto flotante puede resultar en problemas de precisi\u00f3n (\u00bfse recuerdan por qu\u00e9?). Para resolver este problema, su implementaci\u00f3n para la clasificaci\u00f3n va a calcular el logaritmo natural de las probabilidades (likelihoods) y las probabilidades a priori y, luego, sumarlas (en vez de multiplicar los likelihoods por las probabilidades a priori): $P(1| \\text{good}, \\text{food}) = log(\\dfrac{1}{4}) + log(\\dfrac{1}{5}) + log(\\dfrac{2}{5})$ $P(3| \\text{good}, \\text{food}) = log(\\dfrac{2}{4}) + log(\\dfrac{3}{8}) + log(\\dfrac{2}{8})$ $P(5| \\text{good}, \\text{food}) = log(\\dfrac{1}{4}) + log(\\dfrac{2}{6}) + log(\\dfrac{2}{6})$","title":"Ejemplo"},{"location":"projs/proj04/#su-tarea","text":"Su tarea va a ser terminar el clasificador Naive Bayes. Todo el c\u00f3digo para el clasificador Naive Bayes va estar en classifier.py . Las partes que ustedes tienen que completar est\u00e1n claramente indicadas. Tomen un poco tiempo para entender los comentarios en el archivo. Ustedes son libres de implementar las funciones correspondientes de cualquier forma (utilizando MapReduce y Spark, obviamente). Sin embargo, solo vamos a aceptar c\u00f3digo que est\u00e9 en classifier.py . Si su c\u00f3digo tiene otras dependencias y/o no funciona junto con run.py , no va a funcionar y tendr\u00e1n una nota de 0 puntos. El archivo que corre el clasificador es run.py . Si\u00e9ntanse libres de modificar este archivo para depurar, pero recuerden que ninguno de sus cambios a este archivo se van a utilizar para la calificaci\u00f3n final. En general, las funciones que se tienen que implementar son: def calculate_priors ( self , rdd , size ): def calculate_words_per_num_stars ( self , rdd ): def calculate_likelihoods ( self , rdd ): def predict ( self , rdd ):","title":"Su Tarea"},{"location":"projs/proj04/#pruebas","text":"","title":"Pruebas"},{"location":"projs/proj04/#dataset","text":"Primero tienen que descargar el dataset con el que vamos a estar trabajando haciendo lo siguiente: cd data python preprocess.py cd .. Esto va a descargar el dataset, procesarlo y generar los siguientes archivos: reviews-train-sample.txt reviews-test-sample.txt reviews-labels-sample.txt reviews-train-small.txt reviews-test-small.txt reviews-labels-small.txt reviews-train-medium.txt reviews-test-medium.txt reviews-labels-medium.txt reviews-train-large.txt reviews-test-large.txt reviews-labels-large.txt Estos archivos son cargados por run.py en un RDD de Spark, donde cada l\u00ednea de los archivos de entrenamiento (train) representa un diccionario de Python con la siguiente estructura: { 'id' : review_id , 'text' : review_text , 'stars' : review_stars } Cada l\u00ednea de los archivos de prueba (test) representa un diccionario de Python con la siguiente estructura: { 'id' : review_id , 'text' : review_text } Noten que el n\u00famero de estrellas no est\u00e1 presente en estos archivos, ya que es tarea del clasificador predecir ese n\u00famero. De todas maneras las etiquetas correctas est\u00e1n en los archivos de etiquetas (labels) que se utilizan para verificar el porcentaje de acierto, estos tienen la siguiente estructura: { 'id' : review_id , 'stars' : review_stars } Recuerden que review_stars solo puede considerar 1 , 3 o 5 , y que el texto es \"texto crudo\" ( raw text ), que no est\u00e1 separado por palabras.","title":"Dataset"},{"location":"projs/proj04/#tokenizar-texto-en-palabras","text":"Ya que hay diferentes maneras en Python de tokenizar un texto en palabras, ustedes tienen que utilizar lo siguiente para realizar esta tarea: # texto a tokenizar text = 'Hello World!!' # remueve la puntuacion text2 = text . translate ( str . maketrans ( '' , '' , string . punctuation )) . strip () # genera un arreglo de palabras en minuscula words = [ w . lower () for w in text2 . split ( ' ' )] print ( words ) Run Clear De esta forma su resultado ser\u00e1 igual al esperado por el autograder si por alguna raz\u00f3n no llegan al tiempo esperado.","title":"Tokenizar texto en palabras"},{"location":"projs/proj04/#depuracion","text":"Para este proyecto no hay autograder local. Pero vamos a dejar el output del staff para un dataset de ejemplo. Este dataset de ejemplo contiene 10 reviews para entrenamiento y 5 reviews para clasificaci\u00f3n. Si\u00e9ntanse libres de utilizarlo para depurar su salida de cada parte de su implementaci\u00f3n. Cuando ustedes corran el dataset de ejemplo, run.py va a generar autom\u00e1ticamente un archivo llamado debug_diffs.txt en el directorio out/ , que va a contener las diferencias de su implementaci\u00f3n con respecto a las del staff (si es que hay alguna) o indicar que todo est\u00e1 correcto. Noten que como es un dataset demasiado peque\u00f1o, no se tienen que preocupar del porcentaje de acierto si es bajo o 0. Pueden correr el dataset de ejemplo utilizando: ./check sample Si todo esta correcto les tiene que salir algo similar a esto: [PRIORS] OK [\u2713] [WORDS PER # STARS] OK [\u2713] [LIKELIHOODS] OK [\u2713] [PREDICTION] OK [\u2713] De lo contrario contendr\u00e1 las diferencias de cada una de las partes, por ejemplo: [PRIORS] prior for 1 stars, P(1), should be 0.100000 instead of -1.000000 prior for 3 stars, P(3), should be 0.100000 instead of -1.000000 prior for 5 stars, P(5), should be 0.800000 instead of -1.000000 [WORDS PER # STARS] words per 1 stars should be 22 instead of -1 words per 3 stars should be 722 instead of -1 words per 5 stars should be 905 instead of -1 ...","title":"Depuraci\u00f3n"},{"location":"projs/proj04/#benchmark","text":"Una vez hayan implementado todas las partes faltantes, hay tres datasets para que ustedes prueben y as\u00ed ver el porcentaje de acierto y el tiempo que se toma en ejecutar su programa. Pueden probar su c\u00f3digo de Spark en cada uno de estos datasets utilizando el comando: ./check ( small | medium | large ) El cual generar\u00e1 un archivo .txt con el nombre del dataset utilizado que contendr\u00e1 la informaci\u00f3n mencionada, por ejemplo si utilizan ./check large , esto generar\u00eda un archivo llamado out/large.txt con la siguiente informaci\u00f3n: time: 32.44 seconds accuracy: 75.23 Cada dataset est\u00e1 estructurado de la siguiente forma: Dataset # reviews para entrenamiento # reviews para test % acierto Staff Tiempo Staff small 3750 1250 38.24 ~5 segundos medium 37500 12500 65.36 ~10 segundos large 375000 125000 75.23 ~30 segundos El dataset peque\u00f1o deber\u00eda de correr bastante r\u00e1pido, as\u00ed que deber\u00edan de utilizar este para probar su implementaci\u00f3n y asegurarse de que corresponden con los benchmarks del staff. Si su implementaci\u00f3n es mejor, y logra m\u00e1s porcentaje de acierto que el nuestro, \u00a1genial!, sin embargo, por favor noten que vamos a poner l\u00edmites de tiempo. Es decir, si su porcentaje de acierto es igual o mejor que el del staff, pero es significativamente m\u00e1s lento que nuestra implementaci\u00f3n, no van a obtener una buena nota en el autograder. Ya que es el \u00faltimo proyecto, la calificaci\u00f3n va a ser bastante simple. Vamos a correr su implementaci\u00f3n en un dataset m\u00e1s grande (2 millones de reviews). Si es igual o mejor que el porcentaje de acierto que el staff, y no toma mucho tiempo para correr, ustedes van a obtener la nota completa. Si ustedes lograron el benchmark para los tres datasets que les damos, pueden estar 100% seguros que van a lograrlo en el autograder. De todas maneras, se van a dar cr\u00e9ditos parciales de la siguiente manera: 20% si su implementaci\u00f3n corre sin errores 20% si obtienen un porcentaje de acierto diferente de 0 10% si calculan correctamente calculate_priors 10% si calculan correctamente calculate_words_per_num_stars 20% si calculan correctamente calculate_likelihoods 20% si calculan correctamente predict Para los 4 \u00faltimos puntos, vamos a probar estas funciones aisladas para darles los cr\u00e9ditos parciales.","title":"Benchmark"},{"location":"projs/proj04/#calificacion","text":"Por favor empiecen lo antes posible, porque vamos a utilizar instancias de Amazon para el autograder y este solo puede procesar 4 submits al mismo tiempo (esto por lo general toma bastante tiempo en completarse). Para este proyecto vamos a limitar la cantidad de veces que ustedes pueden hacer submit, a 5 por persona . S\u00ed, si ustedes van en pareja, en teor\u00eda tendr\u00edan 10 submits. De esta manera, tal vez, motivamos la colaboraci\u00f3n. Les recomendamos que prueben en las computadoras de los laboratorios antes de desperdiciar cr\u00e9ditos, si es que en su computadora no pueden lograr los tiempos del staff. Las medidas no van a ser exactas, pero les dar\u00e1n una idea. Pueden subir su implementaci\u00f3n al autograder, haciendo lo siguiente: ./submit <TOKEN> lo que va a resultar en algo parecido a esto: ___ __ __ / _ | __ __/ /____ ___ _______ ____/ /__ ____ / __ / // / __/ _ \\/ _ \\/ __/ _ \\/ _ / -_ ) __/ /_/ | _ \\_ ,_/ \\_ _/ \\_ __/ \\_ , /_/ \\_ ,_/ \\_ ,_/ \\_ _/_/ /___/ Machine Structures Great Ideas in Computer Architecture Repo: proj4_spark Best Score: 100 /100 Last Output: Exercise Grade Message ---------------------------------------- ----- ------- 1 . Compiling implementation 20 passed 2 . Non-zero accuracy 20 passed 3 . Correct calculate_priors 10 passed 4 . Correct calculate_words_per_num_stars 10 passed 5 . Correct calculate_likelihoods 20 passed 6 . Correct predict 20 passed Esperamos que hayan disfrutado el curso, muchos \u00e9xitos en lo que viene.","title":"Calificaci\u00f3n"},{"location":"tutorials/install/","text":"Tutorial de Instalacion de material \u00b6 El objetivo de este tutorial es dejar preparado el material que necesitaran para los laboratorios y proyectos. La mejor opcion: M\u00e1quina virtual \u00b6 Puede utilizar VMware Player (gratuito, sin necesidad de licencia) para abrir y utilizar maquinas virtuales ya hechas. Adicionalmente, en los pr\u00f3ximos d\u00edas se les enviar\u00e1 licencia para VMware Workstation con el cual tambi\u00e9n pueden crear sus propias m\u00e1quinas virtuales. Luego de instalar VMware Player, descargue la siguiente m\u00e1quina virtual. Descompr\u00edmala y abra el archivo .vmx (VMware virtual machine configuration). Todos los links son para la misma maquina virtual. Si alguno falla, utilice otro. Descargar maquina virtual desde Google Drive Usuario: student Contrasena: student La maquina virtual trae ya todo lo necesario para el semestre. Mejorando el desempe\u00f1o de la m\u00e1quina virtual \u00b6 Luego de abrir la m\u00e1quina virtual en VMware, podemos ir a VM > Settings... y hacer los siguientes cambios. En Memory aumente la cantidad de RAM que la m\u00e1quina virtual puede usar. Si tiene menos de 4 GB de RAM, d\u00e9jela como est\u00e1. Si tiene entre 4 GB y 8 GB de RAM, coloque la mitad de su RAM. Si tiene m\u00e1s de 8 GB de RAM, coloque 4 GB. En Processors active la opci\u00f3n Virtualize Intel VT-x or AMD-V . Si aparece una ventana que indica que VT-x o AMD-V no est\u00e1n activados, debe ingresar a la BIOS de su m\u00e1quina y activarlo desde all\u00ed. Este proceso cambia de una m\u00e1quina a otra, entonces busque en Google algo como Enable VT-x Asus Windows 10 . Coloque VT-x si su procesador es Intel, AMD-V si es AMD. Sustituya la marca de su computadora y la versi\u00f3n de Windows que utiliza. Otra opcion: Nativo \u00b6 Para trabajar nativo necesitar\u00e1 Ubuntu 18 o 20 en ingl\u00e9s, se recomienda fuertemente Ubuntu 18. Si su Ubuntu no se encuentra en ingles, tendra problemas en el lab 2 (cgdb). Puede cambiar su idioma, o buscar la solucion al problema en Google. Si todavia no tiene Ubuntu instalado aqui hay un tutorial para dual boot . Ponga mucha atenci\u00f3n, sea muy cuidadoso y sobre todo haga un backup de su informaci\u00f3n importante antes de comenzar. Wow... parece que son bastantes instrucciones, seria m\u00e1s facil usar la m\u00e1quina virtual! Instalar git sudo apt update sudo apt install git Instalar Java sudo apt update sudo apt install default-jdk Instalar Python 3 sudo apt update sudo apt install software-properties-common sudo add-apt-repository ppa:deadsnakes/ppa sudo apt update sudo apt install python3.7 Instalar pip sudo apt update sudo apt install python3-pip Las versiones recientes de Python suelen incluir todo lo que necesitamos (en la maquina virtual ya revisamos y esta todo lo que necesita! en serio, use la maquina virtual!), verifiquemoslo abriendo la terminal de Python con el comando python3 , luego en la terminal escribiremos los siguientes comandos import os import sys import requests import zipfile Si ninguno nos dio problema, Python esta listo; si alguno fallo, lo instalaremos con pip pip3 install nombreDelPaqueteQueDioError Finalmente instalamos curl sudo apt update sudo apt install curl Y terminamos instalando cgdb sudo apt update sudo apt install cgdb Casi listo! Cuando lleguemos al lab 3 y al lab 5 all\u00ed le aparecer\u00e1n las instrucciones para instalar el software faltante.","title":"Instalacion de material"},{"location":"tutorials/install/#tutorial-de-instalacion-de-material","text":"El objetivo de este tutorial es dejar preparado el material que necesitaran para los laboratorios y proyectos.","title":"Tutorial de Instalacion de material"},{"location":"tutorials/install/#la-mejor-opcion-maquina-virtual","text":"Puede utilizar VMware Player (gratuito, sin necesidad de licencia) para abrir y utilizar maquinas virtuales ya hechas. Adicionalmente, en los pr\u00f3ximos d\u00edas se les enviar\u00e1 licencia para VMware Workstation con el cual tambi\u00e9n pueden crear sus propias m\u00e1quinas virtuales. Luego de instalar VMware Player, descargue la siguiente m\u00e1quina virtual. Descompr\u00edmala y abra el archivo .vmx (VMware virtual machine configuration). Todos los links son para la misma maquina virtual. Si alguno falla, utilice otro. Descargar maquina virtual desde Google Drive Usuario: student Contrasena: student La maquina virtual trae ya todo lo necesario para el semestre.","title":"La mejor opcion: M\u00e1quina virtual"},{"location":"tutorials/install/#mejorando-el-desempeno-de-la-maquina-virtual","text":"Luego de abrir la m\u00e1quina virtual en VMware, podemos ir a VM > Settings... y hacer los siguientes cambios. En Memory aumente la cantidad de RAM que la m\u00e1quina virtual puede usar. Si tiene menos de 4 GB de RAM, d\u00e9jela como est\u00e1. Si tiene entre 4 GB y 8 GB de RAM, coloque la mitad de su RAM. Si tiene m\u00e1s de 8 GB de RAM, coloque 4 GB. En Processors active la opci\u00f3n Virtualize Intel VT-x or AMD-V . Si aparece una ventana que indica que VT-x o AMD-V no est\u00e1n activados, debe ingresar a la BIOS de su m\u00e1quina y activarlo desde all\u00ed. Este proceso cambia de una m\u00e1quina a otra, entonces busque en Google algo como Enable VT-x Asus Windows 10 . Coloque VT-x si su procesador es Intel, AMD-V si es AMD. Sustituya la marca de su computadora y la versi\u00f3n de Windows que utiliza.","title":"Mejorando el desempe\u00f1o de la m\u00e1quina virtual"},{"location":"tutorials/install/#otra-opcion-nativo","text":"Para trabajar nativo necesitar\u00e1 Ubuntu 18 o 20 en ingl\u00e9s, se recomienda fuertemente Ubuntu 18. Si su Ubuntu no se encuentra en ingles, tendra problemas en el lab 2 (cgdb). Puede cambiar su idioma, o buscar la solucion al problema en Google. Si todavia no tiene Ubuntu instalado aqui hay un tutorial para dual boot . Ponga mucha atenci\u00f3n, sea muy cuidadoso y sobre todo haga un backup de su informaci\u00f3n importante antes de comenzar. Wow... parece que son bastantes instrucciones, seria m\u00e1s facil usar la m\u00e1quina virtual! Instalar git sudo apt update sudo apt install git Instalar Java sudo apt update sudo apt install default-jdk Instalar Python 3 sudo apt update sudo apt install software-properties-common sudo add-apt-repository ppa:deadsnakes/ppa sudo apt update sudo apt install python3.7 Instalar pip sudo apt update sudo apt install python3-pip Las versiones recientes de Python suelen incluir todo lo que necesitamos (en la maquina virtual ya revisamos y esta todo lo que necesita! en serio, use la maquina virtual!), verifiquemoslo abriendo la terminal de Python con el comando python3 , luego en la terminal escribiremos los siguientes comandos import os import sys import requests import zipfile Si ninguno nos dio problema, Python esta listo; si alguno fallo, lo instalaremos con pip pip3 install nombreDelPaqueteQueDioError Finalmente instalamos curl sudo apt update sudo apt install curl Y terminamos instalando cgdb sudo apt update sudo apt install cgdb Casi listo! Cuando lleguemos al lab 3 y al lab 5 all\u00ed le aparecer\u00e1n las instrucciones para instalar el software faltante.","title":"Otra opcion: Nativo"},{"location":"tutorials/python/","text":"Tutorial de Python 3 \u00b6 El objetivo de este tutorial es que ustedes puedan aprender sobre lo b\u00e1sico de Python 3 , no esperamos que se vuelvan expertos con esta introducci\u00f3n. En este curso no es fundamental que dominen al 100% este lenguaje de programaci\u00f3n y realmente solo necesitan conocer lo b\u00e1sico para poder completar satisfactoriamente los laboratorios y proyectos que utilicen este lenguaje. Instalaci\u00f3n \u00b6 Actualmente hay 2 diferentes versiones soportadas de Python: 2.7 y 3.X . Para este curso vamos a estar utilizando Python 3 y m\u00e1s especificamente utilizar Anaconda Python. Para instalar Anaconda en sus computadoras tienen que hacer lo siguiente: wget https://repo.anaconda.com/archive/Anaconda3-2019.03-Linux-x86_64.sh bash Anaconda3-2019.03-Linux-x86_64.sh source ~/.bashrc Esto va a instalar Anaconda Python 3.7 , para verificar la version pueden correr el siguiente comando: python --version Para abrir el int\u00e9rprete de Python solo necesitan escribir: python Si su instalaci\u00f3n es correcta resultar\u00e1 en algo como esto: Python 3 .7.3 ( default, Mar 27 2019 , 22 :11:17 ) [ GCC 7 .3.0 ] :: Anaconda, Inc. on linux Type \"help\" , \"copyright\" , \"credits\" or \"license\" for more information. >>> Introducci\u00f3n \u00b6 Python es un lenguaje de programaci\u00f3n multiparadigma y con tipos din\u00e1micos . El c\u00f3digo escrito en Python se dice que es similar al pseudoc\u00f3digo, ya que permite expresar ideas bastante poderosas en muy pocas l\u00edneas de c\u00f3digo y al mismo tiempo ser bastante le\u00edble. Como ejemplo, aqu\u00ed hay una implementaci\u00f3n del cl\u00e1sico algoritmo quicksort escrito en Python: def quicksort ( arr ): if len ( arr ) <= 1 : return arr pivot = arr [ len ( arr ) // 2 ] left = [ x for x in arr if x < pivot ] middle = [ x for x in arr if x == pivot ] right = [ x for x in arr if x > pivot ] return quicksort ( left ) + middle + quicksort ( right ) print ( quicksort ([ 3 , 6 , 8 , 10 , 1 , 2 , 1 ])) Run Clear Tipos de datos b\u00e1sicos \u00b6 Como en muchos lenguajes, Python tiene un n\u00famero de tipos de datos b\u00e1sicos incluyendo enteros, floats, booleans y strings. Estos tipos de datos se comportan como lo han visto en otros lenguajes de programaci\u00f3n (C por ejemplo). N\u00fameros \u00b6 Los enteros y los floats funcionan como ustedes han visto que funcionan en otros lenguajes: x = 3 print ( type ( x )) # type: sirve para obtener el tipo de un objeto print ( x ) print ( x + 1 ) print ( x - 1 ) print ( x * 2 ) print ( x / 2 ) # division exacta print ( x // 2 ) # division entera print ( x ** 3 ) # exponentes x += 1 print ( x ) x *= 2 print ( x ) y = 2.5 print ( type ( y )) print ( y ) print ( y + 1 ) print ( y * 2 ) print ( y / 2 ) print ( y ** 2 ) Run Clear Noten que Python no tiene los operadores de incremento unario ( x++ ) o decremento ( x-- ). Python tambi\u00e9n tiene tipos para manejo de n\u00fameros completos, todo esto lo pueden ver en la documentaci\u00f3n Booleans \u00b6 Python implementa todos los operadores usuales para hacer l\u00f3gica booleana, pero usa palabras en Ingl\u00e9s en vez de s\u00edmbolos ( && , || , etc.): t = True f = False print ( type ( t )) print ( t and f ) # AND l\u00f3gico print ( t or f ) # OR l\u00f3gico print ( not t ) # NOT l\u00f3gico print ( t != f ) # XOR l\u00f3gico Run Clear Strings \u00b6 Python tiene buen soporte de strings: hello = 'hello' # las literales string pueden ser declaradas con ap\u00f3stofre world = \"world\" # o comillas, no importa la verdad... print ( hello ) print ( len ( hello )) # con len obtenemos el length del string hw = hello + ' ' + world # concatenaci\u00f3n, as\u00ed como en Java print ( hw ) hw12 = ' %s %s %d ' % ( hello , world , 12 ) # formato de texto al estilo sprintf print ( hw12 ) Run Clear Los objetos de tipo string tienen un mont\u00f3n de m\u00e9todos \u00fatiles; Por ejemplo: s = 'hello' # Pone la letra del principio en mayuscula print ( s . capitalize ()) # Pasa el string a mayusculas print ( s . upper ()) # Justifica un string, rellenando con espacios print ( s . rjust ( 7 )) # Centra un string, rellanando con espacios print ( s . center ( 7 )) # Reemplaza todas las apariciones de un substring por otro print ( s . replace ( 'l' , '(ell)' )) # Quita todos los caracteres de whitespace del principio y final print ( ' world ' . strip ()) Run Clear Pueden encontrar una lista de todos los m\u00e9todos en la documentaci\u00f3n . Contenedores \u00b6 Python incluye bastantes tipos de contenedores: listas, diccionarios, sets y tuplas. Listas \u00b6 Una lista en Python es equivalente a un arreglo en C o Java, pero es din\u00e1mico (puede cambiar su tama\u00f1o, es decir no es fijo) y puede tener elementos de diferentes tipos:\\ # Crea una lista xs = [ 3 , 1 , 2 ] print ( xs ) # Para acceder a un elemento de la lista, los indices van de 0 a length - 1 print ( xs [ 1 ]) # Los indices negativos empiezan desde el final de la lista print ( xs [ - 1 ]) # Las listas pueden contener elementos de diferentes tipos xs [ 2 ] = 'foo' print ( xs ) # A\u00f1ade un elemento al final de la lista xs . append ( 'bar' ) print ( xs ) # Quita y devuelve el \u00faltimo elemento de la lista x = xs . pop () print ( x , xs ) # para obtener el length de la lista print ( len ( xs )) Run Clear Puden encontrar m\u00e1s detalles en la documentaci\u00f3n de listas. Slicing \u00b6 Adem\u00e1s de acceder a los elementos de una lista uno a la vez, Python provee una sintaxis para acceder a sublistas, a esto se le conoce como slicing : # Creamos una nueva lista nums = [ 0 , 1 , 2 , 3 , 4 ] print ( nums ) # Agarra una sublista desde el indice 2 hasta el indice 3 es decir [2,4) print ( nums [ 2 : 4 ]) # Agarra una sublista desde el indice 2 hasta el final de la lista, es decir [2,4] print ( nums [ 2 :]) # Agarra una sublista desde el principio de la misma hasta el indice 2 sin incluir, es decir [0,2) print ( nums [: 2 ]) # Agarra toda la lista \"[0, 1, 2, 3, 4]\" print ( nums [:]) # El slice puede ser negativo, en este caso agarra desde el principio hasta el penultimo elemento, es decir [0,3] print ( nums [: - 1 ]) # Asigna una sublista al slice nums [ 2 : 4 ] = [ 8 , 9 ] print ( nums ) Run Clear Ciclos \u00b6 Pueden iterar sobre elementos de una lista de la siguiente manera: animals = [ 'cat' , 'dog' , 'monkey' ] for animal in animals : print ( animal ) Run Clear Si quieren acceder al indice de cada elemento dentro del ciclo, pueden utilizar la funcion \u201cenumerate\u201d: animals = [ 'cat' , 'dog' , 'monkey' ] for idx , animal in enumerate ( animals ): print ( '# %d : %s ' % ( idx + 1 , animal )) Run Clear List comprehensions \u00b6 Cuando estamos programando, frecuentemente vamos a querer transformar un tipo de dato hacia otro. Como un ejemplo simple, consideren el siguiente c\u00f3digo que calcula numeros al cuadrado: nums = [ 0 , 1 , 2 , 3 , 4 ] squares = [] for x in nums : squares . append ( x ** 2 ) print ( squares ) Run Clear Pueden hacer este c\u00f3digo m\u00e1s simple utilizando una list comprehension: nums = [ 0 , 1 , 2 , 3 , 4 ] squares = [ x ** 2 for x in nums ] # list comprehension print ( squares ) Run Clear Las list comprehension pueden contener condiciones: nums = [ 0 , 1 , 2 , 3 , 4 ] even_squares = [ x ** 2 for x in nums if x % 2 == 0 ] print ( even_squares ) Run Clear Diccionarios \u00b6 Un diccionario guarda un par (key, value), similar a un Map en java. Pueden utilizarlo as\u00ed: # crea un nuevo diccionario con algunos datos d = { 'cat' : 'cute' , 'dog' : 'furry' } # toma el valor del key 'cat' print ( d [ 'cat' ]) # verifica que el key 'cat' este en el diccionario d print ( 'cat' in d ) # a\u00f1ade un par key, value al diccionario d d [ 'fish' ] = 'wet' print ( d [ 'fish' ]) # el key 'monkey' no existe, pero podemos poner un valor por defecto, en este caso N/A print ( d . get ( 'monkey' , 'N/A' )) # como fish existe no imprime el valor por defecto print ( d . get ( 'fish' , 'N/A' )) # podemos eliminar elementos del diccionario del d [ 'fish' ] # come fish lo quitamos y ya no existe, tiene que devolver el valor por defecto print ( d . get ( 'fish' , 'N/A' )) Run Clear Pueden encontrar todo lo que necesitan saber de diccionarios en la documentaci\u00f3n . Ciclos \u00b6 Es f\u00e1cil iterar sobre las keys de un diccionario: d = { 'person' : 2 , 'cat' : 4 , 'spider' : 8 } for animal in d : legs = d [ animal ] print ( 'A %s has %d legs' % ( animal , legs )) Run Clear Si quieren acceder a las keys y sus valores correspondientes pueden utilizar el m\u00e9todo \u201citems\u201d: d = { 'person' : 2 , 'cat' : 4 , 'spider' : 8 } for animal , legs in d . items (): print ( 'A %s has %d legs' % ( animal , legs )) Run Clear Dictionary comprehensions \u00b6 Estos son similares a las list comprehensions, pero ayuda a construir diccionarios f\u00e1cilmente, por ejemplo: nums = [ 0 , 1 , 2 , 3 , 4 ] even_num_to_square = { x : x ** 2 for x in nums if x % 2 == 0 } print ( even_num_to_square ) Run Clear Sets \u00b6 Un set es un la colecci\u00f3n no ordenada de elementos distintos. Como ejemplo simple, consideren lo siguiente: animals = { 'cat' , 'dog' } # Verifica que un elemento este en el set print ( 'cat' in animals ) print ( 'fish' in animals ) # A\u00f1ade un elemento al set animals . add ( 'fish' ) print ( 'fish' in animals ) # Numero de elementos en un set print ( len ( animals )) # A\u00f1adir un elemento que ya esta en el set, lo permite pero no pasa nada animals . add ( 'cat' ) print ( len ( animals )) # Remueve un elemento del set animals . remove ( 'cat' ) print ( len ( animals )) Run Clear Otra vez, todo lo que quieran saber acerca de los sets lo pueden encontrar en la documentaci\u00f3n . Loops \u00b6 Iterear sobre un set tienen la misma sintaxis que iterar sobre una lista, sin embargo como los sets no tienen orden, no pueden asumir sobre en que orden se van a visitar los elementos del set: animals = { 'cat' , 'dog' , 'fish' } for idx , animal in enumerate ( animals ): print ( '# %d : %s ' % ( idx + 1 , animal )) Run Clear Set comprehensions \u00b6 como las listas y los diccionarios, podemos construir sets f\u00e1cilmente utilizando set comprehensions: from math import sqrt nums = { int ( sqrt ( x )) for x in range ( 30 )} print ( nums ) Run Clear Tuplas \u00b6 Una tupla es una lista ordenada de elementos \u201cfija\u201d. Una tupla es bastante similar a una lista, una de las m\u00e1s importantes diferencias es que las tuplas se pueden utilizar como keys en un diccionario y como elementos de los sets, mientras que las listas no. Aqu\u00ed hay un ejemplo: # Crea un diccionario con keys de tuplas d = {( x , x + 1 ): x for x in range ( 10 )} # Crea una tupla t = ( 5 , 6 ) print ( type ( t )) print ( d [ t ]) print ( d [( 1 , 2 )]) Run Clear La documentaci\u00f3n tiene mas informaci\u00f3n acerca de las tuplas. Funciones \u00b6 Las funciones de Python se definen utilizando el keyword def. Por ejemplo: def sign ( x ): if x > 0 : return 'positive' elif x < 0 : return 'negative' else : return 'zero' for x in [ - 1 , 0 , 1 ]: print ( sign ( x )) Run Clear Vamos a definir funciones que toman argumentos, y opcionalmente argumentos keyword, como esto: def hello ( name , loud = False ): if loud : print ( 'HELLO, %s ' % name . upper ()) else : print ( 'Hello, %s !' % name ) hello ( 'Bob' ) hello ( 'Fred' , loud = True ) Run Clear Hay mucha informaci\u00f3n acerca de como definir funciones en Python en la documentaci\u00f3n . Funciones Lambda \u00b6 Python tiene una sintaxis definida para funciones an\u00f3nimas, lambda functions , est\u00e1n son bastante utiles para pasarlas como argumento a otras funciones: # importamos la funcion reduce from functools import reduce # definimos una funcion anonima y se la asignamos a una variable x x = lambda l : l ** 2 # podemos usar la funcion anonima como cualquier otra funcion print ( x ( 2 )) # pero lo mas importante es que la podemos pasar como argumento def foo ( f ): return f ( 4 ) print ( foo ( lambda x : x + 1 )) # aunque esto no implica que con las funciones normales puedan hacer esto... def bar ( x ): return x ** 2 print ( foo ( bar )) # por lo general se utilizan con las funciones map, reduce y filter de python que trabajan con listas print ( list ( map ( lambda x : x ** 2 , [ 1 , 2 , 3 , 4 , 5 ]))) print ( list ( filter ( lambda x : x > 2 , [ 1 , 2 , 3 , 4 , 5 ]))) print ( reduce ( lambda a , b : a + b , [ 1 , 2 , 3 , 4 , 5 ])) # pero tambien se ven muy seguido cuando se trabaja con el paradigma MapReduce y Spark # que es parte de su proyecto y este laboratorio !!! Run Clear Clases \u00b6 La sintaxis para definir clases en Python es bastante simple: class Greeter : # Constructor def __init__ ( self , name ): self . name = name # Crea un atributo para la clase # Un metodo de la clase def greet ( self , loud = False ): if loud : print ( 'HELLO, %s !' % self . name . upper ()) else : print ( 'Hello, %s ' % self . name ) # Crea una instancia de la clase g = Greeter ( 'Fred' ) # Llama al metodo de la clase; imprime \"Hello, Fred\" g . greet () # Llama al metodo de la clase; imprime \"HELLO, FRED!\" g . greet ( loud = True ) Run Clear Con esto concluimos el tutorial de Python 3, pueden obtener m\u00e1s informaci\u00f3n en la documentaci\u00f3n de Python 3 oficial o incluso seguir el tutorial completo que ellos tienen.","title":"Python"},{"location":"tutorials/python/#tutorial-de-python-3","text":"El objetivo de este tutorial es que ustedes puedan aprender sobre lo b\u00e1sico de Python 3 , no esperamos que se vuelvan expertos con esta introducci\u00f3n. En este curso no es fundamental que dominen al 100% este lenguaje de programaci\u00f3n y realmente solo necesitan conocer lo b\u00e1sico para poder completar satisfactoriamente los laboratorios y proyectos que utilicen este lenguaje.","title":"Tutorial de Python 3"},{"location":"tutorials/python/#instalacion","text":"Actualmente hay 2 diferentes versiones soportadas de Python: 2.7 y 3.X . Para este curso vamos a estar utilizando Python 3 y m\u00e1s especificamente utilizar Anaconda Python. Para instalar Anaconda en sus computadoras tienen que hacer lo siguiente: wget https://repo.anaconda.com/archive/Anaconda3-2019.03-Linux-x86_64.sh bash Anaconda3-2019.03-Linux-x86_64.sh source ~/.bashrc Esto va a instalar Anaconda Python 3.7 , para verificar la version pueden correr el siguiente comando: python --version Para abrir el int\u00e9rprete de Python solo necesitan escribir: python Si su instalaci\u00f3n es correcta resultar\u00e1 en algo como esto: Python 3 .7.3 ( default, Mar 27 2019 , 22 :11:17 ) [ GCC 7 .3.0 ] :: Anaconda, Inc. on linux Type \"help\" , \"copyright\" , \"credits\" or \"license\" for more information. >>>","title":"Instalaci\u00f3n"},{"location":"tutorials/python/#introduccion","text":"Python es un lenguaje de programaci\u00f3n multiparadigma y con tipos din\u00e1micos . El c\u00f3digo escrito en Python se dice que es similar al pseudoc\u00f3digo, ya que permite expresar ideas bastante poderosas en muy pocas l\u00edneas de c\u00f3digo y al mismo tiempo ser bastante le\u00edble. Como ejemplo, aqu\u00ed hay una implementaci\u00f3n del cl\u00e1sico algoritmo quicksort escrito en Python: def quicksort ( arr ): if len ( arr ) <= 1 : return arr pivot = arr [ len ( arr ) // 2 ] left = [ x for x in arr if x < pivot ] middle = [ x for x in arr if x == pivot ] right = [ x for x in arr if x > pivot ] return quicksort ( left ) + middle + quicksort ( right ) print ( quicksort ([ 3 , 6 , 8 , 10 , 1 , 2 , 1 ])) Run Clear","title":"Introducci\u00f3n"},{"location":"tutorials/python/#tipos-de-datos-basicos","text":"Como en muchos lenguajes, Python tiene un n\u00famero de tipos de datos b\u00e1sicos incluyendo enteros, floats, booleans y strings. Estos tipos de datos se comportan como lo han visto en otros lenguajes de programaci\u00f3n (C por ejemplo).","title":"Tipos de datos b\u00e1sicos"},{"location":"tutorials/python/#numeros","text":"Los enteros y los floats funcionan como ustedes han visto que funcionan en otros lenguajes: x = 3 print ( type ( x )) # type: sirve para obtener el tipo de un objeto print ( x ) print ( x + 1 ) print ( x - 1 ) print ( x * 2 ) print ( x / 2 ) # division exacta print ( x // 2 ) # division entera print ( x ** 3 ) # exponentes x += 1 print ( x ) x *= 2 print ( x ) y = 2.5 print ( type ( y )) print ( y ) print ( y + 1 ) print ( y * 2 ) print ( y / 2 ) print ( y ** 2 ) Run Clear Noten que Python no tiene los operadores de incremento unario ( x++ ) o decremento ( x-- ). Python tambi\u00e9n tiene tipos para manejo de n\u00fameros completos, todo esto lo pueden ver en la documentaci\u00f3n","title":"N\u00fameros"},{"location":"tutorials/python/#booleans","text":"Python implementa todos los operadores usuales para hacer l\u00f3gica booleana, pero usa palabras en Ingl\u00e9s en vez de s\u00edmbolos ( && , || , etc.): t = True f = False print ( type ( t )) print ( t and f ) # AND l\u00f3gico print ( t or f ) # OR l\u00f3gico print ( not t ) # NOT l\u00f3gico print ( t != f ) # XOR l\u00f3gico Run Clear","title":"Booleans"},{"location":"tutorials/python/#strings","text":"Python tiene buen soporte de strings: hello = 'hello' # las literales string pueden ser declaradas con ap\u00f3stofre world = \"world\" # o comillas, no importa la verdad... print ( hello ) print ( len ( hello )) # con len obtenemos el length del string hw = hello + ' ' + world # concatenaci\u00f3n, as\u00ed como en Java print ( hw ) hw12 = ' %s %s %d ' % ( hello , world , 12 ) # formato de texto al estilo sprintf print ( hw12 ) Run Clear Los objetos de tipo string tienen un mont\u00f3n de m\u00e9todos \u00fatiles; Por ejemplo: s = 'hello' # Pone la letra del principio en mayuscula print ( s . capitalize ()) # Pasa el string a mayusculas print ( s . upper ()) # Justifica un string, rellenando con espacios print ( s . rjust ( 7 )) # Centra un string, rellanando con espacios print ( s . center ( 7 )) # Reemplaza todas las apariciones de un substring por otro print ( s . replace ( 'l' , '(ell)' )) # Quita todos los caracteres de whitespace del principio y final print ( ' world ' . strip ()) Run Clear Pueden encontrar una lista de todos los m\u00e9todos en la documentaci\u00f3n .","title":"Strings"},{"location":"tutorials/python/#contenedores","text":"Python incluye bastantes tipos de contenedores: listas, diccionarios, sets y tuplas.","title":"Contenedores"},{"location":"tutorials/python/#listas","text":"Una lista en Python es equivalente a un arreglo en C o Java, pero es din\u00e1mico (puede cambiar su tama\u00f1o, es decir no es fijo) y puede tener elementos de diferentes tipos:\\ # Crea una lista xs = [ 3 , 1 , 2 ] print ( xs ) # Para acceder a un elemento de la lista, los indices van de 0 a length - 1 print ( xs [ 1 ]) # Los indices negativos empiezan desde el final de la lista print ( xs [ - 1 ]) # Las listas pueden contener elementos de diferentes tipos xs [ 2 ] = 'foo' print ( xs ) # A\u00f1ade un elemento al final de la lista xs . append ( 'bar' ) print ( xs ) # Quita y devuelve el \u00faltimo elemento de la lista x = xs . pop () print ( x , xs ) # para obtener el length de la lista print ( len ( xs )) Run Clear Puden encontrar m\u00e1s detalles en la documentaci\u00f3n de listas.","title":"Listas"},{"location":"tutorials/python/#slicing","text":"Adem\u00e1s de acceder a los elementos de una lista uno a la vez, Python provee una sintaxis para acceder a sublistas, a esto se le conoce como slicing : # Creamos una nueva lista nums = [ 0 , 1 , 2 , 3 , 4 ] print ( nums ) # Agarra una sublista desde el indice 2 hasta el indice 3 es decir [2,4) print ( nums [ 2 : 4 ]) # Agarra una sublista desde el indice 2 hasta el final de la lista, es decir [2,4] print ( nums [ 2 :]) # Agarra una sublista desde el principio de la misma hasta el indice 2 sin incluir, es decir [0,2) print ( nums [: 2 ]) # Agarra toda la lista \"[0, 1, 2, 3, 4]\" print ( nums [:]) # El slice puede ser negativo, en este caso agarra desde el principio hasta el penultimo elemento, es decir [0,3] print ( nums [: - 1 ]) # Asigna una sublista al slice nums [ 2 : 4 ] = [ 8 , 9 ] print ( nums ) Run Clear","title":"Slicing"},{"location":"tutorials/python/#ciclos","text":"Pueden iterar sobre elementos de una lista de la siguiente manera: animals = [ 'cat' , 'dog' , 'monkey' ] for animal in animals : print ( animal ) Run Clear Si quieren acceder al indice de cada elemento dentro del ciclo, pueden utilizar la funcion \u201cenumerate\u201d: animals = [ 'cat' , 'dog' , 'monkey' ] for idx , animal in enumerate ( animals ): print ( '# %d : %s ' % ( idx + 1 , animal )) Run Clear","title":"Ciclos"},{"location":"tutorials/python/#list-comprehensions","text":"Cuando estamos programando, frecuentemente vamos a querer transformar un tipo de dato hacia otro. Como un ejemplo simple, consideren el siguiente c\u00f3digo que calcula numeros al cuadrado: nums = [ 0 , 1 , 2 , 3 , 4 ] squares = [] for x in nums : squares . append ( x ** 2 ) print ( squares ) Run Clear Pueden hacer este c\u00f3digo m\u00e1s simple utilizando una list comprehension: nums = [ 0 , 1 , 2 , 3 , 4 ] squares = [ x ** 2 for x in nums ] # list comprehension print ( squares ) Run Clear Las list comprehension pueden contener condiciones: nums = [ 0 , 1 , 2 , 3 , 4 ] even_squares = [ x ** 2 for x in nums if x % 2 == 0 ] print ( even_squares ) Run Clear","title":"List comprehensions"},{"location":"tutorials/python/#diccionarios","text":"Un diccionario guarda un par (key, value), similar a un Map en java. Pueden utilizarlo as\u00ed: # crea un nuevo diccionario con algunos datos d = { 'cat' : 'cute' , 'dog' : 'furry' } # toma el valor del key 'cat' print ( d [ 'cat' ]) # verifica que el key 'cat' este en el diccionario d print ( 'cat' in d ) # a\u00f1ade un par key, value al diccionario d d [ 'fish' ] = 'wet' print ( d [ 'fish' ]) # el key 'monkey' no existe, pero podemos poner un valor por defecto, en este caso N/A print ( d . get ( 'monkey' , 'N/A' )) # como fish existe no imprime el valor por defecto print ( d . get ( 'fish' , 'N/A' )) # podemos eliminar elementos del diccionario del d [ 'fish' ] # come fish lo quitamos y ya no existe, tiene que devolver el valor por defecto print ( d . get ( 'fish' , 'N/A' )) Run Clear Pueden encontrar todo lo que necesitan saber de diccionarios en la documentaci\u00f3n .","title":"Diccionarios"},{"location":"tutorials/python/#ciclos_1","text":"Es f\u00e1cil iterar sobre las keys de un diccionario: d = { 'person' : 2 , 'cat' : 4 , 'spider' : 8 } for animal in d : legs = d [ animal ] print ( 'A %s has %d legs' % ( animal , legs )) Run Clear Si quieren acceder a las keys y sus valores correspondientes pueden utilizar el m\u00e9todo \u201citems\u201d: d = { 'person' : 2 , 'cat' : 4 , 'spider' : 8 } for animal , legs in d . items (): print ( 'A %s has %d legs' % ( animal , legs )) Run Clear","title":"Ciclos"},{"location":"tutorials/python/#dictionary-comprehensions","text":"Estos son similares a las list comprehensions, pero ayuda a construir diccionarios f\u00e1cilmente, por ejemplo: nums = [ 0 , 1 , 2 , 3 , 4 ] even_num_to_square = { x : x ** 2 for x in nums if x % 2 == 0 } print ( even_num_to_square ) Run Clear","title":"Dictionary comprehensions"},{"location":"tutorials/python/#sets","text":"Un set es un la colecci\u00f3n no ordenada de elementos distintos. Como ejemplo simple, consideren lo siguiente: animals = { 'cat' , 'dog' } # Verifica que un elemento este en el set print ( 'cat' in animals ) print ( 'fish' in animals ) # A\u00f1ade un elemento al set animals . add ( 'fish' ) print ( 'fish' in animals ) # Numero de elementos en un set print ( len ( animals )) # A\u00f1adir un elemento que ya esta en el set, lo permite pero no pasa nada animals . add ( 'cat' ) print ( len ( animals )) # Remueve un elemento del set animals . remove ( 'cat' ) print ( len ( animals )) Run Clear Otra vez, todo lo que quieran saber acerca de los sets lo pueden encontrar en la documentaci\u00f3n .","title":"Sets"},{"location":"tutorials/python/#loops","text":"Iterear sobre un set tienen la misma sintaxis que iterar sobre una lista, sin embargo como los sets no tienen orden, no pueden asumir sobre en que orden se van a visitar los elementos del set: animals = { 'cat' , 'dog' , 'fish' } for idx , animal in enumerate ( animals ): print ( '# %d : %s ' % ( idx + 1 , animal )) Run Clear","title":"Loops"},{"location":"tutorials/python/#set-comprehensions","text":"como las listas y los diccionarios, podemos construir sets f\u00e1cilmente utilizando set comprehensions: from math import sqrt nums = { int ( sqrt ( x )) for x in range ( 30 )} print ( nums ) Run Clear","title":"Set comprehensions"},{"location":"tutorials/python/#tuplas","text":"Una tupla es una lista ordenada de elementos \u201cfija\u201d. Una tupla es bastante similar a una lista, una de las m\u00e1s importantes diferencias es que las tuplas se pueden utilizar como keys en un diccionario y como elementos de los sets, mientras que las listas no. Aqu\u00ed hay un ejemplo: # Crea un diccionario con keys de tuplas d = {( x , x + 1 ): x for x in range ( 10 )} # Crea una tupla t = ( 5 , 6 ) print ( type ( t )) print ( d [ t ]) print ( d [( 1 , 2 )]) Run Clear La documentaci\u00f3n tiene mas informaci\u00f3n acerca de las tuplas.","title":"Tuplas"},{"location":"tutorials/python/#funciones","text":"Las funciones de Python se definen utilizando el keyword def. Por ejemplo: def sign ( x ): if x > 0 : return 'positive' elif x < 0 : return 'negative' else : return 'zero' for x in [ - 1 , 0 , 1 ]: print ( sign ( x )) Run Clear Vamos a definir funciones que toman argumentos, y opcionalmente argumentos keyword, como esto: def hello ( name , loud = False ): if loud : print ( 'HELLO, %s ' % name . upper ()) else : print ( 'Hello, %s !' % name ) hello ( 'Bob' ) hello ( 'Fred' , loud = True ) Run Clear Hay mucha informaci\u00f3n acerca de como definir funciones en Python en la documentaci\u00f3n .","title":"Funciones"},{"location":"tutorials/python/#funciones-lambda","text":"Python tiene una sintaxis definida para funciones an\u00f3nimas, lambda functions , est\u00e1n son bastante utiles para pasarlas como argumento a otras funciones: # importamos la funcion reduce from functools import reduce # definimos una funcion anonima y se la asignamos a una variable x x = lambda l : l ** 2 # podemos usar la funcion anonima como cualquier otra funcion print ( x ( 2 )) # pero lo mas importante es que la podemos pasar como argumento def foo ( f ): return f ( 4 ) print ( foo ( lambda x : x + 1 )) # aunque esto no implica que con las funciones normales puedan hacer esto... def bar ( x ): return x ** 2 print ( foo ( bar )) # por lo general se utilizan con las funciones map, reduce y filter de python que trabajan con listas print ( list ( map ( lambda x : x ** 2 , [ 1 , 2 , 3 , 4 , 5 ]))) print ( list ( filter ( lambda x : x > 2 , [ 1 , 2 , 3 , 4 , 5 ]))) print ( reduce ( lambda a , b : a + b , [ 1 , 2 , 3 , 4 , 5 ])) # pero tambien se ven muy seguido cuando se trabaja con el paradigma MapReduce y Spark # que es parte de su proyecto y este laboratorio !!! Run Clear","title":"Funciones Lambda"},{"location":"tutorials/python/#clases","text":"La sintaxis para definir clases en Python es bastante simple: class Greeter : # Constructor def __init__ ( self , name ): self . name = name # Crea un atributo para la clase # Un metodo de la clase def greet ( self , loud = False ): if loud : print ( 'HELLO, %s !' % self . name . upper ()) else : print ( 'Hello, %s ' % self . name ) # Crea una instancia de la clase g = Greeter ( 'Fred' ) # Llama al metodo de la clase; imprime \"Hello, Fred\" g . greet () # Llama al metodo de la clase; imprime \"HELLO, FRED!\" g . greet ( loud = True ) Run Clear Con esto concluimos el tutorial de Python 3, pueden obtener m\u00e1s informaci\u00f3n en la documentaci\u00f3n de Python 3 oficial o incluso seguir el tutorial completo que ellos tienen.","title":"Clases"}]}